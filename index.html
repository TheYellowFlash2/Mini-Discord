<!DOCTYPE html>
<html lang="en" class="dark">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Mini-Discord</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      darkMode: 'class',
      theme: {
        extend: {
          colors: {
            discord: {
              dark: '#36393f',
              darker: '#2f3136',
              darkest: '#202225',
              blurple: '#5865F2',
              green: '#57F287',
              yellow: '#FEE75C',
              red: '#ED4245',
            }
          }
        }
      }
    }
  </script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    * { font-family: 'Inter', system-ui, sans-serif; }
    .scrollbar-thin::-webkit-scrollbar { width: 8px; height: 8px; }
    .scrollbar-thin::-webkit-scrollbar-track { background: transparent; }
    .scrollbar-thin::-webkit-scrollbar-thumb { background: #202225; border-radius: 4px; }
    .scrollbar-thin::-webkit-scrollbar-thumb:hover { background: #36393f; }
    .message-group:hover { background: rgba(4,4,5,0.07); }
    @keyframes fadeIn { from { opacity: 0; transform: translateY(-10px); } to { opacity: 1; transform: translateY(0); } }
    .modal-animate { animation: fadeIn 0.2s ease-out; }
    .skeleton { background: linear-gradient(90deg, #36393f 25%, #2f3136 50%, #36393f 75%); background-size: 200% 100%; animation: skeleton 1.5s infinite; }
    @keyframes skeleton { 0% { background-position: 200% 0; } 100% { background-position: -200% 0; } }
    .toast-enter { animation: toastIn 0.3s ease-out; }
    @keyframes toastIn { from { opacity: 0; transform: translateY(-20px); } to { opacity: 1; transform: translateY(0); } }
    .typing-dot { animation: typingBounce 1.4s infinite; }
    .typing-dot:nth-child(2) { animation-delay: 0.2s; }
    .typing-dot:nth-child(3) { animation-delay: 0.4s; }
    @keyframes typingBounce { 0%, 60%, 100% { transform: translateY(0); } 30% { transform: translateY(-4px); } }
    .gif-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); gap: 4px; }
    .emoji-btn { border: 1px solid rgba(255,255,255,0.1); }
    .emoji-btn:hover { border-color: rgba(255,255,255,0.3); background: rgba(255,255,255,0.05); }
    .context-menu { min-width: 180px; }
    .context-item:hover { background: rgba(255,255,255,0.06); }
    @media (max-width: 767px) {
      #channel-sidebar {
        position: fixed;
        left: 72px;
        top: 0;
        bottom: 0;
        width: min(84vw, 320px);
        z-index: 70;
        display: flex;
      }
      #members-sidebar {
        position: fixed;
        right: 0;
        top: 0;
        bottom: 0;
        width: min(82vw, 320px);
        z-index: 70;
        display: flex;
      }
      #btn-toggle-channel {
        top: max(8px, env(safe-area-inset-top));
        left: 80px;
      }
      #messages-container {
        padding-left: 10px;
        padding-right: 10px;
      }
      #message-input-area {
        padding-bottom: calc(12px + env(safe-area-inset-bottom));
      }
      #voice-channel-panel {
        padding-left: 10px;
        padding-right: 10px;
      }
    }
  </style>
</head>
<body class="bg-discord-darkest text-gray-100 min-h-screen overflow-hidden">
  <!-- ========== CONFIG ========== -->
  <script>
    const firebaseConfig = {
      apiKey: "AIzaSyAnUTCjnbxCEeMpmqfxsfzryUpiVqpp3SE",
      authDomain: "mini-discord-b0977.firebaseapp.com",
      projectId: "mini-discord-b0977",
      storageBucket: "mini-discord-b0977.firebasestorage.app",
      messagingSenderId: "999795104831",
      appId: "1:999795104831:web:f76fdf43d6c889e8deec8a",
      measurementId: "G-V0K3TN8183"
    };
    const GIPHY_API_KEY = "peAMzd2AaeUlKwbMp86bp1wLxHorJFXu";
    const MISTRAL_API_KEY = "ZtJVf6hjKb3FWeVgsFApxIpqs2oKg2U3";
    const DEBUG_MODE = false;
  </script>
  <!-- ========== END CONFIG ========== -->

  <div id="app" class="flex h-screen">
    <div id="auth-screen" class="flex-1 flex items-center justify-center bg-discord-darkest p-4">
      <div class="w-full max-w-md text-center">
        <h1 class="text-4xl font-bold text-white mb-2">Mini-Discord</h1>
        <p class="text-gray-400 mb-8">A Discord-like chat experience</p>
        <div class="space-y-3">
          <button id="btn-login" class="w-full py-3 px-4 bg-discord-blurple hover:bg-indigo-600 rounded font-medium transition">Login</button>
          <button id="btn-signup" class="w-full py-3 px-4 bg-discord-dark hover:bg-discord-darker rounded font-medium transition">Create Account</button>
          <button id="btn-join-invite" class="w-full py-3 px-4 bg-discord-dark hover:bg-discord-darker rounded font-medium transition">Join with Invite</button>
        </div>
      </div>
    </div>

    <div id="main-app" class="hidden flex-1 flex h-screen overflow-hidden">
      <aside id="server-sidebar" class="w-[72px] bg-discord-darkest flex flex-col items-center py-3 gap-2 flex-shrink-0 scrollbar-thin overflow-y-auto">
        <button id="btn-add-server" class="w-12 h-12 rounded-2xl bg-discord-dark hover:bg-discord-green hover:text-discord-darkest flex items-center justify-center transition text-2xl font-light" title="Create Server">+</button>
        <button id="btn-join-server" class="w-12 h-12 rounded-2xl bg-discord-dark hover:bg-discord-blurple flex items-center justify-center transition text-sm font-medium" title="Join Server">Join</button>
        <div id="server-list" class="flex flex-col gap-2"></div>
      </aside>

      <aside id="channel-sidebar" class="w-60 bg-discord-darker flex flex-col flex-shrink-0 hidden md:flex">
        <div class="h-12 px-4 flex items-center justify-between border-b border-discord-dark shadow-sm">
          <div class="flex items-center gap-2 min-w-0">
            <span id="current-server-name" class="font-semibold truncate">Select Server</span>
            <button id="btn-admin-menu" class="flex-shrink-0 p-1 rounded text-gray-400 hover:text-white hover:bg-discord-dark hidden" title="Server Admin">âš™</button>
          </div>
          <div class="flex gap-2 flex-shrink-0">
            <button id="btn-invite" class="text-xs px-2 py-1 rounded bg-discord-dark hover:bg-discord-blurple text-gray-300 hover:text-white transition font-medium">Invite</button>
            <button id="btn-leave-server" class="text-xs px-2 py-1 rounded bg-discord-dark hover:bg-discord-red text-gray-300 hover:text-white transition font-medium">Leave</button>
          </div>
        </div>
        <div class="flex-1 overflow-y-auto scrollbar-thin py-2">
          <div class="px-2">
            <button id="btn-add-channel" class="w-full text-left px-2 py-1.5 rounded text-gray-400 hover:bg-discord-dark hover:text-white flex items-center gap-2 text-sm">
              <span>#</span> Channels
            </button>
            <div id="channel-list" class="mt-1"></div>
          </div>
        </div>
        <div class="p-2 border-t border-discord-dark">
          <div id="user-pill" class="flex items-center gap-3 px-2 py-2 rounded hover:bg-discord-dark cursor-pointer">
            <div class="w-8 h-8 rounded-full bg-discord-blurple flex items-center justify-center overflow-hidden">
              <img id="user-avatar" class="w-full h-full object-cover" src="" alt="" onerror="this.style.display='none';this.nextElementSibling.style.display='flex';">
              <span id="user-initial" class="hidden">?</span>
            </div>
            <div class="flex-1 min-w-0 hidden md:block">
              <div id="user-display-name" class="text-sm font-medium truncate">User</div>
              <div id="user-status" class="text-xs text-gray-500">Online</div>
            </div>
          </div>
        </div>
      </aside>

      <button id="btn-toggle-channel" class="md:hidden fixed top-4 left-20 z-40 bg-discord-dark p-2 rounded">â˜°</button>

      <main class="flex-1 flex flex-col min-w-0 bg-discord-dark">
        <header class="h-12 px-4 flex items-center border-b border-discord-dark shadow-sm flex-shrink-0">
          <span id="channel-header-name" class="font-semibold"># general</span>
          <div class="ml-4 flex-1"></div>
          <button id="btn-members-toggle" class="p-2 hover:bg-discord-darker rounded lg:hidden">ğŸ‘¥</button>
        </header>

        <div id="voice-channel-panel" class="hidden p-4 border-b border-discord-dark bg-discord-darker/40">
          <div class="flex items-center justify-between gap-3 flex-wrap">
            <div>
              <div class="text-sm text-gray-300">Voice Channel</div>
              <div id="voice-channel-name" class="text-white font-medium">Voice</div>
            </div>
            <div class="flex items-center gap-2">
              <button id="btn-voice-join" class="px-3 py-1.5 rounded bg-discord-green text-discord-darkest text-sm font-medium hover:brightness-95">Join Voice</button>
              <button id="btn-voice-leave" class="hidden px-3 py-1.5 rounded bg-discord-red text-white text-sm font-medium hover:bg-red-500">Leave Voice</button>
            </div>
          </div>
          <div class="mt-3">
            <div class="text-xs uppercase tracking-wide text-gray-500 mb-1">In Voice</div>
            <div id="voice-members-list" class="space-y-1 text-sm text-gray-300"></div>
          </div>
        </div>

        <div id="messages-container" class="flex-1 overflow-y-auto scrollbar-thin p-4 flex flex-col-reverse">
          <div id="messages-loading" class="flex justify-center py-8">
            <div class="animate-spin w-8 h-8 border-2 border-discord-blurple border-t-transparent rounded-full"></div>
          </div>
          <div id="messages-list" class="space-y-4"></div>
          <div id="load-more" class="hidden py-4 text-center">
            <button id="btn-load-more" class="text-discord-blurple hover:underline text-sm">Load older messages</button>
          </div>
        </div>

        <div id="typing-indicator" class="hidden px-4 py-2 text-sm text-gray-400">
          <span id="typing-users"></span> <span class="typing-dot">.</span><span class="typing-dot">.</span><span class="typing-dot">.</span>
        </div>

        <div id="message-input-area" class="p-4 flex-shrink-0">
          <div id="reply-preview" class="hidden mb-2 px-3 py-2 rounded-l border-l-4 border-discord-blurple bg-discord-darker/50 flex items-center justify-between">
            <div class="min-w-0 flex-1">
              <span class="text-xs text-discord-blurple font-medium">Replying to </span>
              <span class="text-sm text-gray-300 truncate" id="reply-preview-name"></span>
              <p class="text-xs text-gray-500 truncate mt-0.5" id="reply-preview-text"></p>
            </div>
            <button type="button" id="reply-cancel" class="text-gray-400 hover:text-white p-1 flex-shrink-0">âœ•</button>
          </div>
          <div class="flex items-end gap-2">
            <div class="flex-1 flex items-center gap-2 bg-discord-darker rounded-lg px-4 py-2 min-h-[44px]">
              <button id="btn-emoji" class="text-gray-400 hover:text-white p-1" title="Emoji">ğŸ˜€</button>
              <button id="btn-gif" class="text-gray-400 hover:text-white p-1" title="GIF">GIF</button>
              <input type="file" id="file-attach" accept="*/*" class="hidden">
              <button id="btn-attach" class="text-gray-400 hover:text-white p-1 text-lg" title="Upload file">ğŸ“</button>
              <input id="message-input" type="text" placeholder="Message #general" class="flex-1 bg-transparent outline-none text-sm py-1" maxlength="2000">
              <div id="attachment-preview" class="hidden flex items-center gap-2 flex-wrap"></div>
            </div>
            <button id="btn-send" class="p-2 rounded-full bg-discord-blurple hover:bg-indigo-600 disabled:opacity-50 disabled:cursor-not-allowed transition">
              <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 24 24"><path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z"/></svg>
            </button>
          </div>
        </div>
      </main>

      <aside id="members-sidebar" class="w-60 bg-discord-darker flex flex-col flex-shrink-0 hidden lg:flex">
        <div class="h-12 px-4 flex items-center border-b border-discord-dark">
          <span class="font-semibold text-sm">Members</span>
        </div>
        <div id="members-list" class="flex-1 overflow-y-auto scrollbar-thin p-2"></div>
      </aside>
    </div>
  </div>

  <div id="modal-backdrop" class="fixed inset-0 bg-black/50 z-50 hidden items-center justify-center p-4" style="display: none;">
    <div id="modal-content" class="bg-discord-darker rounded-lg shadow-xl max-w-md w-full max-h-[90vh] overflow-y-auto modal-animate" onclick="event.stopPropagation()">
      <div class="p-6">
        <div class="flex items-center justify-between mb-4">
          <h2 id="modal-title" class="text-xl font-semibold">Modal</h2>
          <button id="modal-close" class="text-gray-400 hover:text-white p-1">âœ•</button>
        </div>
        <div id="modal-body"></div>
      </div>
    </div>
  </div>

  <div id="toast-container" class="fixed bottom-4 right-4 z-[100] flex flex-col gap-2"></div>
  <div id="context-menu" class="context-menu fixed z-[120] hidden bg-discord-darker border border-discord-dark rounded shadow-xl py-1"></div>

  <script type="module">
    import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
    import { getAuth, createUserWithEmailAndPassword, signInWithEmailAndPassword, signOut, onAuthStateChanged, deleteUser as firebaseDeleteUser } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js';
    import { getFirestore, collection, doc, setDoc, getDoc, getDocs, addDoc, updateDoc, deleteDoc, query, where, orderBy, limit, startAfter, onSnapshot, serverTimestamp, increment } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js';
    import { getStorage, ref, uploadBytes, getDownloadURL, deleteObject } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-storage.js';

    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getFirestore(app);
    const storage = getStorage(app);

    let currentUser = null;
    let currentServerId = null;
    let currentChannelId = null;
    let servers = {};
    let channels = {};
    let members = {};
    let memberUserData = {};
    let memberUserUnsubs = {};
    let messages = {};
    let typingUsers = {};
    let userPresence = {};
    let messageListeners = [];
    let channelUnsub = null;
    let unsubPresence = null;
    let unsubMembers = null;
    let unsubMyMemberships = null;
    let unsubReports = null;
    let unsubActiveSuspension = null;
    let unsubPublicSuspensionLifecycle = null;
    let unsubServerBannedAccounts = null;
    let unsubVoiceMembers = null;
    let reportAlertInitialized = false;
    const seenReportAlerts = new Set();
    let openReports = {};
    let lastSuspensionNoticeKey = '';
    let isHandlingPublicSuspensionRedirect = false;
    let lastSafeBriefingKey = '';
    let serverBannedAccounts = {};
    let voiceMembers = {};
    let activeVoiceChannelId = null;
    let activeVoiceStream = null;
    let voicePeerConnections = {};
    let voiceSignalUnsubs = {};
    let handledVoiceSignalsByPeer = {};
    let remoteVoiceAudioEls = {};
    let serversLoadVersion = 0;
    let membersLoadVersion = 0;
    let presenceInterval = null;
    let lastDoc = null;
    const MESSAGE_LIMIT = 50;
    const PRESENCE_HEARTBEAT_MS = 30000;
    const PRESENCE_STALE_MS = 90000;
    const ATTACHMENT_TTL_MS = 2 * 24 * 60 * 60 * 1000;
    const ATTACHMENT_CLEANUP_INTERVAL_MS = 15 * 60 * 1000;
    let pendingAttachments = [];
    const PUBLIC_SERVER_ID = 'public';
    const BOT_USER_ID = 'global-bot-mistral';
    const BOT_DISPLAY_NAME = 'Mistral';
    const BOT_MODEL = 'pixtral-12b-2409';
    const APP_STARTED_AT = Date.now();
    const BOT_QUIPS = [
      'Keep your channels tidy and your logs clear.',
      'Moderation is consistency over intensity.',
      'Short messages, sharp intent.'
    ];
    const BOT_JOKES = [
      'Why do programmers love dark mode? Because light attracts bugs.',
      'I would tell a UDP joke, but you might not get it.',
      'A SQL query walks into a bar, walks up to two tables and asks: "Can I join you?"'
    ];
    const BOT_EIGHT_BALL = [
      'Yes.', 'No.', 'Likely.', 'Unlikely.', 'Ask again soon.', 'Definitely.', 'Not today.', 'Signs point to yes.'
    ];
    const BOT_COMMAND_HELP = [
      '/help - list supported commands',
      '/ping - latency check',
      '/time - current local time',
      '/uptime - bot session uptime',
      '/roll XdY - roll dice, e.g. /roll 2d6',
      '/coinflip - heads or tails',
      '/choose a | b | c - random choice',
      '/8ball question - random answer',
      '/serverinfo - server summary',
      '/members - member count',
      '/whoami - your user details',
      '/joke - random dev joke',
      '/quote - random bot quote'
    ];
    const BOT_CONVERSATION_IDLE_MS = 6 * 60 * 1000;
    const botConversationByChannel = {};
    const PROFANITY_WORDS = ['fuck','fucking','shit','bitch','asshole','bastard','cunt','nigger','nigga','faggot','retard','whore','slut','dick','pussy'];
    const moderationCooldownByUser = {};
    let attachmentCleanupInterval = null;
    let replyingTo = null;
    let activeMemberProfileUserId = null;
    let contextMenuMessage = null;
    const NOTIFICATION_PREF_KEY = 'mini_discord_notifications_enabled';
    let notificationsEnabled = localStorage.getItem(NOTIFICATION_PREF_KEY) === 'true';
    const REPORT_REASONS = ['Harassment', 'Spam', 'Hate Speech', 'Threats', 'Impersonation', 'Other'];
    const BOT_MEMORY_LIMIT = 6;
    const VOICE_RTC_CONFIG = {
      iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
    };

    const EMOJI_CATEGORIES = {
      'Smileys': ['ğŸ˜€','ğŸ˜ƒ','ğŸ˜„','ğŸ˜','ğŸ˜†','ğŸ˜…','ğŸ¤£','ğŸ˜‚','ğŸ™‚','ğŸ™ƒ','ğŸ˜‰','ğŸ˜Š','ğŸ˜‡','ğŸ¥°','ğŸ˜','ğŸ¤©','ğŸ˜˜','ğŸ˜—','â˜º','ğŸ˜š','ğŸ˜™','ğŸ¥²','ğŸ˜‹','ğŸ˜›','ğŸ˜œ','ğŸ¤ª','ğŸ˜','ğŸ¤‘','ğŸ¤—','ğŸ¤­','ğŸ¤«','ğŸ¤”','ğŸ¤','ğŸ¤¨','ğŸ˜','ğŸ˜‘','ğŸ˜¶','ğŸ˜','ğŸ˜’','ğŸ™„','ğŸ˜¬','ğŸ¤¥','ğŸ˜Œ','ğŸ˜”','ğŸ˜ª','ğŸ¤¤','ğŸ˜´','ğŸ˜·','ğŸ¤’','ğŸ¤•','ğŸ¤¢','ğŸ¤®','ğŸ¤§','ğŸ¥µ','ğŸ¥¶','ğŸ¥´','ğŸ˜µ','ğŸ¤¯','ğŸ¤ ','ğŸ¥³','ğŸ¥¸'],
      'Gestures': ['ğŸ‘‹','ğŸ¤š','ğŸ–','âœ‹','ğŸ––','ğŸ‘Œ','ğŸ¤Œ','ğŸ¤','âœŒ','ğŸ¤','ğŸ¤Ÿ','ğŸ¤˜','ğŸ¤™','ğŸ‘ˆ','ğŸ‘‰','ğŸ‘†','ğŸ–•','ğŸ‘‡','â˜','ğŸ‘','ğŸ‘','âœŠ','ğŸ‘Š','ğŸ¤›','ğŸ¤œ','ğŸ‘','ğŸ™Œ','ğŸ‘','ğŸ¤²','ğŸ¤','ğŸ™','âœ','ğŸ’…','ğŸ¤³','ğŸ’ª','ğŸ¦¾','ğŸ¦¿','ğŸ¦µ','ğŸ¦¶','ğŸ‘‚','ğŸ¦»','ğŸ‘ƒ','ğŸ§ ','ğŸ«€','ğŸ«','ğŸ¦·','ğŸ¦´','ğŸ‘€','ğŸ‘','ğŸ‘…','ğŸ‘„'],
      'Hearts': ['â¤ï¸','ğŸ§¡','ğŸ’›','ğŸ’š','ğŸ’™','ğŸ’œ','ğŸ–¤','ğŸ¤','ğŸ¤','ğŸ’”','â£ï¸','ğŸ’•','ğŸ’','ğŸ’“','ğŸ’—','ğŸ’–','ğŸ’˜','ğŸ’','ğŸ’Ÿ','â™¥ï¸'],
      'Symbols': ['âœ–ï¸','â•','â–','â—','â™¾ï¸','ğŸ’²','ğŸ’±','â„¢ï¸','Â©ï¸','Â®ï¸','ã€°ï¸','â°','â¿','ğŸ”','ğŸ”™','ğŸ”›','ğŸ”œ','ğŸ”š','ã€½ï¸','âœ³ï¸','â‡ï¸','â€¼ï¸','â‰ï¸','â“','â”','â—','â•','ğŸ”…','ğŸ”†','âš ï¸','ğŸš¸','ğŸ”±','âšœï¸','ğŸ”°','â™»ï¸','âœ…','ğŸˆ¯','ğŸ’¹','â‡ï¸','âœ³ï¸','â','ğŸŒ','ğŸ’ ','â“‚ï¸','ğŸŒ€','ğŸ’¤','ğŸ§','ğŸš¾','â™¿','ğŸ…¿ï¸','ğŸ›—','ğŸˆ³','ğŸˆ‚ï¸','ğŸ›‚','ğŸ›ƒ','ğŸ›„','ğŸ›…','ğŸš¹','ğŸšº','ğŸš¼','âš§ï¸','ğŸš»','â™»ï¸','â›”','ğŸš«','ğŸš³','ğŸš­','ğŸš¯','ğŸš±','ğŸš·','ğŸ“µ','ğŸ”','â˜¢ï¸','â˜£ï¸','â¬†ï¸','â†—ï¸','â¡ï¸','â†˜ï¸','â¬‡ï¸','â†™ï¸','â¬…ï¸','â†–ï¸','â†•ï¸','â†”ï¸','â†©ï¸','â†ªï¸','â¤´ï¸','â¤µï¸','ğŸ”ƒ','ğŸ”„','ğŸ”™','ğŸ”›','ğŸ”œ','ğŸ”']
    };

    function showToast(message, type = 'info') {
      const container = document.getElementById('toast-container');
      const toast = document.createElement('div');
      toast.className = 'bg-discord-darker border border-discord-dark px-4 py-3 rounded shadow-lg toast-enter flex items-center gap-2';
      const colors = { success: 'text-discord-green', error: 'text-discord-red', info: 'text-gray-300' };
      toast.innerHTML = `<span class="${colors[type] || colors.info}">${message}</span>`;
      container.appendChild(toast);
      setTimeout(() => toast.remove(), 3000);
    }

    function formatTime(timestamp) {
      if (!timestamp) return '';
      const d = timestamp?.toDate ? timestamp.toDate() : new Date(timestamp);
      const now = new Date();
      const diff = now - d;
      if (diff < 60000) return 'Just now';
      if (diff < 3600000) return `${Math.floor(diff/60000)}m ago`;
      if (diff < 86400000) return d.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
      if (diff < 604800000) return d.toLocaleDateString([], { weekday: 'short' });
      return d.toLocaleDateString();
    }

    function escapeHtml(text) {
      if (!text) return '';
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    function formatFileSize(bytes) {
      const n = Number(bytes);
      if (!Number.isFinite(n) || n <= 0) return '';
      const units = ['B', 'KB', 'MB', 'GB', 'TB'];
      let size = n;
      let unitIndex = 0;
      while (size >= 1024 && unitIndex < units.length - 1) {
        size /= 1024;
        unitIndex++;
      }
      const rounded = size >= 100 ? Math.round(size) : Math.round(size * 10) / 10;
      return `${rounded} ${units[unitIndex]}`;
    }

    function isImageAttachment(att) {
      if (!att?.url) return false;
      const type = (att.type || '').toLowerCase();
      const mimeType = (att.mimeType || '').toLowerCase();
      if (type === 'image' || mimeType.startsWith('image/')) return true;
      return /\.(gif|png|jpe?g|webp|bmp|svg)$/i.test(att.url);
    }

    function debounce(fn, ms) {
      let t;
      return (...args) => { clearTimeout(t); t = setTimeout(() => fn(...args), ms); };
    }

    function notificationsSupported() {
      return typeof Notification !== 'undefined';
    }

    function getNotificationPermissionLabel() {
      if (!notificationsSupported()) return 'Unsupported';
      if (Notification.permission === 'granted') return 'Granted';
      if (Notification.permission === 'denied') return 'Denied';
      return 'Not requested';
    }

    function updateNotificationToggleUI() {
      const btn = document.getElementById('profile-notifications-toggle');
      const status = document.getElementById('profile-notification-status');
      if (btn) {
        btn.textContent = notificationsEnabled ? 'On' : 'Off';
        btn.className = `px-3 py-1 rounded text-sm font-medium transition ${notificationsEnabled ? 'bg-discord-blurple hover:bg-indigo-600 text-white' : 'bg-discord-dark hover:bg-discord-darker text-gray-300'}`;
      }
      if (status) status.textContent = `Permission: ${getNotificationPermissionLabel()}`;
    }

    async function setNotificationsEnabled(enabled) {
      notificationsEnabled = !!enabled;
      localStorage.setItem(NOTIFICATION_PREF_KEY, String(notificationsEnabled));
      if (notificationsEnabled) {
        if (!notificationsSupported()) {
          notificationsEnabled = false;
          localStorage.setItem(NOTIFICATION_PREF_KEY, 'false');
          showToast('Notifications are not supported in this browser', 'error');
          updateNotificationToggleUI();
          return;
        }
        if (Notification.permission === 'default') {
          const permission = await Notification.requestPermission();
          if (permission !== 'granted') {
            notificationsEnabled = false;
            localStorage.setItem(NOTIFICATION_PREF_KEY, 'false');
            showToast('Notification permission was not granted', 'error');
          } else {
            showToast('Desktop notifications enabled', 'success');
          }
        } else if (Notification.permission === 'denied') {
          notificationsEnabled = false;
          localStorage.setItem(NOTIFICATION_PREF_KEY, 'false');
          showToast('Notifications are blocked in browser settings', 'error');
        } else {
          showToast('Desktop notifications enabled', 'success');
        }
      } else {
        showToast('Desktop notifications disabled', 'info');
      }
      updateNotificationToggleUI();
    }

    function maybeNotifyForMessage(messageId, messageData) {
      if (!notificationsEnabled || !notificationsSupported()) return;
      if (Notification.permission !== 'granted') return;
      if (!messageData || messageData.userId === currentUser?.uid) return;
      if (!document.hidden) return;
      const sender = getUserDisplayName(memberUserData[messageData.userId], messageData) || 'Someone';
      const channelName = channels[messageData.channelId]?.name || 'channel';
      const text = (messageData.text || '').trim();
      const attachmentText = (messageData.attachments || []).length ? 'Sent an attachment' : 'New message';
      const body = text ? text.slice(0, 140) : attachmentText;
      const notif = new Notification(`${sender} in #${channelName}`, {
        body,
        icon: messageData.photoURL || memberUserData[messageData.userId]?.photoURL || '',
        tag: `msg-${messageId}`
      });
      notif.onclick = () => window.focus();
    }

    async function resolveReport(reportId, action = 'dismissed', reportedUserId = '') {
      if (!reportId || !isAdmin()) return;
      try {
        await updateDoc(doc(db, 'reports', reportId), {
          status: action === 'kicked' ? 'actioned' : 'dismissed',
          action,
          resolvedBy: currentUser.uid,
          resolvedAt: serverTimestamp()
        });
      } catch (_) {}
      delete openReports[reportId];
      renderAdminReportsInbox();
      if (action === 'kicked' && reportedUserId) {
        try {
          await kickUserFromServer(currentServerId, reportedUserId, 'User kicked from report');
        } catch (_) {}
      }
    }

    async function fetchOpenReportsForCurrentServer() {
      if (!currentServerId || !currentUser?.uid || !isAdmin()) {
        openReports = {};
        return;
      }
      const snap = await getDocs(query(
        collection(db, 'reports'),
        where('serverId', '==', currentServerId),
        limit(100)
      ));
      const nextOpen = {};
      snap.docs.forEach((d) => {
        const data = d.data();
        if (data?.status === 'open') nextOpen[d.id] = { id: d.id, ...data };
      });
      openReports = nextOpen;
    }

    function renderAdminReportsInbox() {
      const host = document.getElementById('admin-reports-inbox');
      if (!host) return;
      const rows = Object.values(openReports)
        .filter(r => r.serverId === currentServerId && r.status === 'open')
        .sort((a, b) => {
          const at = a.createdAt?.toDate ? a.createdAt.toDate().getTime() : 0;
          const bt = b.createdAt?.toDate ? b.createdAt.toDate().getTime() : 0;
          return bt - at;
        })
        .map((r) => {
          const reportedUser = memberUserData[r.reportedUserId] || {};
          const reporterUser = memberUserData[r.reportedBy] || {};
          const reportedName = getUserDisplayName(reportedUser, {}) || 'Unknown';
          const reporterName = getUserDisplayName(reporterUser, { displayName: r.reportedByDisplayName || 'User' }) || 'User';
          const reason = (r.reason || 'Other').trim();
          const details = (r.details || '').trim();
          return `
            <div class="rounded border border-discord-dark bg-discord-darkest/40 p-3">
              <div class="flex items-center justify-between gap-2">
                <div class="text-sm text-gray-200">${escapeHtml(reportedName)} <span class="text-gray-500">reported by ${escapeHtml(reporterName)}</span></div>
                <span class="text-xs text-gray-500">${formatTime(r.createdAt)}</span>
              </div>
              <div class="text-xs text-amber-300 mt-1">Reason: ${escapeHtml(reason)}</div>
              ${details ? `<div class="text-xs text-gray-400 mt-1">${escapeHtml(details)}</div>` : ''}
              <div class="mt-2 flex gap-2">
                <button type="button" class="text-xs px-2 py-1 rounded bg-discord-red hover:bg-red-500" data-report-inbox-kick="${r.id}" data-reported-user="${r.reportedUserId}">Kick</button>
                <button type="button" class="text-xs px-2 py-1 rounded bg-discord-dark hover:bg-discord-darker" data-report-inbox-dismiss="${r.id}">Dismiss</button>
              </div>
            </div>
          `;
        }).join('');
      host.innerHTML = rows || '<p class="text-gray-500 py-2">No open reports</p>';
      host.querySelectorAll('[data-report-inbox-kick]').forEach(btn => btn.onclick = async () => {
        await resolveReport(btn.dataset.reportInboxKick, 'kicked', btn.dataset.reportedUser || '');
      });
      host.querySelectorAll('[data-report-inbox-dismiss]').forEach(btn => btn.onclick = async () => {
        await resolveReport(btn.dataset.reportInboxDismiss, 'dismissed');
      });
    }

    function maybeNotifyForReport(reportId, reportData) {
      if (!reportData || reportData.reportedBy === currentUser?.uid) return;
      const reportedName = getUserDisplayName(memberUserData[reportData.reportedUserId], {}) || 'a user';
      const reporterName = getUserDisplayName(memberUserData[reportData.reportedBy], {}) || 'Someone';
      const reason = reportData.reason || 'Rule violation';
      if (document.hidden && notificationsEnabled && notificationsSupported() && Notification.permission === 'granted') {
        const notif = new Notification(`New report: ${reportedName}`, {
          body: `${reporterName} reported ${reportedName} for ${reason}`,
          tag: `report-${reportId}`
        });
        notif.onclick = () => {
          window.focus();
          renderAdminModal();
        };
        return;
      }
      const container = document.getElementById('toast-container');
      const toast = document.createElement('div');
      toast.className = 'bg-discord-darker border border-amber-600/60 px-4 py-3 rounded shadow-lg toast-enter';
      const details = (reportData.details || '').trim();
      toast.innerHTML = `
        <div class="text-sm">
          <div class="font-semibold text-amber-300">New user report</div>
          <div class="text-gray-200 mt-1">${escapeHtml(reporterName)} reported ${escapeHtml(reportedName)}</div>
          <div class="text-xs text-gray-400 mt-1">Reason: ${escapeHtml(reason)}</div>
          ${details ? `<div class="text-xs text-gray-500 mt-1 max-w-[260px] truncate">"${escapeHtml(details)}"</div>` : ''}
          <div class="mt-2 flex gap-2">
            <button type="button" data-report-kick="${reportId}" class="text-xs px-2 py-1 rounded bg-discord-red hover:bg-red-500">Kick</button>
            <button type="button" data-report-dismiss="${reportId}" class="text-xs px-2 py-1 rounded bg-discord-dark hover:bg-discord-darkest">Dismiss</button>
          </div>
        </div>
      `;
      container.appendChild(toast);
      const kickBtn = toast.querySelector(`[data-report-kick="${reportId}"]`);
      const dismissBtn = toast.querySelector(`[data-report-dismiss="${reportId}"]`);
      if (kickBtn) {
        kickBtn.onclick = async () => {
          await resolveReport(reportId, 'kicked', reportData.reportedUserId);
          toast.remove();
        };
      }
      if (dismissBtn) {
        dismissBtn.onclick = async () => {
          await resolveReport(reportId, 'dismissed', reportData.reportedUserId);
          toast.remove();
        };
      }
      setTimeout(() => toast.remove(), 25000);
    }

    function subscribeReports() {
      if (unsubReports) { unsubReports(); unsubReports = null; }
      reportAlertInitialized = false;
      openReports = {};
      if (!currentServerId || !currentUser?.uid || !isAdmin()) return;
      const q = query(
        collection(db, 'reports'),
        where('serverId', '==', currentServerId),
        limit(100)
      );
      unsubReports = onSnapshot(q, (snap) => {
        const nextOpen = {};
        snap.docs.forEach((d) => {
          const data = d.data();
          if (data?.status === 'open') nextOpen[d.id] = { id: d.id, ...data };
        });
        openReports = nextOpen;
        renderAdminReportsInbox();
        if (!reportAlertInitialized) {
          Object.values(openReports).forEach((d) => {
            if (!seenReportAlerts.has(d.id)) {
              seenReportAlerts.add(d.id);
              maybeNotifyForReport(d.id, d);
            }
          });
          reportAlertInitialized = true;
          return;
        }
        snap.docChanges().forEach((change) => {
          const data = change.doc.data() || {};
          if (data.status !== 'open') return;
          if (change.type !== 'added' && change.type !== 'modified') return;
          if (!seenReportAlerts.has(change.doc.id)) {
            seenReportAlerts.add(change.doc.id);
            maybeNotifyForReport(change.doc.id, data);
          }
        });
      }, (err) => {
        showToast('Report alerts failed to subscribe', 'error');
        if (DEBUG_MODE) console.error('Report subscription failed', err);
      });
    }

    function renderReportUserModal(userId) {
      const memberData = memberUserData[userId] || {};
      const displayName = getUserDisplayName(memberData, {}) || 'Unknown';
      modal.open('Report User', `
        <form id="report-user-form" class="space-y-4">
          <p class="text-sm text-gray-400">Reporting <span class="text-white font-medium">${escapeHtml(displayName)}</span></p>
          <div>
            <label class="block text-sm text-gray-400 mb-1">Reason</label>
            <select id="report-reason" class="w-full bg-discord-dark border border-discord-darkest rounded px-3 py-2 outline-none focus:border-discord-blurple">
              ${REPORT_REASONS.map((r) => `<option value="${escapeHtml(r)}">${escapeHtml(r)}</option>`).join('')}
            </select>
          </div>
          <div>
            <label class="block text-sm text-gray-400 mb-1">Details</label>
            <textarea id="report-details" rows="4" maxlength="300" placeholder="What happened?" class="w-full bg-discord-dark border border-discord-darkest rounded px-3 py-2 outline-none focus:border-discord-blurple resize-none"></textarea>
          </div>
          <button type="submit" class="w-full py-2 bg-discord-red hover:bg-red-500 rounded font-medium">Report User</button>
        </form>
      `);
      document.getElementById('report-user-form').onsubmit = async (e) => {
        e.preventDefault();
        if (!currentUser?.uid || !currentServerId || !userId) return;
        if (userId === currentUser.uid) { showToast('You cannot report yourself', 'error'); return; }
        if (userId === BOT_USER_ID) { showToast('Cannot report bot account', 'error'); return; }
        const reason = document.getElementById('report-reason').value;
        const details = document.getElementById('report-details').value.trim();
        try {
          const reportPayload = {
            serverId: currentServerId,
            channelId: currentChannelId || null,
            status: 'open',
            reason: reason || 'Other',
            details: details.slice(0, 300),
            reportedUserId: userId,
            reportedBy: currentUser.uid,
            reportedByDisplayName: currentUser.displayName || 'User',
            createdAt: serverTimestamp()
          };
          const created = await addDoc(collection(db, 'reports'), reportPayload);
          showToast(currentServerId === PUBLIC_SERVER_ID ? 'Report sent for bot review' : 'Report sent to admins', 'success');
          modal.closeModal();
          if (currentServerId === PUBLIC_SERVER_ID) {
            reviewPublicReportAndMaybeSuspend(created.id, reportPayload).catch(() => {});
          }
        } catch (err) {
          showToast(err?.message || 'Failed to submit report', 'error');
        }
      };
    }

    function toBehaviorSummary(reason = '', details = '') {
      const r = String(reason || '').trim();
      const d = String(details || '').trim();
      const combined = `${r} ${d}`.toLowerCase();
      if (/harass|insult|threat|bully|slur|hate|abuse|name/.test(combined)) return 'You called someone names or used abusive language.';
      if (/spam|flood|repeat|advert|promo|link/.test(combined)) return 'You repeatedly posted spam or disruptive messages.';
      if (/nsfw|sexual|explicit|image|photo/.test(combined)) return 'You shared inappropriate content.';
      if (/impersonat|fake|scam|fraud/.test(combined)) return 'You appeared to impersonate or mislead others.';
      if (/privacy|dox|personal|address|phone/.test(combined)) return 'You shared or requested private personal information.';
      if (/self-harm|suicide|violence|kill|attack/.test(combined)) return 'You posted harmful or dangerous content.';
      if (r) return `You were reported for ${r.toLowerCase()}.`;
      return 'You were reported for behavior that broke server rules.';
    }

    function getUserDisplayName(userData, memberData) {
      return (userData?.displayName || userData?.username || memberData?.displayName || memberData?.username || '').trim();
    }

    function textHasProfanity(text) {
      const raw = (text || '').toLowerCase();
      if (!raw) return false;
      return PROFANITY_WORDS.some(word => new RegExp(`\\b${word.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\b`, 'i').test(raw));
    }

    function extractMistralText(content) {
      if (!content) return '';
      if (typeof content === 'string') return content.trim();
      if (Array.isArray(content)) {
        return content.map(item => {
          if (typeof item === 'string') return item;
          if (item?.type === 'text') return item.text || '';
          return '';
        }).join(' ').trim();
      }
      return String(content).trim();
    }

    function renderFormattedText(rawText = '') {
      const escaped = escapeHtml(rawText);
      const inline = escaped
        .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
        .replace(/\*(.+?)\*/g, '<em>$1</em>');
      const lines = inline.split(/\r?\n/);
      let html = '';
      let inUl = false;
      let inOl = false;
      lines.forEach((line) => {
        const ulMatch = line.match(/^\s*[-*]\s+(.+)$/);
        const olMatch = line.match(/^\s*\d+\.\s+(.+)$/);
        if (ulMatch) {
          if (inOl) { html += '</ol>'; inOl = false; }
          if (!inUl) { html += '<ul class="list-disc pl-5 space-y-1 my-1">'; inUl = true; }
          html += `<li>${ulMatch[1]}</li>`;
          return;
        }
        if (olMatch) {
          if (inUl) { html += '</ul>'; inUl = false; }
          if (!inOl) { html += '<ol class="list-decimal pl-5 space-y-1 my-1">'; inOl = true; }
          html += `<li>${olMatch[1]}</li>`;
          return;
        }
        if (inUl) { html += '</ul>'; inUl = false; }
        if (inOl) { html += '</ol>'; inOl = false; }
        html += line ? `<div>${line}</div>` : '<div><br></div>';
      });
      if (inUl) html += '</ul>';
      if (inOl) html += '</ol>';
      return html;
    }

    function renderMessageText(rawText = '', isBot = false) {
      if (!rawText) return '';
      if (isBot) return renderFormattedText(rawText);
      return escapeHtml(rawText).replace(/\r?\n/g, '<br>');
    }

    async function getBotMemory(userId) {
      if (!userId) return [];
      try {
        const snap = await getDoc(doc(db, 'botMemory', userId));
        const history = snap.exists() ? snap.data()?.history : [];
        return Array.isArray(history) ? history.slice(-BOT_MEMORY_LIMIT) : [];
      } catch (_) {
        return [];
      }
    }

    async function saveBotMemory(userId, userText, botReply) {
      if (!userId || !userText || !botReply) return;
      const prev = await getBotMemory(userId);
      const next = [...prev, {
        user: String(userText).slice(0, 500),
        bot: String(botReply).slice(0, 500),
        at: Date.now()
      }].slice(-BOT_MEMORY_LIMIT);
      try {
        await setDoc(doc(db, 'botMemory', userId), {
          history: next,
          updatedAt: serverTimestamp()
        }, { merge: true });
      } catch (_) {}
    }

    function extractBotPrompt(rawText) {
      const raw = String(rawText || '').trim();
      if (!raw) return '';
      const slashMatch = raw.match(/^\/bot\s*(.*)$/i);
      if (slashMatch) return (slashMatch[1] || '').trim();
      const keywordMatch = raw.match(/\b(bot|mistral|assistant|ai)\b[:,-]?\s*(.*)$/i);
      if (keywordMatch) return (keywordMatch[2] || raw).trim();
      return '';
    }

    function isBotOnlyServer(serverId = currentServerId) {
      const srv = serverId ? servers[serverId] : null;
      return !!srv?.botOnly;
    }

    function markBotConversationActive(channelId) {
      if (!channelId) return;
      botConversationByChannel[channelId] = { at: Date.now() };
    }

    function clearBotConversation(channelId) {
      if (!channelId) return;
      delete botConversationByChannel[channelId];
    }

    function messageLooksLikeTalkingToSomeoneElse(text) {
      const t = String(text || '').trim();
      if (!t) return false;
      const lower = t.toLowerCase();
      const atMention = lower.match(/@([a-z0-9_.-]+)/i);
      if (atMention) {
        const mentioned = (atMention[1] || '').toLowerCase();
        if (!['bot', 'mistral', 'assistant', 'ai'].includes(mentioned)) return true;
      }
      const otherNames = Object.values(members)
        .filter(m => m.serverId === currentServerId && m.userId !== currentUser?.uid && m.userId !== BOT_USER_ID)
        .map(m => (getUserDisplayName(memberUserData[m.userId], m) || '').toLowerCase().trim())
        .filter(Boolean);
      return otherNames.some((name) => {
        if (name.length < 2) return false;
        return lower.startsWith(`${name}:`) || lower.startsWith(`${name},`) || lower.startsWith(`${name} `);
      });
    }

    function shouldAutoContinueBotConversation(text, channelId) {
      if (!channelId) return false;
      if (isBotOnlyServer()) return true;
      const state = botConversationByChannel[channelId];
      if (!state) return false;
      if (Date.now() - Number(state.at || 0) > BOT_CONVERSATION_IDLE_MS) {
        clearBotConversation(channelId);
        return false;
      }
      if (messageLooksLikeTalkingToSomeoneElse(text)) {
        clearBotConversation(channelId);
        return false;
      }
      return true;
    }

    function extractJsonObjectFromText(raw) {
      const txt = String(raw || '').replace(/```json|```/gi, '').trim();
      if (!txt) return '{}';
      const start = txt.indexOf('{');
      const end = txt.lastIndexOf('}');
      if (start >= 0 && end > start) return txt.slice(start, end + 1);
      return txt;
    }

    function getDeterministicPublicReviewDecision(reason, details, evidenceText = '') {
      const combined = `${String(reason || '')} ${String(details || '')} ${String(evidenceText || '')}`.trim();
      const severeKeywords = ['threat', 'kill', 'hate', 'racist', 'nazi', 'harass', 'spam', 'scam', 'dox', 'slur'];
      const low = combined.toLowerCase();
      const severeHit = severeKeywords.some(k => low.includes(k)) || textHasProfanity(combined);
      if (severeHit) {
        return { action: 'suspend', minutes: 120, reason: 'Deterministic policy check triggered' };
      }
      return { action: 'none', minutes: 0, reason: 'No deterministic policy hit' };
    }

    function normalizeModerationText(text = '') {
      return String(text || '')
        .toLowerCase()
        .replace(/[^a-z0-9\s]/g, ' ')
        .replace(/\s+/g, ' ')
        .trim();
    }

    function normalizeAccountName(name = '') {
      return String(name || '')
        .toLowerCase()
        .replace(/[^a-z0-9_.-]/g, '')
        .trim();
    }

    function accountBanDocId(type, value) {
      return `${type}:${String(value || '').toLowerCase().trim()}`;
    }

    async function addGlobalAccountBanToken(type, value, reason = 'Banned') {
      const normalized = String(value || '').toLowerCase().trim();
      if (!normalized) return;
      await setDoc(doc(db, 'bannedAccounts', accountBanDocId(type, normalized)), {
        type,
        value: normalized,
        reason: String(reason || 'Banned').slice(0, 180),
        createdAt: serverTimestamp(),
        createdBy: currentUser?.uid || 'system'
      }, { merge: true });
    }

    async function isGloballyBannedIdentity({ email = '', username = '' } = {}) {
      const checks = [];
      const e = String(email || '').toLowerCase().trim();
      const u = normalizeAccountName(username);
      if (e) checks.push(getDoc(doc(db, 'bannedAccounts', accountBanDocId('email', e))));
      if (u) checks.push(getDoc(doc(db, 'bannedAccounts', accountBanDocId('username', u))));
      if (!checks.length) return false;
      const results = await Promise.all(checks.map(p => p.catch(() => ({ exists: () => false }))));
      return results.some(r => r?.exists?.());
    }

    async function addServerBannedAccountName(serverId, name, reason = 'Banned account name') {
      if (!serverId) return;
      const normalized = normalizeAccountName(name);
      if (!normalized) return;
      await setDoc(doc(db, 'servers', serverId, 'bannedAccounts', normalized), {
        normalized,
        displayName: String(name || '').trim().slice(0, 60),
        reason: String(reason || 'Banned account name').slice(0, 180),
        addedBy: currentUser?.uid || 'system',
        source: 'manual',
        createdAt: serverTimestamp()
      }, { merge: true });
    }

    async function isBannedNameForServer(serverId, name) {
      if (!serverId || !name) return false;
      const normalized = normalizeAccountName(name);
      if (!normalized) return false;
      try {
        const snap = await getDoc(doc(db, 'servers', serverId, 'bannedAccounts', normalized));
        return snap.exists();
      } catch (_) {
        return false;
      }
    }

    function stopServerBannedAccountsWatcher() {
      if (!unsubServerBannedAccounts) return;
      unsubServerBannedAccounts();
      unsubServerBannedAccounts = null;
      serverBannedAccounts = {};
    }

    function renderAdminBannedAccountList() {
      const host = document.getElementById('admin-ban-name-list');
      if (!host) return;
      const rows = Object.values(serverBannedAccounts)
        .sort((a, b) => {
          const at = a.createdAt?.toDate ? a.createdAt.toDate().getTime() : 0;
          const bt = b.createdAt?.toDate ? b.createdAt.toDate().getTime() : 0;
          return bt - at;
        })
        .map((entry) => {
          const label = entry.displayName || entry.normalized || entry.id || 'unknown';
          const reason = (entry.reason || 'Blocked account').trim();
          return `
            <div class="flex items-center justify-between gap-2 rounded bg-discord-darkest/40 px-2 py-1.5">
              <div class="min-w-0">
                <div class="text-xs text-gray-200 truncate">${escapeHtml(label)}</div>
                <div class="text-[11px] text-gray-500 truncate">${escapeHtml(reason)}</div>
              </div>
              <button type="button" class="text-[11px] px-2 py-1 rounded bg-discord-dark hover:bg-discord-darker" data-unblock-name="${escapeHtml(entry.id || '')}">Unblock</button>
            </div>
          `;
        }).join('');
      host.innerHTML = rows || '<p class="text-xs text-gray-500 py-1">No blocked names</p>';
      host.querySelectorAll('[data-unblock-name]').forEach((btn) => {
        btn.onclick = async () => {
          const id = normalizeAccountName(btn.dataset.unblockName || '');
          if (!id || !currentServerId || !isAdmin()) return;
          try {
            await deleteDoc(doc(db, 'servers', currentServerId, 'bannedAccounts', id));
            showToast('Name unblocked', 'success');
          } catch (err) {
            showToast(err?.message || 'Failed to unblock name', 'error');
          }
        };
      });
    }

    function subscribeServerBannedAccounts(serverId) {
      stopServerBannedAccountsWatcher();
      if (!serverId || !currentUser?.uid) return;
      unsubServerBannedAccounts = onSnapshot(collection(db, 'servers', serverId, 'bannedAccounts'), (snap) => {
        const next = {};
        snap.docs.forEach(d => { next[d.id] = { id: d.id, ...d.data() }; });
        serverBannedAccounts = next;
        renderAdminBannedAccountList();
        if (normalizeAccountName(currentUser.displayName) && next[normalizeAccountName(currentUser.displayName)]) {
          if (serverId === currentServerId) {
            showToast('Your account name is blocked from this server', 'error');
            if (serverId === PUBLIC_SERVER_ID) {
              getActiveSuspension(PUBLIC_SERVER_ID, currentUser.uid).then((s) => redirectSuspendedUserFromPublic(s || { untilMs: Date.now() + 15 * 60 * 1000, reason: 'Blocked account name' })).catch(() => {});
            } else if (servers[PUBLIC_SERVER_ID]) {
              selectServer(PUBLIC_SERVER_ID);
            }
          }
        }
      }, () => {});
    }

    async function analyzeImageModeration(imageUrl) {
      if (!imageUrl || !MISTRAL_API_KEY) return { flagged: false, reason: '' };
      try {
        const prompt = 'Check this image for explicit sexual nudity, child sexual content, or graphic sexual abuse. Return only JSON: {"flagged":true|false,"reason":"short reason"}.';
        const res = await fetch('https://api.mistral.ai/v1/chat/completions', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${MISTRAL_API_KEY}`
          },
          body: JSON.stringify({
            model: BOT_MODEL,
            temperature: 0,
            max_tokens: 120,
            messages: [
              { role: 'system', content: 'Return strict JSON only.' },
              {
                role: 'user',
                content: [
                  { type: 'text', text: prompt },
                  { type: 'image_url', image_url: imageUrl }
                ]
              }
            ]
          })
        });
        if (!res.ok) return { flagged: false, reason: '' };
        const data = await res.json();
        const raw = extractJsonObjectFromText(extractMistralText(data?.choices?.[0]?.message?.content) || '{}');
        let parsed = {};
        try { parsed = JSON.parse(raw); } catch (_) { parsed = {}; }
        return { flagged: !!parsed.flagged, reason: String(parsed.reason || 'Inappropriate image').slice(0, 180) };
      } catch (_) {
        return { flagged: false, reason: '' };
      }
    }

    function hasEvidenceMatch(details = '', evidenceMessages = []) {
      const detailNorm = normalizeModerationText(details);
      if (!detailNorm || detailNorm.length < 8) return false;
      const evidenceNorm = evidenceMessages.map(m => normalizeModerationText(m)).filter(Boolean);
      if (evidenceNorm.some(msg => msg.includes(detailNorm))) return true;
      const detailTokens = detailNorm.split(' ').filter(t => t.length > 2);
      if (detailTokens.length < 4) return false;
      return evidenceNorm.some((msg) => {
        const overlap = detailTokens.filter(t => msg.includes(t)).length;
        return overlap >= Math.min(6, Math.ceil(detailTokens.length * 0.7));
      });
    }

    async function getRecentPublicEvidenceForUser(userId, maxItems = 20) {
      if (!userId) return [];
      try {
        const snap = await getDocs(query(
          collection(db, 'messages'),
          where('serverId', '==', PUBLIC_SERVER_ID),
          where('userId', '==', userId),
          limit(50)
        ));
        const rows = snap.docs.map((d) => {
          const data = d.data() || {};
          const at = data.createdAt?.toDate ? data.createdAt.toDate().getTime() : 0;
          return { at, text: String(data.text || '').trim() };
        }).filter(x => x.text);
        rows.sort((a, b) => b.at - a.at);
        return rows.slice(0, maxItems).map(x => x.text);
      } catch (_) {
        return [];
      }
    }

    function getAttachmentStoragePath(att) {
      if (!att) return '';
      if (att.storagePath) return att.storagePath;
      const url = (att.url || '').trim();
      if (!url.includes('firebasestorage.googleapis.com')) return '';
      const m = url.match(/\/o\/([^?]+)/);
      if (!m?.[1]) return '';
      try { return decodeURIComponent(m[1]); } catch (_) { return ''; }
    }

    async function deleteAttachmentFromStorage(att) {
      const storagePath = getAttachmentStoragePath(att);
      if (!storagePath) return false;
      try {
        await deleteObject(ref(storage, storagePath));
        return true;
      } catch (_) {
        return false;
      }
    }

    async function deleteMessageWithAttachments(messageId, messageData) {
      const data = messageData || messages[messageId];
      if (!messageId || !data) return { filesDeleted: 0, messageDeleted: false };
      let filesDeleted = 0;
      for (const att of (data.attachments || [])) {
        const deleted = await deleteAttachmentFromStorage(att);
        if (deleted) filesDeleted++;
      }
      await deleteDoc(doc(db, 'messages', messageId));
      return { filesDeleted, messageDeleted: true };
    }

    function getDurationMs(value, unit) {
      const n = Number(value);
      if (!Number.isFinite(n) || n <= 0) return 0;
      if (unit === 'minutes') return n * 60 * 1000;
      if (unit === 'days') return n * 24 * 60 * 60 * 1000;
      return n * 60 * 60 * 1000;
    }

    function formatDurationRemaining(ms) {
      const remaining = Math.max(0, Number(ms) || 0);
      const totalMinutes = Math.ceil(remaining / 60000);
      if (totalMinutes < 60) return `${totalMinutes} minute${totalMinutes === 1 ? '' : 's'}`;
      const totalHours = Math.ceil(totalMinutes / 60);
      if (totalHours < 24) return `${totalHours} hour${totalHours === 1 ? '' : 's'}`;
      const totalDays = Math.ceil(totalHours / 24);
      return `${totalDays} day${totalDays === 1 ? '' : 's'}`;
    }

    async function getActiveSuspension(serverId, userId = currentUser?.uid) {
      if (!serverId || !userId) return null;
      try {
        const suspensionRef = doc(db, 'servers', serverId, 'suspended', userId);
        const snap = await getDoc(suspensionRef);
        if (!snap.exists()) return null;
        const data = snap.data() || {};
        const untilMs = Number(data.untilMs || 0);
        if (!untilMs || untilMs <= Date.now()) {
          deleteDoc(suspensionRef).catch(() => {});
          return null;
        }
        return { ...data, untilMs };
      } catch (_) {
        return null;
      }
    }

    async function ensureSafeChatServerForSuspendedUser() {
      if (!currentUser?.uid) return null;
      const existingLocal = Object.values(servers).find(
        (s) => s.botOnly && s.personalSafe && (s.safeUserId === currentUser.uid || s.ownerId === currentUser.uid)
      );
      if (existingLocal?.id) {
        try {
          await updateDoc(doc(db, 'servers', existingLocal.id), {
            ownerId: BOT_USER_ID,
            safeUserId: currentUser.uid,
            botOnly: true,
            personalSafe: true
          });
          await setDoc(doc(db, 'servers', existingLocal.id, 'members', BOT_USER_ID), { role: 'owner' }, { merge: true });
          await setDoc(doc(db, 'servers', existingLocal.id, 'members', currentUser.uid), { role: 'member' }, { merge: true });
          const existingMyMembership = await getDocs(query(
            collection(db, 'memberships'),
            where('serverId', '==', existingLocal.id),
            where('userId', '==', currentUser.uid),
            limit(5)
          ));
          for (const m of existingMyMembership.docs) {
            await updateDoc(m.ref, { role: 'member' });
          }
          const existingBotMembership = await getDocs(query(
            collection(db, 'memberships'),
            where('serverId', '==', existingLocal.id),
            where('userId', '==', BOT_USER_ID),
            limit(5)
          ));
          if (existingBotMembership.empty) {
            await setDoc(doc(collection(db, 'memberships')), { serverId: existingLocal.id, userId: BOT_USER_ID, role: 'owner' });
          } else {
            for (const m of existingBotMembership.docs) {
              await updateDoc(m.ref, { role: 'owner' });
            }
          }
        } catch (_) {}
        return existingLocal.id;
      }
      const serverRef = doc(collection(db, 'servers'));
      const channelRef = doc(collection(db, 'channels'));
      await setDoc(serverRef, {
        name: 'Safe Chat',
        ownerId: BOT_USER_ID,
        safeUserId: currentUser.uid,
        icon: '',
        botOnly: true,
        personalSafe: true,
        createdAt: serverTimestamp()
      });
      await setDoc(doc(db, 'servers', serverRef.id, 'members', currentUser.uid), { role: 'member' });
      await setDoc(doc(collection(db, 'memberships')), { serverId: serverRef.id, userId: currentUser.uid, role: 'member' });
      await setDoc(channelRef, { serverId: serverRef.id, name: 'safe-chat', type: 'text', createdAt: serverTimestamp() });
      ensureGlobalBotProfile().catch(() => {});
      await setDoc(doc(db, 'servers', serverRef.id, 'members', BOT_USER_ID), { role: 'owner' }, { merge: true });
      await setDoc(doc(collection(db, 'memberships')), { serverId: serverRef.id, userId: BOT_USER_ID, role: 'owner' });
      await sendBotMessage(serverRef.id, channelRef.id, 'You are currently suspended from Public. Use this private chat in the meantime.');
      await loadServers();
      return serverRef.id;
    }

    async function getSafeChatChannelId(serverId) {
      if (!serverId) return '';
      try {
        const snap = await getDocs(query(collection(db, 'channels'), where('serverId', '==', serverId), limit(10)));
        const match = snap.docs.find(d => (d.data()?.name || '') === 'safe-chat') || snap.docs[0];
        return match?.id || '';
      } catch (_) {
        return '';
      }
    }

    async function sendSafeChatSuspensionBriefing(safeServerId, suspension) {
      if (!safeServerId || !currentUser?.uid) return;
      const untilMs = Number(suspension?.untilMs || 0);
      const briefKey = `${currentUser.uid}:${untilMs}`;
      if (briefKey && briefKey === lastSafeBriefingKey) return;
      lastSafeBriefingKey = briefKey;
      const channelId = await getSafeChatChannelId(safeServerId);
      if (!channelId) return;
      let recentReports = [];
      try {
        const repSnap = await getDocs(query(
          collection(db, 'reports'),
          where('serverId', '==', PUBLIC_SERVER_ID),
          where('reportedUserId', '==', currentUser.uid),
          limit(20)
        ));
        recentReports = repSnap.docs
          .map(d => ({ id: d.id, ...(d.data() || {}) }))
          .sort((a, b) => {
            const at = a.createdAt?.toDate ? a.createdAt.toDate().getTime() : 0;
            const bt = b.createdAt?.toDate ? b.createdAt.toDate().getTime() : 0;
            return bt - at;
          })
          .slice(0, 3);
      } catch (_) {}
      const reason = String(suspension?.reason || 'Policy violation').replace(/^\[BOT-AUTO\]\s*/i, '').trim();
      const ends = untilMs ? new Date(untilMs).toLocaleString() : 'Unknown';
      const reportLines = recentReports.length
        ? recentReports.map((r, i) => `- Report ${i + 1}: ${toBehaviorSummary(r.reason, r.details)}`).join('\n')
        : '- No specific report text was found.';
      const msg = [
        `You were suspended from Public.`,
        `Reason: ${reason || 'Policy violation'}`,
        `Suspension ends: ${ends}`,
        '',
        'Recent report context:',
        reportLines,
        '',
        'Tips to avoid future reports:',
        '- Avoid insults, slurs, threats, and harassment.',
        '- Don\'t spam repeated messages or links.',
        '- Keep disagreements civil and factual.',
        '- If a conversation escalates, pause and cool down.',
        '- Ask for clarification instead of assuming bad intent.'
      ].join('\n');
      await sendBotMessage(safeServerId, channelId, msg);
    }

    async function redirectSuspendedUserFromPublic(suspension) {
      if (isHandlingPublicSuspensionRedirect) return;
      isHandlingPublicSuspensionRedirect = true;
      try {
        showSuspensionLockModal(servers[PUBLIC_SERVER_ID]?.name || 'Public', suspension);
        const safeServerId = await ensureSafeChatServerForSuspendedUser();
        if (safeServerId) {
          await sendSafeChatSuspensionBriefing(safeServerId, suspension);
          currentServerId = null;
          currentChannelId = null;
          renderChannelList();
          renderMessages();
          updateServerActionButtons();
          setTimeout(() => selectServer(safeServerId), 0);
        }
      } catch (_) {
      } finally {
        isHandlingPublicSuspensionRedirect = false;
      }
    }

    function stopActiveSuspensionWatcher() {
      if (unsubActiveSuspension) {
        unsubActiveSuspension();
        unsubActiveSuspension = null;
      }
    }

    async function removeUserFromSafeChatServers() {
      if (!currentUser?.uid) return;
      try {
        const membershipSnap = await getDocs(query(
          collection(db, 'memberships'),
          where('userId', '==', currentUser.uid),
          limit(200)
        ));
        for (const mem of membershipSnap.docs) {
          const data = mem.data() || {};
          const sid = data.serverId;
          if (!sid || sid === PUBLIC_SERVER_ID) continue;
          let srv = servers[sid];
          if (!srv) {
            const snap = await getDoc(doc(db, 'servers', sid));
            srv = snap.exists() ? { id: sid, ...snap.data() } : null;
          }
          if (!srv?.personalSafe || srv?.safeUserId !== currentUser.uid) continue;
          try { await deleteDoc(doc(db, 'servers', sid, 'members', currentUser.uid)); } catch (_) {}
          try { await deleteDoc(mem.ref); } catch (_) {}
          if (currentServerId === sid) {
            currentServerId = null;
            currentChannelId = null;
            renderChannelList();
            renderMessages();
          }
        }
      } catch (_) {}
    }

    function stopPublicSuspensionLifecycleWatcher() {
      if (unsubPublicSuspensionLifecycle) {
        unsubPublicSuspensionLifecycle();
        unsubPublicSuspensionLifecycle = null;
      }
    }

    function startPublicSuspensionLifecycleWatcher() {
      stopPublicSuspensionLifecycleWatcher();
      if (!currentUser?.uid) return;
      const suspensionRef = doc(db, 'servers', PUBLIC_SERVER_ID, 'suspended', currentUser.uid);
      unsubPublicSuspensionLifecycle = onSnapshot(suspensionRef, async (snap) => {
        if (!currentUser?.uid) return;
        if (!snap.exists()) {
          await removeUserFromSafeChatServers();
          await loadServers();
          return;
        }
        const data = snap.data() || {};
        const untilMs = Number(data.untilMs || 0);
        if (!untilMs || untilMs <= Date.now()) {
          deleteDoc(suspensionRef).catch(() => {});
          await removeUserFromSafeChatServers();
          await loadServers();
        }
      }, () => {});
    }

    function startActiveSuspensionWatcher(serverId) {
      stopActiveSuspensionWatcher();
      if (!serverId || !currentUser?.uid) return;
      const watchServerId = serverId;
      const suspensionRef = doc(db, 'servers', watchServerId, 'suspended', currentUser.uid);
      unsubActiveSuspension = onSnapshot(suspensionRef, async (snap) => {
        if (watchServerId !== currentServerId) return;
        if (!snap.exists()) {
          lastSuspensionNoticeKey = '';
          return;
        }
        const data = snap.data() || {};
        const untilMs = Number(data.untilMs || 0);
        if (!untilMs || untilMs <= Date.now()) {
          deleteDoc(suspensionRef).catch(() => {});
          lastSuspensionNoticeKey = '';
          return;
        }
        const noticeKey = `${watchServerId}:${untilMs}`;
        if (lastSuspensionNoticeKey !== noticeKey) {
          lastSuspensionNoticeKey = noticeKey;
          showSuspensionLockModal(servers[watchServerId]?.name || 'this server', { ...data, untilMs });
        }
        if (watchServerId === PUBLIC_SERVER_ID) {
          await redirectSuspendedUserFromPublic({ ...data, untilMs });
        } else if (servers[PUBLIC_SERVER_ID]) {
          await selectServer(PUBLIC_SERVER_ID);
        } else {
          currentChannelId = null;
          renderChannelList();
          renderMessages();
        }
      }, () => {});
    }

    function showSuspensionLockModal(serverName, suspension) {
      const remaining = formatDurationRemaining((suspension?.untilMs || 0) - Date.now());
      const untilLabel = new Date(Number(suspension?.untilMs || Date.now())).toLocaleString();
      const reason = (suspension?.reason || '').trim();
      modal.open('Server Locked', `
        <div class="space-y-3">
          <p class="text-sm text-gray-300">You are suspended from <span class="text-white font-medium">${escapeHtml(serverName || 'this server')}</span>.</p>
          <div class="rounded border border-discord-dark bg-discord-darkest/40 p-3 text-sm text-gray-300">
            <div>Remaining: <span class="text-white font-medium">${escapeHtml(remaining)}</span></div>
            <div class="text-xs text-gray-500 mt-1">Ends: ${escapeHtml(untilLabel)}</div>
            ${reason ? `<div class="text-xs text-gray-400 mt-1">Reason: ${escapeHtml(reason)}</div>` : ''}
          </div>
          <button type="button" id="suspension-lock-ok" class="w-full py-2 rounded bg-discord-blurple hover:bg-indigo-600 font-medium">OK</button>
        </div>
      `);
      const okBtn = document.getElementById('suspension-lock-ok');
      if (okBtn) okBtn.onclick = () => modal.closeModal();
    }

    async function deleteMessagesByFilter({ channelId = null, olderThanMs = null } = {}) {
      if (!currentServerId || !currentUser?.uid) return { deleted: 0, filesDeleted: 0 };
      const srv = servers[currentServerId];
      if (srv?.ownerId !== currentUser.uid) {
        showToast('Only server owner can run bulk message cleanup', 'error');
        return { deleted: 0, filesDeleted: 0 };
      }
      const qBase = channelId
        ? query(collection(db, 'messages'), where('channelId', '==', channelId))
        : query(collection(db, 'messages'), where('serverId', '==', currentServerId));
      const snap = await getDocs(qBase);
      const cutoff = olderThanMs ? Date.now() - olderThanMs : 0;
      const targetDocs = snap.docs.filter((d) => {
        const data = d.data();
        if (!olderThanMs) return true;
        const at = data.createdAt?.toDate ? data.createdAt.toDate().getTime() : 0;
        return at > 0 && at <= cutoff;
      });
      let deleted = 0;
      let filesDeleted = 0;
      for (const d of targetDocs) {
        try {
          const result = await deleteMessageWithAttachments(d.id, d.data());
          if (result.messageDeleted) deleted++;
          filesDeleted += result.filesDeleted;
        } catch (_) {}
      }
      return { deleted, filesDeleted };
    }

    async function cleanupExpiredAttachments({ serverScoped = false } = {}) {
      if (!currentUser?.uid) return { filesDeleted: 0, messagesUpdated: 0 };
      if (serverScoped && !currentServerId) return { filesDeleted: 0, messagesUpdated: 0 };
      const now = Date.now();
      let qRef;
      if (serverScoped) {
        qRef = query(
          collection(db, 'messages'),
          where('serverId', '==', currentServerId),
          limit(300)
        );
      } else {
        qRef = query(
          collection(db, 'messages'),
          where('userId', '==', currentUser.uid),
          limit(200)
        );
      }
      const snap = await getDocs(qRef);
      let filesDeleted = 0;
      let messagesUpdated = 0;
      for (const d of snap.docs) {
        const data = d.data();
        const messageExpiry = Number(data.attachmentExpiresAt || 0);
        if (!messageExpiry || messageExpiry > now) continue;
        const currentAttachments = data.attachments || [];
        const keep = [];
        let touched = false;
        let nextExpiry = null;
        for (const att of currentAttachments) {
          const expiresAt = Number(att?.expiresAt || 0);
          const storagePath = getAttachmentStoragePath(att);
          const isExpiredManagedAttachment = !!storagePath && expiresAt > 0 && expiresAt <= now;
          if (isExpiredManagedAttachment) {
            const deleted = await deleteAttachmentFromStorage(att);
            if (deleted) filesDeleted++;
            touched = true;
            continue;
          }
          keep.push(att);
          if (storagePath && expiresAt > 0) {
            nextExpiry = nextExpiry ? Math.min(nextExpiry, expiresAt) : expiresAt;
          }
        }
        if (!touched) continue;
        try {
          await updateDoc(doc(db, 'messages', d.id), {
            attachments: keep,
            attachmentExpiresAt: nextExpiry || null,
            editedAt: serverTimestamp()
          });
          messagesUpdated++;
        } catch (_) {}
      }
      return { filesDeleted, messagesUpdated };
    }

    function startAttachmentCleanupScheduler() {
      if (attachmentCleanupInterval) clearInterval(attachmentCleanupInterval);
      cleanupExpiredAttachments().catch(() => {});
      attachmentCleanupInterval = setInterval(() => {
        cleanupExpiredAttachments().catch(() => {});
      }, ATTACHMENT_CLEANUP_INTERVAL_MS);
    }

    function stopAttachmentCleanupScheduler() {
      if (!attachmentCleanupInterval) return;
      clearInterval(attachmentCleanupInterval);
      attachmentCleanupInterval = null;
    }

    async function ensureGlobalBotProfile() {
      await setDoc(doc(db, 'users', BOT_USER_ID), {
        displayName: BOT_DISPLAY_NAME,
        bio: 'Assistant bot for this server. Mention bot/ai/mistral or use commands like /help, /ping, /roll, /choose, /serverinfo, /members, /whoami, /joke, /quote.',
        photoURL: '',
        isBot: true,
        status: 'online',
        updatedAt: serverTimestamp()
      }, { merge: true });
    }

    async function ensureBotMembership(serverId) {
      if (!serverId) return;
      const existing = await getDocs(query(
        collection(db, 'memberships'),
        where('serverId', '==', serverId),
        where('userId', '==', BOT_USER_ID)
      ));
      if (!existing.empty) return;
      await setDoc(doc(db, 'servers', serverId, 'members', BOT_USER_ID), { role: 'bot' }, { merge: true });
      await setDoc(doc(collection(db, 'memberships')), { serverId, userId: BOT_USER_ID, role: 'bot' });
    }

    async function sendBotMessage(serverId, channelId, text) {
      if (!serverId || !channelId || !text) return;
      await addDoc(collection(db, 'messages'), {
        serverId,
        channelId,
        userId: BOT_USER_ID,
        displayName: BOT_DISPLAY_NAME,
        photoURL: '',
        text: String(text).slice(0, 2000),
        attachments: [],
        replyTo: null,
        isBot: true,
        createdAt: serverTimestamp()
      });
    }

    function getCurrentServerMemberCount(serverId) {
      return Object.values(members).filter(m => m.serverId === serverId).length;
    }

    function formatUptime() {
      const ms = Date.now() - APP_STARTED_AT;
      const mins = Math.floor(ms / 60000);
      const hours = Math.floor(mins / 60);
      const days = Math.floor(hours / 24);
      const remHours = hours % 24;
      const remMins = mins % 60;
      if (days > 0) return `${days}d ${remHours}h ${remMins}m`;
      if (hours > 0) return `${hours}h ${remMins}m`;
      return `${Math.max(1, remMins)}m`;
    }

    function pickRandom(arr) {
      if (!Array.isArray(arr) || arr.length === 0) return '';
      return arr[Math.floor(Math.random() * arr.length)];
    }

    function parseDiceRoll(raw) {
      const m = String(raw || '').trim().match(/^(\d{1,2})d(\d{1,3})$/i);
      if (!m) return null;
      const count = Number(m[1]);
      const sides = Number(m[2]);
      if (!count || !sides || count < 1 || count > 20 || sides < 2 || sides > 1000) return null;
      return { count, sides };
    }

    function runBuiltInBotCommand(prompt) {
      const p = String(prompt || '').trim();
      if (!p) return null;
      const clean = p.startsWith('/') ? p.slice(1) : p;
      const [cmdRaw, ...restArr] = clean.split(/\s+/);
      const cmd = (cmdRaw || '').toLowerCase();
      const rest = restArr.join(' ').trim();
      if (!cmd) return null;

      if (cmd === 'help') return `Supported commands:\n- ${BOT_COMMAND_HELP.join('\n- ')}`;
      if (cmd === 'ping') return 'Pong.';
      if (cmd === 'time') return `Local time: ${new Date().toLocaleString()}`;
      if (cmd === 'uptime') return `Uptime: ${formatUptime()}`;
      if (cmd === 'coinflip') return `Coinflip: ${Math.random() < 0.5 ? 'Heads' : 'Tails'}`;
      if (cmd === 'joke') return pickRandom(BOT_JOKES);
      if (cmd === 'quote') return pickRandom(BOT_QUIPS);
      if (cmd === '8ball') return `8ball: ${pickRandom(BOT_EIGHT_BALL)}`;
      if (cmd === 'members') return `Members in this server: ${getCurrentServerMemberCount(currentServerId)}`;
      if (cmd === 'whoami') return `You are ${currentUser?.displayName || 'User'} (${currentUser?.uid || 'unknown'}).`;
      if (cmd === 'serverinfo') {
        const srv = servers[currentServerId] || {};
        const channelCount = Object.values(channels).filter(c => c.serverId === currentServerId).length;
        const memberCount = getCurrentServerMemberCount(currentServerId);
        return `Server: ${srv.name || 'Unknown'}\nMembers: ${memberCount}\nChannels: ${channelCount}`;
      }
      if (cmd === 'choose') {
        const options = rest.split('|').map(x => x.trim()).filter(Boolean);
        if (options.length < 2) return 'Usage: /choose option1 | option2 | option3';
        return `I choose: ${pickRandom(options)}`;
      }
      if (cmd === 'roll') {
        const parsed = parseDiceRoll(rest);
        if (!parsed) return 'Usage: /roll XdY (example: /roll 2d6)';
        const values = [];
        for (let i = 0; i < parsed.count; i++) values.push(1 + Math.floor(Math.random() * parsed.sides));
        const total = values.reduce((a, b) => a + b, 0);
        return `Rolled ${parsed.count}d${parsed.sides}: ${values.join(', ')} (total ${total})`;
      }
      return null;
    }

    async function reviewPublicReportAndMaybeSuspend(reportId, reportData) {
      if (!reportId || !reportData || currentServerId !== PUBLIC_SERVER_ID) return;
      const reportedUserId = reportData.reportedUserId;
      if (!reportedUserId || reportedUserId === BOT_USER_ID) return;
      const suspensionRef = doc(db, 'servers', PUBLIC_SERVER_ID, 'suspended', reportedUserId);
      const reason = String(reportData.reason || 'Other');
      const details = String(reportData.details || '');
      const targetChannelId = currentChannelId || (Object.values(channels).find(c => c.serverId === PUBLIC_SERVER_ID)?.id || '');
      const evidenceMessages = await getRecentPublicEvidenceForUser(reportedUserId, 20);
      const evidenceText = evidenceMessages.join('\n');
      const deterministic = getDeterministicPublicReviewDecision(reason, details, evidenceText);
      const evidenceVerified = hasEvidenceMatch(details, evidenceMessages);
      let action = deterministic.action;
      let minutes = deterministic.minutes;
      let reviewReason = deterministic.reason;
      if (evidenceVerified && action !== 'suspend') {
        action = 'suspend';
        minutes = 90;
        reviewReason = 'Reported statement verified in recent chat logs';
      }
      let attemptedSuspendWrite = false;
      let suspendWriteFailed = false;
      try {
        ensureGlobalBotProfile().catch(() => {});
        ensureBotMembership(PUBLIC_SERVER_ID).catch(() => {});
        const prompt = [
          'You are a strict moderation reviewer for a public chat.',
          'Return ONLY one JSON object with keys: action, minutes, reason.',
          'action must be exactly "none" or "suspend".',
          'minutes must be an integer between 0 and 1440.',
          'If action is "none", set minutes to 0.',
          'Example: {"action":"suspend","minutes":120,"reason":"Harassment"}',
          `Report reason: ${reason}`,
          `Report details: ${details || '(none)'}`,
          `Recent chat evidence from reported user (${evidenceMessages.length} messages):\n${evidenceText || '(no recent messages found)'}`,
          'Do not suspend based only on accusations. Prefer evidence from recent chat logs.',
          'Suspend only when content indicates clear harassment, hate, threats, or spam abuse.'
        ].join('\n');
        const res = await fetch('https://api.mistral.ai/v1/chat/completions', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${MISTRAL_API_KEY}`
          },
          body: JSON.stringify({
            model: BOT_MODEL,
            temperature: 0.1,
            max_tokens: 180,
            messages: [
              { role: 'system', content: 'Output only valid minified JSON.' },
              { role: 'user', content: prompt }
            ]
          })
        });
        if (!res.ok) throw new Error('Review unavailable');
        const data = await res.json();
        const raw = extractMistralText(data?.choices?.[0]?.message?.content) || '{}';
        const jsonRaw = extractJsonObjectFromText(raw);
        let parsed = {};
        try { parsed = JSON.parse(jsonRaw); } catch (_) { parsed = {}; }
        const aiAction = String(parsed.action || 'none').toLowerCase();
        const aiMinutes = Math.max(0, Math.min(1440, Math.floor(Number(parsed.minutes || 0))));
        const aiReason = String(parsed.reason || '').slice(0, 180);
        if (['none', 'suspend'].includes(aiAction)) {
          if (aiAction === 'suspend') {
            const nextMinutes = aiMinutes > 0 ? aiMinutes : 120;
            if (nextMinutes >= minutes) {
              action = 'suspend';
              minutes = nextMinutes;
              reviewReason = aiReason || reviewReason;
            }
          } else if (action !== 'suspend') {
            action = 'none';
            minutes = 0;
            reviewReason = aiReason || reviewReason;
          }
        }
      } catch (err) {
        if (DEBUG_MODE) console.error('Public report review failed', err);
      }
      if (action === 'suspend' && minutes > 0) {
        try {
          attemptedSuspendWrite = true;
          const appliedMinutes = Math.max(1, minutes);
          const untilMs = Date.now() + (appliedMinutes * 60 * 1000);
          await setDoc(suspensionRef, {
            userId: reportedUserId,
            reason: `[BOT-AUTO] ${String(reviewReason || 'Policy violation').slice(0, 180)}`,
            reviewSource: 'public-report-bot',
            suspendedBy: currentUser.uid,
            suspendedAt: serverTimestamp(),
            untilMs
          }, { merge: true });
          await sendBotMessage(PUBLIC_SERVER_ID, targetChannelId, `Report reviewed: user suspended for ${appliedMinutes} minute(s). Reason: ${String(reviewReason || 'Policy violation').slice(0, 180)}`);
          return;
        } catch (err) {
          suspendWriteFailed = true;
          if (DEBUG_MODE) console.error('Public suspension write failed', err);
        }
      }
      if (attemptedSuspendWrite && suspendWriteFailed) {
        await sendBotMessage(PUBLIC_SERVER_ID, targetChannelId, 'Report reviewed: suspension decision made, but applying suspension failed (rules/config).');
        return;
      }
      try {
        const postCheck = await getDoc(suspensionRef);
        const untilMs = postCheck.exists() ? Number(postCheck.data()?.untilMs || 0) : 0;
        if (untilMs > Date.now()) {
          await sendBotMessage(PUBLIC_SERVER_ID, targetChannelId, 'Report reviewed: user is already suspended.');
          return;
        }
      } catch (_) {}
      await sendBotMessage(PUBLIC_SERVER_ID, targetChannelId, 'Report reviewed: no suspension applied.');
    }

    async function askMistral(prompt, userId = currentUser?.uid) {
      const memory = await getBotMemory(userId);
      const memoryText = memory.length
        ? memory.map((item, idx) => `${idx + 1}. User: ${item.user}\nBot: ${item.bot}`).join('\n')
        : 'No prior memory.';
      const res = await fetch('https://api.mistral.ai/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${MISTRAL_API_KEY}`
        },
        body: JSON.stringify({
          model: BOT_MODEL,
          temperature: 0.6,
          max_tokens: 450,
          messages: [
            { role: 'system', content: `You are a concise chat assistant. Do not mention Discord, slash-command ecosystems, or platform-specific features. Use clean formatting. If listing items, use clear bullets or numbering. Only mention these supported commands if asked: ${BOT_COMMAND_HELP.join(' | ')}. Never suggest commands outside this list.` },
            { role: 'system', content: `User memory:\n${memoryText}` },
            { role: 'user', content: prompt }
          ]
        })
      });
      if (!res.ok) {
        const errText = await res.text();
        throw new Error(errText || `Mistral API error (${res.status})`);
      }
      const data = await res.json();
      return extractMistralText(data?.choices?.[0]?.message?.content) || 'I could not generate a response.';
    }

    async function handleBotCommand(rawText, opts = {}) {
      const prompt = opts.alreadyPrompt ? String(rawText || '').trim() : extractBotPrompt(rawText);
      if (!prompt) {
        if (!opts.silentOnEmpty) showToast('Try mentioning bot, AI, or Mistral in your message.', 'info');
        return false;
      }
      try {
        // Best effort only: these writes can be blocked by Firestore rules.
        ensureGlobalBotProfile().catch(() => {});
        ensureBotMembership(currentServerId).catch(() => {});
        const builtIn = runBuiltInBotCommand(prompt);
        if (builtIn) {
          await sendBotMessage(currentServerId, currentChannelId, builtIn);
          saveBotMemory(currentUser?.uid, prompt, builtIn).catch(() => {});
          return true;
        }
        const reply = await askMistral(prompt, currentUser?.uid);
        await sendBotMessage(currentServerId, currentChannelId, reply);
        saveBotMemory(currentUser?.uid, prompt, reply).catch(() => {});
      } catch (err) {
        const reason = (err?.message || 'Unknown error').replace(/\s+/g, ' ').slice(0, 140);
        showToast(`Bot failed: ${reason}`, 'error');
        await sendBotMessage(currentServerId, currentChannelId, 'Bot is currently unavailable. Please try again.');
      }
      return true;
    }

    async function kickUserFromServer(serverId, userId, reason = 'Kicked') {
      if (!serverId || !userId || userId === BOT_USER_ID) return;
      const srv = servers[serverId];
      if (srv?.ownerId === userId) return;
      const mem = Object.values(members).find(m => m.serverId === serverId && m.userId === userId);
      if (!mem) return;
      await deleteDoc(doc(db, 'servers', serverId, 'members', userId));
      await deleteDoc(doc(db, 'memberships', mem.id));
      await ensureUserPublicMembership(userId);
      showToast(reason, 'error');
    }

    async function moderateMessageIfNeeded(messageData) {
      if (!messageData || !currentUser?.uid) return;
      if (messageData.serverId === PUBLIC_SERVER_ID) return;
      if (!messageData.text || !textHasProfanity(messageData.text)) return;
      if (!isAdmin(messageData.serverId)) return;
      const offenderId = messageData.userId;
      if (!offenderId || offenderId === currentUser.uid || offenderId === BOT_USER_ID) return;
      const now = Date.now();
      const last = moderationCooldownByUser[offenderId] || 0;
      if (now - last < 30000) return;
      moderationCooldownByUser[offenderId] = now;
      try {
        await kickUserFromServer(messageData.serverId, offenderId, 'User kicked for profanity');
        if (messageData.channelId) {
          await sendBotMessage(messageData.serverId, messageData.channelId, 'A user was kicked for profanity.');
        }
      } catch (_) {}
    }

    const modal = {
      backdrop: document.getElementById('modal-backdrop'),
      title: document.getElementById('modal-title'),
      body: document.getElementById('modal-body'),
      close: document.getElementById('modal-close'),
      open(title, content) {
        this.title.textContent = title;
        this.body.innerHTML = content;
        this.backdrop.classList.remove('hidden');
        this.backdrop.style.display = 'flex';
        document.body.style.overflow = 'hidden';
      },
      closeModal() {
        this.backdrop.classList.add('hidden');
        this.backdrop.style.display = 'none';
        document.body.style.overflow = '';
        activeMemberProfileUserId = null;
      }
    };
    modal.close.onclick = () => modal.closeModal();
    modal.backdrop.onclick = (e) => { if (e.target === modal.backdrop) modal.closeModal(); };
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        hideContextMenu();
        modal.closeModal();
      }
    });

    function hideContextMenu() {
      const menu = document.getElementById('context-menu');
      if (!menu) return;
      menu.classList.add('hidden');
      menu.innerHTML = '';
      contextMenuMessage = null;
    }

    function showMessageContextMenu(evt, messageData, displayName, isOwn, isBot) {
      const menu = document.getElementById('context-menu');
      if (!menu || !messageData?.id) return;
      evt.preventDefault();
      contextMenuMessage = messageData;
      const canReport = !isOwn && !isBot && messageData.userId !== BOT_USER_ID;
      const canDelete = isAdmin() || isOwn;
      const safeName = escapeHtml(displayName || 'User');
      const hasText = !!(messageData.text || '').trim();
      menu.innerHTML = `
        <button type="button" data-cm="reply" class="context-item w-full text-left px-3 py-2 text-sm text-gray-200">Reply to ${safeName}</button>
        ${hasText ? '<button type="button" data-cm="copy" class="context-item w-full text-left px-3 py-2 text-sm text-gray-200">Copy Message</button>' : ''}
        <button type="button" data-cm="profile" class="context-item w-full text-left px-3 py-2 text-sm text-gray-200">View Profile</button>
        ${canReport ? '<button type="button" data-cm="report" class="context-item w-full text-left px-3 py-2 text-sm text-amber-300">Report User</button>' : ''}
        ${canDelete ? '<button type="button" data-cm="delete" class="context-item w-full text-left px-3 py-2 text-sm text-discord-red">Delete Message</button>' : ''}
      `;
      const pad = 8;
      const maxX = window.innerWidth - 190;
      const maxY = window.innerHeight - 220;
      menu.style.left = `${Math.max(pad, Math.min(evt.clientX, maxX))}px`;
      menu.style.top = `${Math.max(pad, Math.min(evt.clientY, maxY))}px`;
      menu.classList.remove('hidden');
      menu.querySelectorAll('[data-cm]').forEach((btn) => {
        btn.onclick = async () => {
          const action = btn.dataset.cm;
          const m = contextMenuMessage;
          hideContextMenu();
          if (!m) return;
          if (action === 'reply') {
            replyingTo = { id: m.id, userId: m.userId, displayName, text: (m.text || '').slice(0, 100) };
            document.getElementById('reply-preview').classList.remove('hidden');
            document.getElementById('reply-preview-name').textContent = replyingTo.displayName;
            document.getElementById('reply-preview-text').textContent = replyingTo.text || '(attachment)';
            document.getElementById('message-input').focus();
          }
          if (action === 'copy') {
            try {
              await navigator.clipboard.writeText(m.text || '');
              showToast('Message copied', 'success');
            } catch (_) {
              showToast('Copy failed', 'error');
            }
          }
          if (action === 'profile') renderMemberProfileModal(m.userId);
          if (action === 'report') renderReportUserModal(m.userId);
          if (action === 'delete') {
            if (confirm('Delete this message?')) deleteAnyMessage(m.id);
          }
        };
      });
    }

    async function signUp(email, password, displayName) {
      try {
        const signupName = (displayName || email.split('@')[0] || 'User').trim();
        const bannedBefore = await isGloballyBannedIdentity({ email, username: signupName });
        if (bannedBefore) {
          showToast('This account is banned and cannot sign up.', 'error');
          return;
        }
        const cred = await createUserWithEmailAndPassword(auth, email, password);
        const bannedAfter = await isGloballyBannedIdentity({ email, username: signupName });
        if (bannedAfter) {
          try { await firebaseDeleteUser(cred.user); } catch (_) {}
          showToast('This account is banned and cannot sign up.', 'error');
          return;
        }
        await setDoc(doc(db, 'users', cred.user.uid), {
          displayName: signupName,
          displayNameNormalized: normalizeAccountName(signupName),
          email: String(email || '').toLowerCase().trim(),
          bio: '',
          photoURL: '',
          createdAt: serverTimestamp(),
          status: 'offline'
        });
        showToast('Account created!', 'success');
        modal.closeModal();
      } catch (e) {
        const raw = (e?.message || '').toLowerCase();
        if (raw.includes('email') && raw.includes('already')) {
          showToast('That email is already used. Usernames can still be duplicated.', 'error');
          return;
        }
        showToast(e.message || 'Signup failed', 'error');
      }
    }

    async function logIn(email, password) {
      try {
        await signInWithEmailAndPassword(auth, email, password);
        showToast('Logged in!', 'success');
        modal.closeModal();
      } catch (e) { showToast(e.message || 'Login failed', 'error'); }
    }

    async function logOut() {
      try { await updatePresence('offline'); } catch (_) {}
      stopPresenceHeartbeat();
      stopAttachmentCleanupScheduler();
      stopActiveSuspensionWatcher();
      stopPublicSuspensionLifecycleWatcher();
      leaveActiveVoiceChannel().catch(() => {});
      stopVoiceMembersSubscription();
      stopMicStream();
      await signOut(auth);
      currentServerId = null;
      currentChannelId = null;
      updateServerActionButtons();
      document.getElementById('auth-screen').classList.remove('hidden');
      document.getElementById('main-app').classList.add('hidden');
    }

    async function deleteMyAccount(options = {}) {
      if (!currentUser?.uid) return;
      const uid = currentUser.uid;
      const authUser = auth.currentUser;
      if (!authUser || authUser.uid !== uid) {
        showToast('Please sign in again and retry', 'error');
        return;
      }
      try {
        const skipOwnedCheck = !!options.skipOwnedCheck;
        const ownedServers = await getDocs(query(collection(db, 'servers'), where('ownerId', '==', uid)));
        const ownedNonPublic = ownedServers.docs.filter(d => d.id !== PUBLIC_SERVER_ID);
        if (!skipOwnedCheck && ownedNonPublic.length > 0) {
          showToast('Transfer/delete owned servers before deleting account', 'error');
          return;
        }

        const membershipsSnap = await getDocs(query(collection(db, 'memberships'), where('userId', '==', uid)));
        for (const mem of membershipsSnap.docs) {
          const serverId = mem.data()?.serverId;
          if (serverId) {
            try { await deleteDoc(doc(db, 'servers', serverId, 'members', uid)); } catch (_) {}
            try { await deleteDoc(doc(db, 'servers', serverId, 'banned', uid)); } catch (_) {}
            try { await deleteDoc(doc(db, 'servers', serverId, 'suspended', uid)); } catch (_) {}
          }
          await deleteDoc(mem.ref);
        }

        const reportsByUser = await getDocs(query(collection(db, 'reports'), where('reportedBy', '==', uid)));
        for (const r of reportsByUser.docs) await deleteDoc(r.ref);

        const myMessages = await getDocs(query(collection(db, 'messages'), where('userId', '==', uid)));
        for (const m of myMessages.docs) {
          try { await deleteMessageWithAttachments(m.id, m.data()); } catch (_) {}
        }

        try { await deleteDoc(doc(db, 'botMemory', uid)); } catch (_) {}
        try {
          await deleteDoc(doc(db, 'users', uid));
        } catch (_) {}

        if (currentUser?.photoURL?.includes('firebasestorage.googleapis.com')) {
          const avatarPath = getAttachmentStoragePath({ url: currentUser.photoURL });
          if (avatarPath) {
            try { await deleteObject(ref(storage, avatarPath)); } catch (_) {}
          }
        }

        await firebaseDeleteUser(authUser);
        showToast('Account deleted', 'success');
      } catch (err) {
        const msg = String(err?.message || '').toLowerCase();
        if (msg.includes('requires-recent-login')) {
          showToast('Please log out and log back in, then delete account.', 'error');
          return;
        }
        showToast(err?.message || 'Failed to delete account', 'error');
      }
    }

    async function enforcePolicyAccountDeletion(reason = 'Policy violation') {
      if (!currentUser?.uid) return;
      const email = String(auth.currentUser?.email || '').toLowerCase().trim();
      const username = normalizeAccountName(currentUser.displayName || '');
      try {
        if (email) await addGlobalAccountBanToken('email', email, reason);
        if (username) await addGlobalAccountBanToken('username', username, reason);
        if (currentServerId) await addServerBannedAccountName(currentServerId, currentUser.displayName || username, reason);
      } catch (_) {}
      await deleteMyAccount({ skipOwnedCheck: true });
    }

    async function adminDeleteAccountNow(targetUserId) {
      if (!currentServerId || !isAdmin() || !targetUserId || targetUserId === currentUser?.uid || targetUserId === BOT_USER_ID) return;
      try {
        const userSnap = await getDoc(doc(db, 'users', targetUserId));
        const userData = userSnap.exists() ? userSnap.data() : {};
        const displayName = getUserDisplayName(userData, {}) || 'User';
        const normalized = normalizeAccountName(displayName);
        const email = String(userData?.email || '').toLowerCase().trim();
        if (normalized) {
          await addServerBannedAccountName(currentServerId, displayName, 'Admin account delete');
          await addGlobalAccountBanToken('username', normalized, 'Admin account delete');
        }
        if (email) await addGlobalAccountBanToken('email', email, 'Admin account delete');
        const membershipsSnap = await getDocs(query(collection(db, 'memberships'), where('userId', '==', targetUserId)));
        for (const mem of membershipsSnap.docs) {
          const sid = mem.data()?.serverId;
          if (sid) {
            try { await deleteDoc(doc(db, 'servers', sid, 'members', targetUserId)); } catch (_) {}
            try { await deleteDoc(doc(db, 'servers', sid, 'banned', targetUserId)); } catch (_) {}
            try { await deleteDoc(doc(db, 'servers', sid, 'suspended', targetUserId)); } catch (_) {}
          }
          await deleteDoc(mem.ref);
        }
        const msgSnap = await getDocs(query(collection(db, 'messages'), where('userId', '==', targetUserId)));
        for (const m of msgSnap.docs) {
          try { await deleteMessageWithAttachments(m.id, m.data()); } catch (_) {}
        }
        const reportSnap = await getDocs(query(collection(db, 'reports'), where('reportedBy', '==', targetUserId)));
        for (const r of reportSnap.docs) await deleteDoc(r.ref);
        try { await deleteDoc(doc(db, 'botMemory', targetUserId)); } catch (_) {}
        try { await deleteDoc(doc(db, 'users', targetUserId)); } catch (_) {}
        showToast('Account data deleted and banned by username', 'success');
        loadMembers();
      } catch (err) {
        showToast(err?.message || 'Failed to delete account', 'error');
      }
    }

    function renderLoginModal() {
      modal.open('Login', `
        <form id="login-form" class="space-y-4">
          <div>
            <label class="block text-sm text-gray-400 mb-1">Email</label>
            <input type="email" id="login-email" required class="w-full bg-discord-dark border border-discord-darkest rounded px-3 py-2 outline-none focus:border-discord-blurple">
          </div>
          <div>
            <label class="block text-sm text-gray-400 mb-1">Password</label>
            <input type="password" id="login-password" required class="w-full bg-discord-dark border border-discord-darkest rounded px-3 py-2 outline-none focus:border-discord-blurple">
          </div>
          <button type="submit" class="w-full py-2 bg-discord-blurple hover:bg-indigo-600 rounded font-medium">Login</button>
        </form>
      `);
      document.getElementById('login-form').onsubmit = (e) => {
        e.preventDefault();
        logIn(document.getElementById('login-email').value, document.getElementById('login-password').value);
      };
    }

    function renderSignupModal() {
      modal.open('Create Account', `
        <form id="signup-form" class="space-y-4">
          <div>
            <label class="block text-sm text-gray-400 mb-1">Username</label>
            <input type="text" id="signup-display" placeholder="Choose a username" class="w-full bg-discord-dark border border-discord-darkest rounded px-3 py-2 outline-none focus:border-discord-blurple">
            <div class="text-xs text-gray-500 mt-1">Usernames are not unique. Multiple users can use the same username.</div>
          </div>
          <div>
            <label class="block text-sm text-gray-400 mb-1">Email</label>
            <input type="email" id="signup-email" required class="w-full bg-discord-dark border border-discord-darkest rounded px-3 py-2 outline-none focus:border-discord-blurple">
          </div>
          <div>
            <label class="block text-sm text-gray-400 mb-1">Password</label>
            <input type="password" id="signup-password" required minlength="6" class="w-full bg-discord-dark border border-discord-darkest rounded px-3 py-2 outline-none focus:border-discord-blurple">
          </div>
          <button type="submit" class="w-full py-2 bg-discord-blurple hover:bg-indigo-600 rounded font-medium">Create Account</button>
        </form>
      `);
      document.getElementById('signup-form').onsubmit = (e) => {
        e.preventDefault();
        signUp(document.getElementById('signup-email').value, document.getElementById('signup-password').value, document.getElementById('signup-display').value);
      };
    }

    function renderProfileModal() {
      modal.open('Edit Profile', `
        <form id="profile-form" class="space-y-4">
          <div class="flex items-center gap-4">
            <div id="profile-avatar-preview" class="w-16 h-16 rounded-full bg-discord-blurple flex items-center justify-center overflow-hidden flex-shrink-0">
              <img id="profile-avatar-img" class="w-full h-full object-cover" src="${currentUser?.photoURL || ''}" alt="" onerror="this.style.display='none'">
              <span id="profile-avatar-initial" class="text-2xl font-bold">${(currentUser?.displayName || '?')[0].toUpperCase()}</span>
            </div>
            <div class="flex-1">
              <label class="block text-sm text-gray-400 mb-1">Change Avatar</label>
              <label for="profile-avatar-input" class="inline-block px-4 py-2 rounded bg-discord-blurple hover:bg-indigo-600 text-white text-sm font-medium cursor-pointer transition">Choose Photo</label>
              <input type="file" id="profile-avatar-input" accept="image/*" class="hidden">
            </div>
          </div>
          <div>
            <label class="block text-sm text-gray-400 mb-1">Display Name</label>
            <input type="text" id="profile-display" value="${escapeHtml(currentUser?.displayName || '')}" class="w-full bg-discord-dark border border-discord-darkest rounded px-3 py-2 outline-none focus:border-discord-blurple">
          </div>
          <div>
            <label class="block text-sm text-gray-400 mb-1">About Me</label>
            <textarea id="profile-bio" rows="3" maxlength="200" placeholder="Say something about yourself" class="w-full bg-discord-dark border border-discord-darkest rounded px-3 py-2 outline-none focus:border-discord-blurple resize-none">${escapeHtml(currentUser?.bio || '')}</textarea>
          </div>
          <div class="rounded border border-discord-dark bg-discord-dark/40 p-3">
            <div class="flex items-center justify-between gap-2">
              <div>
                <div class="text-sm text-gray-200">Desktop Notifications</div>
                <div id="profile-notification-status" class="text-xs text-gray-500 mt-0.5">Permission: ${getNotificationPermissionLabel()}</div>
              </div>
              <button type="button" id="profile-notifications-toggle" class="px-3 py-1 rounded text-sm font-medium transition ${notificationsEnabled ? 'bg-discord-blurple hover:bg-indigo-600 text-white' : 'bg-discord-dark hover:bg-discord-darker text-gray-300'}">${notificationsEnabled ? 'On' : 'Off'}</button>
            </div>
          </div>
          <div class="rounded border border-discord-red/50 bg-discord-dark/40 p-3">
            <div class="text-sm text-gray-200 mb-2">Danger Zone</div>
            <button type="button" id="profile-delete-account" class="w-full py-2 rounded bg-discord-red hover:bg-red-500 text-sm font-medium">Delete Account</button>
          </div>
          <button type="submit" class="w-full py-2 bg-discord-blurple hover:bg-indigo-600 rounded font-medium">Save</button>
        </form>
      `);
      const img = document.getElementById('profile-avatar-img');
      const initialSpan = document.getElementById('profile-avatar-initial');
      if (currentUser?.photoURL) { img.src = currentUser.photoURL; img.style.display = 'block'; initialSpan.style.display = 'none'; }
      else { img.style.display = 'none'; initialSpan.style.display = 'flex'; }
      document.getElementById('profile-notifications-toggle').onclick = async () => {
        await setNotificationsEnabled(!notificationsEnabled);
      };
      document.getElementById('profile-delete-account').onclick = async () => {
        if (!confirm('Delete your account permanently? This cannot be undone.')) return;
        if (!confirm('Final confirmation: all your account data will be removed.')) return;
        modal.closeModal();
        await deleteMyAccount();
      };
      updateNotificationToggleUI();
      document.getElementById('profile-avatar-input').onchange = async (e) => {
        const file = e.target.files?.[0];
        if (!file) return;
        try {
          const r = ref(storage, `users/${currentUser.uid}/avatar`);
          await uploadBytes(r, file);
          const url = await getDownloadURL(r);
          const moderation = await analyzeImageModeration(url);
          if (moderation.flagged) {
            try { await deleteObject(r); } catch (_) {}
            showToast('Inappropriate image detected. Account removed.', 'error');
            await enforcePolicyAccountDeletion(moderation.reason || 'Inappropriate image');
            return;
          }
          await updateDoc(doc(db, 'users', currentUser.uid), { photoURL: url });
          currentUser.photoURL = url;
          img.src = url; img.style.display = 'block'; document.getElementById('profile-avatar-initial').style.display = 'none';
          showToast('Avatar updated!', 'success');
        } catch (err) { showToast(err.message, 'error'); }
      };
      document.getElementById('profile-form').onsubmit = async (e) => {
        e.preventDefault();
        const name = document.getElementById('profile-display').value.trim();
        const bio = document.getElementById('profile-bio').value.trim();
        if (!name) return;
        try {
          await updateDoc(doc(db, 'users', currentUser.uid), { displayName: name, bio });
          currentUser.displayName = name;
          currentUser.bio = bio;
          updateUserPill();
          showToast('Profile updated!', 'success');
          modal.closeModal();
        } catch (err) { showToast(err.message, 'error'); }
      };
    }

    async function updatePresence(status = 'online') {
      if (!currentUser?.uid) return;
      await setDoc(doc(db, 'users', currentUser.uid), { status, lastSeen: serverTimestamp() }, { merge: true });
    }

    function startPresenceHeartbeat() {
      if (presenceInterval) clearInterval(presenceInterval);
      presenceInterval = setInterval(() => {
        if (!currentUser?.uid) return;
        updatePresence(document.hidden ? 'idle' : 'online').catch(() => {});
      }, PRESENCE_HEARTBEAT_MS);
    }

    function stopPresenceHeartbeat() {
      if (!presenceInterval) return;
      clearInterval(presenceInterval);
      presenceInterval = null;
    }

    function getEffectivePresenceStatus(userId) {
      const status = userPresence[userId] || 'offline';
      const lastSeen = memberUserData[userId]?.lastSeen;
      const seenAt = lastSeen?.toDate ? lastSeen.toDate().getTime() : (lastSeen ? new Date(lastSeen).getTime() : 0);
      if (!seenAt) return status;
      if (Date.now() - seenAt > PRESENCE_STALE_MS) return 'offline';
      return status;
    }

    function clearMemberUserListeners() {
      Object.values(memberUserUnsubs).forEach(unsub => typeof unsub === 'function' && unsub());
      memberUserUnsubs = {};
    }

    function subscribePresence(serverId) {
      if (unsubPresence) unsubPresence();
      if (!serverId) return;
      const memberIds = Object.values(members).filter(m => m.serverId === serverId).map(m => m.userId);
      if (memberIds.length === 0) return;
      const batch = memberIds.slice(0, 10);
      unsubPresence = onSnapshot(query(collection(db, 'users'), where('__name__', 'in', batch)), (snap) => {
        snap.docs.forEach(d => { userPresence[d.id] = d.data().status || 'offline'; });
        renderMembers();
      });
    }

    async function createServer(name, iconFile, options = {}) {
      if (!currentUser?.uid) return;
      try {
        const botChat = !!options.botChat;
        const serverRef = doc(collection(db, 'servers'));
        let iconUrl = '';
        if (iconFile && !botChat) {
          const r = ref(storage, `servers/${serverRef.id}/icon`);
          await uploadBytes(r, iconFile);
          iconUrl = await getDownloadURL(r);
        }
        const serverName = botChat ? (name || 'Bot Chat') : (name || 'New Server');
        await setDoc(serverRef, { name: serverName, ownerId: currentUser.uid, icon: iconUrl, botOnly: botChat, createdAt: serverTimestamp() });
        await setDoc(doc(db, 'servers', serverRef.id, 'members', currentUser.uid), { role: 'owner' });
        const chRef = doc(collection(db, 'channels'));
        await setDoc(chRef, { serverId: serverRef.id, name: botChat ? 'bot-chat' : 'general', type: 'text', createdAt: serverTimestamp() });
        await setDoc(doc(collection(db, 'memberships')), { serverId: serverRef.id, userId: currentUser.uid, role: 'owner' });
        if (botChat) {
          ensureGlobalBotProfile().catch(() => {});
          await setDoc(doc(db, 'servers', serverRef.id, 'members', BOT_USER_ID), { role: 'bot' }, { merge: true });
          await setDoc(doc(collection(db, 'memberships')), { serverId: serverRef.id, userId: BOT_USER_ID, role: 'bot' });
          await sendBotMessage(serverRef.id, chRef.id, `Welcome to your private bot chat. You can talk naturally here and I will respond without needing "bot". Try /help.`);
        }
        showToast('Server created!', 'success');
        modal.closeModal();
        loadServers();
      } catch (e) { showToast(e.message, 'error'); }
    }

    async function deleteServerPermanently(serverId) {
      if (!serverId || !currentUser?.uid) return;
      const srv = servers[serverId];
      if (!srv) { showToast('Server not found', 'error'); return; }
      if (serverId === PUBLIC_SERVER_ID) { showToast('Public server cannot be deleted', 'error'); return; }
      if (srv.ownerId !== currentUser.uid) { showToast('Only owner can delete server', 'error'); return; }
      try {
        showToast('Deleting server...', 'info');
        const channelsSnap = await getDocs(query(collection(db, 'channels'), where('serverId', '==', serverId)));
        for (const ch of channelsSnap.docs) {
          try {
            const typingSnap = await getDocs(collection(db, 'channels', ch.id, 'typing'));
            for (const t of typingSnap.docs) await deleteDoc(t.ref);
          } catch (_) {}
          try {
            const voiceSnap = await getDocs(collection(db, 'channels', ch.id, 'voiceMembers'));
            for (const v of voiceSnap.docs) await deleteDoc(v.ref);
          } catch (_) {}
          await deleteDoc(ch.ref);
        }

        const msgsSnap = await getDocs(query(collection(db, 'messages'), where('serverId', '==', serverId)));
        for (const m of msgsSnap.docs) {
          await deleteMessageWithAttachments(m.id, m.data());
        }

        const invitesSnap = await getDocs(query(collection(db, 'invites'), where('serverId', '==', serverId)));
        for (const inv of invitesSnap.docs) await deleteDoc(inv.ref);

        const reportsSnap = await getDocs(query(collection(db, 'reports'), where('serverId', '==', serverId)));
        for (const rep of reportsSnap.docs) await deleteDoc(rep.ref);

        const membershipsSnap = await getDocs(query(collection(db, 'memberships'), where('serverId', '==', serverId)));
        for (const mem of membershipsSnap.docs) await deleteDoc(mem.ref);

        const memberDocs = await getDocs(collection(db, 'servers', serverId, 'members'));
        for (const d of memberDocs.docs) await deleteDoc(d.ref);
        const bannedDocs = await getDocs(collection(db, 'servers', serverId, 'banned'));
        for (const d of bannedDocs.docs) await deleteDoc(d.ref);
        const suspendedDocs = await getDocs(collection(db, 'servers', serverId, 'suspended'));
        for (const d of suspendedDocs.docs) await deleteDoc(d.ref);
        const blockedNameDocs = await getDocs(collection(db, 'servers', serverId, 'bannedAccounts'));
        for (const d of blockedNameDocs.docs) await deleteDoc(d.ref);
        const emojiDocs = await getDocs(collection(db, 'servers', serverId, 'emojis'));
        for (const d of emojiDocs.docs) await deleteDoc(d.ref);

        const iconPath = getAttachmentStoragePath({ url: srv.icon || '' });
        if (iconPath) {
          try { await deleteObject(ref(storage, iconPath)); } catch (_) {}
        }

        await deleteDoc(doc(db, 'servers', serverId));
        if (currentServerId === serverId) {
          currentServerId = null;
          currentChannelId = null;
          renderChannelList();
          renderMessages();
        }
        modal.closeModal();
        showToast('Server deleted permanently', 'success');
        await loadServers();
      } catch (e) {
        showToast(e.message || 'Failed to delete server', 'error');
      }
    }

    function isAdmin(serverId) {
      const sid = serverId || currentServerId;
      if (!sid || !currentUser?.uid) return false;
      const srv = servers[sid];
      if (srv?.ownerId === 'system') return false;
      if (srv?.ownerId === currentUser.uid) return true;
      const mem = Object.values(members).find(m => m.serverId === sid && m.userId === currentUser.uid);
      return mem?.role === 'admin';
    }

    async function joinServerByCode(code) {
      if (!currentUser?.uid || !code) return;
      const q = query(collection(db, 'invites'), where('code', '==', code.trim().toUpperCase()));
      const snap = await getDocs(q);
      const inv = snap.docs.find(d => {
        const d_ = d.data();
        if (d_.maxUses && d_.uses >= d_.maxUses) return false;
        if (d_.expireAt?.toDate && d_.expireAt.toDate() < new Date()) return false;
        return true;
      });
      if (!inv) { showToast('Invalid or expired invite', 'error'); return; }
      const invData = inv.data();
      const bannedSnap = await getDoc(doc(db, 'servers', invData.serverId, 'banned', currentUser.uid));
      if (bannedSnap.exists()) { showToast('You are banned from this server', 'error'); return; }
      const isNameBanned = await isBannedNameForServer(invData.serverId, currentUser.displayName || '');
      if (isNameBanned) { showToast('Your account name is blocked from this server', 'error'); return; }
      const activeSuspension = await getActiveSuspension(invData.serverId, currentUser.uid);
      if (activeSuspension) {
        showSuspensionLockModal(servers[invData.serverId]?.name || 'this server', activeSuspension);
        return;
      }
      const existing = await getDocs(query(collection(db, 'memberships'), where('serverId', '==', invData.serverId), where('userId', '==', currentUser.uid)));
      if (!existing.empty) { showToast('Already a member', 'info'); selectServer(invData.serverId); modal.closeModal(); return; }
      await setDoc(doc(db, 'servers', invData.serverId, 'members', currentUser.uid), { role: 'member' });
      await setDoc(doc(collection(db, 'memberships')), { serverId: invData.serverId, userId: currentUser.uid, role: 'member' });
      await updateDoc(doc(db, 'invites', inv.id), { uses: increment(1) });
      showToast('Joined server!', 'success');
      modal.closeModal();
      await loadServers();
      if (servers[invData.serverId]) selectServer(invData.serverId);
      else showToast('Joined, but server details could not be loaded', 'error');
    }

    async function leaveServer() {
      if (!currentServerId || !currentUser?.uid) {
        showToast('Select a server first', 'error');
        return;
      }
      if (currentServerId === PUBLIC_SERVER_ID) {
        showToast('Cannot leave the public server', 'error');
        return;
      }
      const mem = Object.values(members).find(m => m.serverId === currentServerId && m.userId === currentUser.uid);
      if (!mem) return;
      const srv = servers[currentServerId];
      if (srv?.ownerId === currentUser.uid) { showToast('Transfer ownership before leaving', 'error'); return; }
      await deleteDoc(doc(db, 'servers', currentServerId, 'members', currentUser.uid));
      await deleteDoc(doc(db, 'memberships', mem.id));
      showToast('Left server', 'info');
      currentServerId = null; currentChannelId = null;
      leaveActiveVoiceChannel().catch(() => {});
      stopVoiceMembersSubscription();
      stopMicStream();
      stopActiveSuspensionWatcher();
      stopServerBannedAccountsWatcher();
      loadServers();
      renderChannelList();
      renderMessages();
    }

    async function selectServer(serverId) {
      if (activeVoiceChannelId) {
        leaveActiveVoiceChannel().catch(() => {});
      }
      stopVoiceMembersSubscription();
      stopMicStream();
      const nameBlocked = await isBannedNameForServer(serverId, currentUser?.displayName || '');
      if (nameBlocked) {
        showToast('Your account name is blocked from this server', 'error');
        if (serverId === PUBLIC_SERVER_ID) {
          await redirectSuspendedUserFromPublic({ untilMs: Date.now() + 15 * 60 * 1000, reason: 'Blocked account name' });
        } else if (servers[PUBLIC_SERVER_ID] && currentServerId !== PUBLIC_SERVER_ID) {
          selectServer(PUBLIC_SERVER_ID);
        }
        return;
      }
      const suspension = await getActiveSuspension(serverId, currentUser?.uid);
      if (suspension) {
        const serverName = servers[serverId]?.name || 'this server';
        if (serverId === PUBLIC_SERVER_ID) {
          await redirectSuspendedUserFromPublic(suspension);
        } else {
          showSuspensionLockModal(serverName, suspension);
          if (servers[PUBLIC_SERVER_ID] && currentServerId !== PUBLIC_SERVER_ID) {
            selectServer(PUBLIC_SERVER_ID);
          }
        }
        return;
      }
      currentServerId = serverId;
      currentChannelId = null;
      seenReportAlerts.clear();
      openReports = {};
      lastSuspensionNoticeKey = '';
      startActiveSuspensionWatcher(serverId);
      document.getElementById('current-server-name').textContent = servers[serverId]?.name || 'Server';
      updateServerActionButtons();
      loadChannels(serverId);
      loadMembers();
      document.getElementById('messages-loading').classList.remove('hidden');
      renderMessages();
    }

    async function ensurePublicServer() {
      const publicRef = doc(db, 'servers', PUBLIC_SERVER_ID);
      const publicSnap = await getDoc(publicRef);
      if (!publicSnap.exists()) {
        await setDoc(publicRef, { name: 'Public', ownerId: 'system', icon: '', createdAt: serverTimestamp() });
        const chRef = doc(collection(db, 'channels'));
        await setDoc(chRef, { serverId: PUBLIC_SERVER_ID, name: 'general', type: 'text', createdAt: serverTimestamp() });
      }
      ensureGlobalBotProfile().catch(() => {});
      ensureBotMembership(PUBLIC_SERVER_ID).catch(() => {});
    }

    async function ensurePublicMembership() {
      const membershipsSnap = await getDocs(query(collection(db, 'memberships'), where('userId', '==', currentUser.uid)));
      if (!membershipsSnap.empty) return;
      await ensurePublicServer();
      await setDoc(doc(db, 'servers', PUBLIC_SERVER_ID, 'members', currentUser.uid), { role: 'member' });
      await setDoc(doc(collection(db, 'memberships')), { serverId: PUBLIC_SERVER_ID, userId: currentUser.uid, role: 'member' });
    }

    async function ensureUserPublicMembership(userId) {
      if (!userId) return;
      await ensurePublicServer();
      const existingMembership = await getDocs(query(
        collection(db, 'memberships'),
        where('serverId', '==', PUBLIC_SERVER_ID),
        where('userId', '==', userId)
      ));
      if (existingMembership.empty) {
        await setDoc(doc(collection(db, 'memberships')), { serverId: PUBLIC_SERVER_ID, userId, role: 'member' });
      }
      const publicMemberRef = doc(db, 'servers', PUBLIC_SERVER_ID, 'members', userId);
      const existingPublicMember = await getDoc(publicMemberRef);
      if (!existingPublicMember.exists()) {
        await setDoc(publicMemberRef, { role: 'member' });
      }
    }

    async function loadServers() {
      if (!currentUser?.uid) return;
      await ensurePublicMembership();
      if (unsubMyMemberships) { unsubMyMemberships(); unsubMyMemberships = null; }
      const loadVersion = ++serversLoadVersion;
      const q = query(collection(db, 'memberships'), where('userId', '==', currentUser.uid));
      unsubMyMemberships = onSnapshot(q, async (snap) => {
        if (loadVersion !== serversLoadVersion || !currentUser?.uid) return;
        const nextMembers = {};
        snap.docs.forEach(d => { nextMembers[d.id] = { id: d.id, ...d.data() }; });
        const serverIds = [...new Set(snap.docs.map(d => d.data().serverId))];
        const nextServers = {};
        const serverDocs = await Promise.all(serverIds.map(sid => getDoc(doc(db, 'servers', sid))));
        if (loadVersion !== serversLoadVersion || !currentUser?.uid) return;
        serverDocs.forEach((sDoc, i) => {
          if (sDoc.exists()) nextServers[serverIds[i]] = { id: serverIds[i], ...sDoc.data() };
        });
        servers = nextServers;
        members = nextMembers;
        renderServerList();
        if (currentServerId && !servers[currentServerId]) {
          currentServerId = null;
          currentChannelId = null;
          renderChannelList();
          renderMessages();
          updateServerActionButtons();
        }
        if (!currentServerId && Object.keys(servers).length > 0) {
          const first = servers[PUBLIC_SERVER_ID] ? PUBLIC_SERVER_ID : Object.keys(servers)[0];
          selectServer(first);
        }
      }, (err) => {
        if (loadVersion !== serversLoadVersion) return;
        showToast(err.message || 'Failed to load servers', 'error');
      });
    }

    function renderServerList() {
      const el = document.getElementById('server-list');
      el.innerHTML = '';
      const sorted = Object.values(servers).sort((a, b) => (a.id === PUBLIC_SERVER_ID ? -1 : b.id === PUBLIC_SERVER_ID ? 1 : 0));
      sorted.forEach(s => {
        const btn = document.createElement('button');
        btn.className = `w-12 h-12 rounded-2xl flex items-center justify-center overflow-hidden transition ${currentServerId === s.id ? 'rounded-xl bg-discord-blurple' : 'hover:bg-discord-blurple'}`;
        btn.title = s.name;
        if (s.icon) { btn.innerHTML = `<img src="${s.icon}" class="w-full h-full object-cover" alt="">`; }
        else { btn.textContent = (s.name || 'S')[0].toUpperCase(); btn.classList.add('bg-discord-dark'); }
        btn.onclick = () => selectServer(s.id);
        el.appendChild(btn);
      });
    }

    async function loadChannels(serverId) {
      const sid = serverId || currentServerId;
      if (!sid) return;
      if (channelUnsub) { channelUnsub(); channelUnsub = null; }
      const q = query(collection(db, 'channels'), where('serverId', '==', sid), orderBy('createdAt'));
      channelUnsub = onSnapshot(q, (snap) => {
        channels = {};
        snap.docs.forEach(d => {
          const data = d.data() || {};
          channels[d.id] = { id: d.id, ...data, type: data.type === 'voice' ? 'voice' : 'text' };
        });
        renderChannelList();
        const serverChannels = Object.values(channels).filter(c => c.serverId === sid);
        const textChannels = serverChannels.filter(c => c.type !== 'voice');
        const chIds = serverChannels.map(c => c.id);
        if (chIds.length && currentServerId === sid && !currentChannelId) {
          selectChannel((textChannels[0] || serverChannels[0]).id);
        } else if (currentChannelId && !channels[currentChannelId]) {
          currentChannelId = null;
          if (currentServerId === sid && chIds.length) selectChannel((textChannels[0] || serverChannels[0]).id);
        } else if (chIds.length === 0 && currentServerId === sid) {
          currentChannelId = null;
          document.getElementById('messages-loading').classList.add('hidden');
          renderMessages();
        }
      }, (err) => {
        document.getElementById('messages-loading').classList.add('hidden');
        showToast(err.message || 'Failed to load channels', 'error');
      });
    }

    function renderChannelList() {
      const el = document.getElementById('channel-list');
      el.innerHTML = '';
      const items = Object.values(channels).filter(c => c.serverId === currentServerId);
      const textItems = items.filter(c => c.type !== 'voice');
      const voiceItems = items.filter(c => c.type === 'voice');
      const renderRow = (ch, isVoice) => {
        const btn = document.createElement('button');
        btn.className = `w-full text-left px-2 py-1.5 rounded flex items-center gap-2 text-sm ${currentChannelId === ch.id ? 'bg-discord-dark text-white' : 'text-gray-400 hover:bg-discord-dark hover:text-white'}`;
        btn.innerHTML = `<span>${isVoice ? 'ğŸ”Š' : '#'}</span><span class="truncate">${escapeHtml(ch.name)}</span>`;
        btn.onclick = () => {
          selectChannel(ch.id);
          if (window.innerWidth < 768) {
            document.getElementById('channel-sidebar')?.classList.add('hidden');
          }
        };
        el.appendChild(btn);
      };
      if (textItems.length) {
        const label = document.createElement('div');
        label.className = 'px-2 pt-1 pb-1 text-[11px] uppercase tracking-wide text-gray-500';
        label.textContent = 'Text';
        el.appendChild(label);
        textItems.forEach(ch => renderRow(ch, false));
      }
      if (voiceItems.length) {
        const label = document.createElement('div');
        label.className = 'px-2 pt-3 pb-1 text-[11px] uppercase tracking-wide text-gray-500';
        label.textContent = 'Voice';
        el.appendChild(label);
        voiceItems.forEach(ch => renderRow(ch, true));
      }
    }

    async function createChannel(name, type = 'text') {
      if (!currentServerId || !currentUser?.uid) return;
      if (!isAdmin()) { showToast('Admin only', 'error'); return; }
      try {
        const chRef = doc(collection(db, 'channels'));
        await setDoc(chRef, {
          serverId: currentServerId,
          name: (name || 'new-channel').replace(/\s/g, '-').toLowerCase(),
          type: type === 'voice' ? 'voice' : 'text',
          createdAt: serverTimestamp()
        });
        showToast('Channel created!', 'success');
        modal.closeModal();
      } catch (e) { showToast(e.message, 'error'); }
    }

    async function deleteChannel(channelId) {
      if (!channelId) return;
      const ch = channels[channelId];
      if (!ch || ch.serverId !== currentServerId) return;
      if (!isAdmin()) { showToast('Admin only', 'error'); return; }
      try {
        if (activeVoiceChannelId === channelId) {
          activeVoiceChannelId = null;
          stopVoiceMembersSubscription();
          renderVoicePanel();
        }
        try {
          const voiceMembersSnap = await getDocs(collection(db, 'channels', channelId, 'voiceMembers'));
          for (const v of voiceMembersSnap.docs) await deleteDoc(v.ref);
        } catch (_) {}
        try {
          const signalPairs = await getDocs(collection(db, 'channels', channelId, 'voiceSignals'));
          for (const pair of signalPairs.docs) {
            const eventsSnap = await getDocs(collection(db, 'channels', channelId, 'voiceSignals', pair.id, 'events'));
            for (const ev of eventsSnap.docs) await deleteDoc(ev.ref);
            await deleteDoc(pair.ref);
          }
        } catch (_) {}
        const msgs = await getDocs(query(collection(db, 'messages'), where('channelId', '==', channelId)));
        for (const m of msgs.docs) await deleteMessageWithAttachments(m.id, m.data());
        await deleteDoc(doc(db, 'channels', channelId));
        showToast('Channel deleted', 'info');
        if (currentChannelId === channelId) { currentChannelId = null; selectServer(currentServerId); }
        modal.closeModal();
      } catch (e) { showToast(e.message, 'error'); }
    }

    function stopVoiceMembersSubscription() {
      if (unsubVoiceMembers) {
        unsubVoiceMembers();
        unsubVoiceMembers = null;
      }
      voiceMembers = {};
      teardownVoiceRtc();
      renderVoicePanel();
    }

    async function ensureMicAccess() {
      if (activeVoiceStream && activeVoiceStream.active) return activeVoiceStream;
      if (!navigator?.mediaDevices?.getUserMedia) {
        throw new Error('Microphone is not supported in this browser');
      }
      activeVoiceStream = await navigator.mediaDevices.getUserMedia({ audio: true });
      return activeVoiceStream;
    }

    function stopMicStream() {
      if (!activeVoiceStream) return;
      try {
        activeVoiceStream.getTracks().forEach((t) => t.stop());
      } catch (_) {}
      activeVoiceStream = null;
    }

    function getVoicePairId(a, b) {
      return [String(a || ''), String(b || '')].sort().join('__');
    }

    function getVoiceEventsRef(channelId, remoteUid) {
      const pairId = getVoicePairId(currentUser?.uid, remoteUid);
      return collection(db, 'channels', channelId, 'voiceSignals', pairId, 'events');
    }

    function removeRemoteVoiceAudio(remoteUid) {
      const el = remoteVoiceAudioEls[remoteUid];
      if (!el) return;
      try { el.pause(); } catch (_) {}
      el.srcObject = null;
      el.remove();
      delete remoteVoiceAudioEls[remoteUid];
    }

    function teardownVoicePeer(remoteUid) {
      const unsub = voiceSignalUnsubs[remoteUid];
      if (typeof unsub === 'function') unsub();
      delete voiceSignalUnsubs[remoteUid];
      delete handledVoiceSignalsByPeer[remoteUid];
      const pc = voicePeerConnections[remoteUid];
      if (pc) {
        try { pc.onicecandidate = null; } catch (_) {}
        try { pc.ontrack = null; } catch (_) {}
        try { pc.close(); } catch (_) {}
      }
      delete voicePeerConnections[remoteUid];
      removeRemoteVoiceAudio(remoteUid);
    }

    function teardownVoiceRtc() {
      Object.keys(voicePeerConnections).forEach((uid) => teardownVoicePeer(uid));
    }

    async function emitVoiceSignal(remoteUid, payload) {
      if (!activeVoiceChannelId || !currentUser?.uid || !remoteUid) return;
      try {
        await addDoc(getVoiceEventsRef(activeVoiceChannelId, remoteUid), {
          from: currentUser.uid,
          to: remoteUid,
          ...payload,
          createdAt: serverTimestamp()
        });
      } catch (_) {}
    }

    function subscribeVoiceSignals(remoteUid) {
      if (!activeVoiceChannelId || !remoteUid || voiceSignalUnsubs[remoteUid]) return;
      handledVoiceSignalsByPeer[remoteUid] = handledVoiceSignalsByPeer[remoteUid] || new Set();
      voiceSignalUnsubs[remoteUid] = onSnapshot(getVoiceEventsRef(activeVoiceChannelId, remoteUid), (snap) => {
        snap.docChanges().forEach((change) => {
          if (change.type !== 'added') return;
          const id = change.doc.id;
          const handled = handledVoiceSignalsByPeer[remoteUid];
          if (handled?.has(id)) return;
          handled?.add(id);
          const data = change.doc.data() || {};
          if (data.from === currentUser?.uid) return;
          processVoiceSignal(remoteUid, data).catch(() => {});
        });
      }, () => {});
    }

    async function processVoiceSignal(remoteUid, data) {
      if (!activeVoiceChannelId || !currentUser?.uid) return;
      const type = data?.type;
      if (!type) return;
      const pc = await ensureVoicePeer(remoteUid);
      if (!pc) return;
      if (type === 'offer' && data.sdp) {
        try {
          if (pc.signalingState !== 'stable') {
            await pc.setLocalDescription({ type: 'rollback' }).catch(() => {});
          }
          await pc.setRemoteDescription(new RTCSessionDescription(data.sdp));
          const answer = await pc.createAnswer();
          await pc.setLocalDescription(answer);
          await emitVoiceSignal(remoteUid, { type: 'answer', sdp: pc.localDescription });
        } catch (_) {}
        return;
      }
      if (type === 'answer' && data.sdp) {
        if (pc.signalingState === 'have-local-offer') {
          await pc.setRemoteDescription(new RTCSessionDescription(data.sdp)).catch(() => {});
        }
        return;
      }
      if (type === 'candidate' && data.candidate) {
        await pc.addIceCandidate(new RTCIceCandidate(data.candidate)).catch(() => {});
      }
    }

    async function ensureVoicePeer(remoteUid) {
      if (!remoteUid || remoteUid === currentUser?.uid || !activeVoiceChannelId) return null;
      if (voicePeerConnections[remoteUid]) return voicePeerConnections[remoteUid];
      const pc = new RTCPeerConnection(VOICE_RTC_CONFIG);
      voicePeerConnections[remoteUid] = pc;
      subscribeVoiceSignals(remoteUid);
      (activeVoiceStream?.getTracks() || []).forEach((track) => {
        try { pc.addTrack(track, activeVoiceStream); } catch (_) {}
      });
      pc.onicecandidate = (event) => {
        if (event.candidate) {
          emitVoiceSignal(remoteUid, {
            type: 'candidate',
            candidate: event.candidate.toJSON ? event.candidate.toJSON() : event.candidate
          }).catch(() => {});
        }
      };
      pc.ontrack = (event) => {
        let el = remoteVoiceAudioEls[remoteUid];
        if (!el) {
          el = document.createElement('audio');
          el.autoplay = true;
          el.playsInline = true;
          el.className = 'hidden';
          document.body.appendChild(el);
          remoteVoiceAudioEls[remoteUid] = el;
        }
        const [stream] = event.streams || [];
        if (stream) {
          el.srcObject = stream;
          el.play().catch(() => {});
        }
      };
      pc.onconnectionstatechange = () => {
        if (['failed', 'closed', 'disconnected'].includes(pc.connectionState)) {
          teardownVoicePeer(remoteUid);
        }
      };
      const shouldInitiate = String(currentUser.uid) < String(remoteUid);
      if (shouldInitiate) {
        try {
          const offer = await pc.createOffer();
          await pc.setLocalDescription(offer);
          await emitVoiceSignal(remoteUid, { type: 'offer', sdp: pc.localDescription });
        } catch (_) {}
      }
      return pc;
    }

    function reconcileVoicePeers() {
      if (!activeVoiceChannelId || !currentUser?.uid) {
        teardownVoiceRtc();
        return;
      }
      const remoteIds = new Set(
        Object.keys(voiceMembers).filter((uid) => uid !== currentUser.uid)
      );
      remoteIds.forEach((uid) => {
        ensureVoicePeer(uid).catch(() => {});
      });
      Object.keys(voicePeerConnections).forEach((uid) => {
        if (!remoteIds.has(uid)) teardownVoicePeer(uid);
      });
    }

    async function leaveActiveVoiceChannel() {
      if (!activeVoiceChannelId || !currentUser?.uid) return;
      const channelId = activeVoiceChannelId;
      activeVoiceChannelId = null;
      teardownVoiceRtc();
      try {
        await deleteDoc(doc(db, 'channels', channelId, 'voiceMembers', currentUser.uid));
      } catch (_) {}
      stopMicStream();
      renderVoicePanel();
    }

    async function joinVoiceChannel(channelId) {
      if (!channelId || !currentUser?.uid) return;
      const activeSuspension = await getActiveSuspension(currentServerId, currentUser.uid);
      if (activeSuspension) {
        showSuspensionLockModal(servers[currentServerId]?.name || 'this server', activeSuspension);
        return;
      }
      try {
        if (typeof RTCPeerConnection === 'undefined') {
          throw new Error('Voice is not supported in this browser');
        }
        await ensureMicAccess();
        if (activeVoiceChannelId && activeVoiceChannelId !== channelId) {
          await leaveActiveVoiceChannel();
        }
        activeVoiceChannelId = channelId;
        await setDoc(doc(db, 'channels', channelId, 'voiceMembers', currentUser.uid), {
          userId: currentUser.uid,
          displayName: currentUser.displayName || 'User',
          joinedAt: serverTimestamp()
        }, { merge: true });
        showToast('Microphone connected', 'success');
        reconcileVoicePeers();
        renderVoicePanel();
      } catch (err) {
        activeVoiceChannelId = null;
        teardownVoiceRtc();
        stopMicStream();
        const msg = String(err?.message || '');
        if (/missing or insufficient permissions/i.test(msg)) {
          showToast('Voice join blocked by Firestore rules. Publish latest firestore.rules.', 'error');
        } else if (/denied|permission/i.test(msg)) {
          showToast('Microphone permission denied', 'error');
        } else {
          showToast(err?.message || 'Failed to join voice', 'error');
        }
      }
    }

    function subscribeVoiceMembers(channelId) {
      stopVoiceMembersSubscription();
      if (!channelId) return;
      unsubVoiceMembers = onSnapshot(collection(db, 'channels', channelId, 'voiceMembers'), (snap) => {
        const next = {};
        snap.docs.forEach((d) => { next[d.id] = { id: d.id, ...d.data() }; });
        voiceMembers = next;
        reconcileVoicePeers();
        renderVoicePanel();
      }, () => {});
    }

    function renderVoicePanel() {
      const panel = document.getElementById('voice-channel-panel');
      const membersEl = document.getElementById('voice-members-list');
      const joinBtn = document.getElementById('btn-voice-join');
      const leaveBtn = document.getElementById('btn-voice-leave');
      const nameEl = document.getElementById('voice-channel-name');
      const ch = channels[currentChannelId];
      const isVoice = ch?.type === 'voice';
      panel.classList.toggle('hidden', !isVoice);
      if (!isVoice) return;
      nameEl.textContent = `ğŸ”Š ${ch?.name || 'voice'}`;
      const rows = Object.values(voiceMembers).map((m) => {
        const uid = m.userId || m.id;
        const live = memberUserData[uid] || {};
        const name = getUserDisplayName(live, m) || m.displayName || 'User';
        return `<div class="px-2 py-1 rounded bg-discord-darkest/40 text-sm">${escapeHtml(name)}</div>`;
      }).join('');
      membersEl.innerHTML = rows || '<div class="text-xs text-gray-500">No one in voice yet</div>';
      const joined = !!(activeVoiceChannelId && currentChannelId === activeVoiceChannelId);
      joinBtn.classList.toggle('hidden', joined);
      leaveBtn.classList.toggle('hidden', !joined);
    }

    function selectChannel(channelId) {
      const prevChannelId = currentChannelId;
      if (activeVoiceChannelId && activeVoiceChannelId !== channelId && prevChannelId === activeVoiceChannelId) {
        leaveActiveVoiceChannel().catch(() => {});
      }
      currentChannelId = channelId;
      const ch = channels[channelId];
      const isVoice = ch?.type === 'voice';
      document.getElementById('channel-header-name').textContent = ch ? `${isVoice ? 'ğŸ”Š' : '#'} ${ch.name}` : '# general';
      document.getElementById('message-input').placeholder = `Message ${isVoice ? 'voice' : '#'}${ch?.name || 'general'}`;
      document.getElementById('message-input-area').style.display = currentChannelId && !isVoice ? 'block' : 'none';
      document.getElementById('typing-indicator').classList.toggle('hidden', isVoice || Object.keys(typingUsers).length === 0);
      document.getElementById('messages-container').style.display = isVoice ? 'none' : 'flex';
      if (isVoice) {
        messages = {};
        stopVoiceMembersSubscription();
        subscribeVoiceMembers(channelId);
        renderVoicePanel();
        messageListeners.forEach(u => typeof u === 'function' && u());
        messageListeners = [];
      } else {
        stopVoiceMembersSubscription();
        renderVoicePanel();
        renderMessages();
        subscribeMessages();
        subscribeTyping();
      }
    }

    function subscribeMessages() {
      messageListeners.forEach(u => typeof u === 'function' && u());
      messageListeners = messageListeners.filter(() => false);
      if (!currentChannelId) return;
      document.getElementById('messages-loading').classList.remove('hidden');
      let initialSnapshotLoaded = false;
      const q = query(
        collection(db, 'messages'),
        where('channelId', '==', currentChannelId),
        orderBy('createdAt', 'desc'),
        limit(MESSAGE_LIMIT)
      );
      const unsub = onSnapshot(q, (snap) => {
        if (initialSnapshotLoaded) {
          snap.docChanges().forEach((change) => {
            if (change.type === 'added') {
              const data = change.doc.data();
              maybeNotifyForMessage(change.doc.id, data);
              moderateMessageIfNeeded(data);
            }
          });
        } else {
          initialSnapshotLoaded = true;
        }
        messages = {};
        snap.docs.forEach(d => { messages[d.id] = { id: d.id, ...d.data() }; });
        lastDoc = snap.docs[snap.docs.length - 1];
        document.getElementById('load-more').classList.toggle('hidden', !lastDoc || snap.docs.length < MESSAGE_LIMIT);
        renderMessages();
        document.getElementById('messages-loading').classList.add('hidden');
      }, (err) => {
        document.getElementById('messages-loading').classList.add('hidden');
        showToast(err.message || 'Failed to load messages', 'error');
      });
      messageListeners.push(unsub);
    }

    async function loadOlderMessages() {
      if (!currentChannelId || !lastDoc) return;
      const q = query(
        collection(db, 'messages'),
        where('channelId', '==', currentChannelId),
        orderBy('createdAt', 'desc'),
        startAfter(lastDoc),
        limit(MESSAGE_LIMIT)
      );
      const snap = await getDocs(q);
      snap.docs.forEach(d => { messages[d.id] = { id: d.id, ...d.data() }; });
      lastDoc = snap.docs[snap.docs.length - 1];
      document.getElementById('load-more').classList.toggle('hidden', !lastDoc || snap.docs.length < MESSAGE_LIMIT);
      renderMessages();
    }

    function renderMessages() {
      const list = document.getElementById('messages-list');
      const loadingEl = document.getElementById('messages-loading');
      list.innerHTML = '';
      if (!currentChannelId) {
        loadingEl.classList.add('hidden');
        list.innerHTML = '<div class="text-center text-gray-500 py-12">Select a channel</div>';
        return;
      }
      const arr = Object.values(messages).filter(m => m.channelId === currentChannelId).sort((a, b) => (a.createdAt?.toDate?.() || 0) - (b.createdAt?.toDate?.() || 0));
      let prevUserId = null;
      arr.forEach((m) => {
        const liveUser = memberUserData[m.userId] || {};
        const displayName = getUserDisplayName(liveUser, m) || (m.userId === BOT_USER_ID || m.isBot ? BOT_DISPLAY_NAME : 'Unknown');
        const isBot = m.userId === BOT_USER_ID || liveUser?.isBot || m.isBot;
        const avatarUrl = (liveUser.photoURL || m.photoURL || '').trim();
        const isOwn = m.userId === currentUser?.uid;
        const showAvatar = prevUserId !== m.userId || isOwn;
        prevUserId = m.userId;
        const div = document.createElement('div');
        div.className = `message-group group flex gap-4 px-4 py-1 pl-1 ${isOwn ? 'flex-row-reverse justify-end' : ''}`;
        const avatar = showAvatar ? `<div class="w-10 h-10 rounded-full bg-discord-blurple flex-shrink-0 flex items-center justify-center overflow-hidden">
          ${avatarUrl
            ? `<img src="${escapeHtml(avatarUrl)}" class="w-full h-full object-cover" alt="" onerror="this.style.display='none';this.nextElementSibling.style.display='flex'"><span class="hidden text-sm font-bold">${displayName[0].toUpperCase()}</span>`
            : `<span class="text-sm font-bold">${displayName[0].toUpperCase()}</span>`
          }
        </div>` : '<div class="w-10 flex-shrink-0"></div>';
        const time = formatTime(m.createdAt);
        const edited = m.editedAt ? ' <span class="text-xs text-gray-500">(edited)</span>' : '';
        const textBlockId = `msg-text-${m.id}`;
        const rawText = m.text || '';
        let content = `<div id="${textBlockId}" data-msgid="${m.id}">${renderMessageText(rawText, isBot)}</div>`;
        (m.attachments || []).forEach((att, index) => {
          if (!att?.url) return;
          const safeUrl = escapeHtml(att.url);
          const fileName = escapeHtml(att.name || `Attachment ${index + 1}`);
          const sizeText = formatFileSize(att.size);
          if (isImageAttachment(att)) {
            content += `<div class="mt-2">
              <a href="${safeUrl}" target="_blank" rel="noopener noreferrer">
                <img src="${safeUrl}" class="max-w-sm max-h-64 rounded cursor-pointer" alt="${fileName}">
              </a>
              <a href="${safeUrl}" target="_blank" rel="noopener noreferrer" download="${fileName}" class="text-xs text-discord-blurple hover:underline">${fileName}</a>
            </div>`;
          } else {
            content += `<div class="mt-2 max-w-sm rounded border border-discord-dark bg-discord-darkest/60 p-3">
              <div class="text-sm text-gray-200 truncate">${fileName}</div>
              <div class="text-xs text-gray-500">${sizeText || 'File'}</div>
              <a href="${safeUrl}" target="_blank" rel="noopener noreferrer" download="${fileName}" class="text-xs text-discord-blurple hover:underline">Download</a>
            </div>`;
          }
        });
        const adminDelBtn = isAdmin() ? `<button type="button" class="opacity-0 group-hover:opacity-100 ml-1 text-xs text-discord-red hover:underline transition" data-delete-msg="${m.id}" title="Delete message">Delete</button>` : '';
        const replyBtn = `<button type="button" class="opacity-0 group-hover:opacity-100 ml-1 text-xs text-discord-blurple hover:underline transition" data-reply-msg="${m.id}" title="Reply">Reply</button>`;
        const canReportUser = !isOwn && m.userId !== BOT_USER_ID;
        const reportBtn = canReportUser ? `<button type="button" class="opacity-0 group-hover:opacity-100 ml-1 text-xs text-amber-400 hover:underline transition" data-report-msg-user="${m.userId}" title="Report user">Report</button>` : '';
        const replyPreview = m.replyTo ? `<div class="mb-1 py-1 px-2 rounded border-l-2 border-discord-blurple/50 bg-discord-darkest/50 text-xs"><span class="text-discord-blurple">${escapeHtml(m.replyTo.displayName || 'Unknown')}</span><span class="text-gray-500">: </span><span class="text-gray-400 truncate">${escapeHtml((m.replyTo.text || '').slice(0, 80))}${(m.replyTo.text || '').length > 80 ? '...' : ''}</span></div>` : '';
        const botBadge = isBot ? '<span class="text-[10px] px-1.5 py-0.5 rounded bg-discord-blurple text-white font-bold align-middle">BOT</span>' : '';
        const msgContent = `<div class="flex-1 min-w-0 max-w-[75%] ${isOwn ? 'text-right' : ''}"><div class="flex items-baseline gap-2 flex-wrap ${isOwn ? 'justify-end' : ''}"><span class="font-semibold text-white">${escapeHtml(displayName)}</span>${botBadge}<span class="text-xs text-gray-500">${time}</span>${edited}${replyBtn}${reportBtn}${adminDelBtn}</div>${replyPreview}<div class="text-gray-300 break-words ${isOwn ? 'bg-discord-blurple/30 rounded-lg px-3 py-2 inline-block' : ''}">${content}</div></div>`;
        div.innerHTML = `${avatar}${msgContent}`;
        div.oncontextmenu = (e) => showMessageContextMenu(e, m, displayName, isOwn, isBot);
        list.appendChild(div);
        const delBtn = div.querySelector('[data-delete-msg]');
        if (delBtn) delBtn.onclick = () => { if (confirm('Delete this message?')) deleteAnyMessage(m.id); };
        const replyBtnEl = div.querySelector('[data-reply-msg]');
        if (replyBtnEl) replyBtnEl.onclick = () => {
          replyingTo = { id: m.id, userId: m.userId, displayName, text: (m.text || '').slice(0, 100) };
          document.getElementById('reply-preview').classList.remove('hidden');
          document.getElementById('reply-preview-name').textContent = replyingTo.displayName;
          document.getElementById('reply-preview-text').textContent = replyingTo.text || '(attachment)';
          document.getElementById('message-input').focus();
        };
        const reportBtnEl = div.querySelector('[data-report-msg-user]');
        if (reportBtnEl) reportBtnEl.onclick = () => renderReportUserModal(reportBtnEl.dataset.reportMsgUser);
      });
      list.scrollTop = list.scrollHeight;
    }

    async function sendMessage() {
      const input = document.getElementById('message-input');
      const text = input.value.trim();
      if (!currentChannelId || !currentUser?.uid) {
        showToast('Select a channel first', 'error');
        return;
      }
      if (channels[currentChannelId]?.type === 'voice') {
        showToast('Use Join Voice for voice channels', 'info');
        return;
      }
      const activeSuspension = await getActiveSuspension(currentServerId, currentUser.uid);
      if (activeSuspension) {
        showSuspensionLockModal(servers[currentServerId]?.name || 'this server', activeSuspension);
        return;
      }
      if (!text && pendingAttachments.length === 0) return;
      const botPrompt = extractBotPrompt(text);
      const continueBot = shouldAutoContinueBotConversation(text, currentChannelId);
      const shouldTalkToBot = !!botPrompt || continueBot || isBotOnlyServer();
      const botInput = botPrompt || text;
      if (messageLooksLikeTalkingToSomeoneElse(text) && !isBotOnlyServer()) {
        clearBotConversation(currentChannelId);
      }
      try {
        const expiringAttachments = pendingAttachments.filter(att => getAttachmentStoragePath(att) && Number(att.expiresAt) > 0);
        const nextAttachmentExpiry = expiringAttachments.length
          ? Math.min(...expiringAttachments.map(att => Number(att.expiresAt)))
          : null;
        const msg = {
          serverId: currentServerId,
          channelId: currentChannelId,
          userId: currentUser.uid,
          displayName: currentUser.displayName || 'User',
          photoURL: currentUser.photoURL || '',
          text: text || '',
          attachments: [...pendingAttachments],
          attachmentExpiresAt: nextAttachmentExpiry,
          replyTo: replyingTo ? { messageId: replyingTo.id, userId: replyingTo.userId, displayName: replyingTo.displayName, text: replyingTo.text } : null,
          createdAt: serverTimestamp()
        };
        await addDoc(collection(db, 'messages'), msg);
        input.value = '';
        pendingAttachments = [];
        replyingTo = null;
        document.getElementById('reply-preview').classList.add('hidden');
        document.getElementById('attachment-preview').classList.add('hidden');
        document.getElementById('attachment-preview').innerHTML = '';
        updateTyping(false);
        if (shouldTalkToBot && botInput.trim()) {
          markBotConversationActive(currentChannelId);
          await handleBotCommand(botInput, { alreadyPrompt: true, silentOnEmpty: true });
        }
      } catch (e) {
        showToast(e.message || 'Failed to send message', 'error');
        console.error('Send error:', e);
      }
    }

    let typingTimeout;
    async function updateTyping(typing) {
      if (!currentChannelId || !currentUser?.uid) return;
      try {
        const refPath = doc(db, 'channels', currentChannelId, 'typing', currentUser.uid);
        if (typing) {
          await setDoc(refPath, { userId: currentUser.uid, displayName: currentUser.displayName, at: serverTimestamp() });
          clearTimeout(typingTimeout);
          typingTimeout = setTimeout(() => updateTyping(false), 5000);
        } else {
          await deleteDoc(refPath);
        }
      } catch (_) {}
    }

    function subscribeTyping() {
      if (!currentChannelId) return;
      const unsub = onSnapshot(collection(db, 'channels', currentChannelId, 'typing'), (snap) => {
        typingUsers = {};
        snap.docs.forEach(d => {
          const d_ = d.data();
          if (d_.userId !== currentUser?.uid) typingUsers[d_.userId] = d_.displayName;
        });
        const names = Object.values(typingUsers);
        const el = document.getElementById('typing-indicator');
        el.classList.toggle('hidden', names.length === 0);
        document.getElementById('typing-users').textContent = names.length ? `${names.slice(0, 2).join(', ')}${names.length > 2 ? ' and others' : ''} typing` : '';
      });
      messageListeners.push(unsub);
    }

    async function createInvite() {
      if (!currentServerId || !currentUser?.uid) {
        showToast('Select a server first', 'error');
        return;
      }
      if (isBotOnlyServer()) {
        showToast('Invites are disabled for Bot Chat servers', 'error');
        return;
      }
      const code = Math.random().toString(36).slice(2, 10).toUpperCase();
      try {
        await addDoc(collection(db, 'invites'), {
          serverId: currentServerId,
          code,
          createdBy: currentUser.uid,
          uses: 0,
          maxUses: null,
          expireAt: null
        });
        modal.open('Invite Link', `
          <p class="text-gray-300 mb-4">Share this code to invite people:</p>
          <p class="text-2xl font-mono bg-discord-dark p-4 rounded text-center">${code}</p>
          <p class="text-sm text-gray-500 mt-2">Or share: ${window.location.origin}${window.location.pathname}?invite=${code}</p>
        `);
      } catch (e) { showToast(e.message, 'error'); }
    }

    function renderJoinModal() {
      const needLogin = !currentUser?.uid;
      modal.open('Join Server', `
        ${needLogin ? '<p class="text-amber-400 text-sm mb-4">Log in or create an account first to join a server.</p>' : ''}
        <form id="join-form" class="space-y-4">
          <div>
            <label class="block text-sm text-gray-400 mb-1">Invite Code</label>
            <input type="text" id="invite-code" placeholder="e.g. ABC123XY" class="w-full bg-discord-dark border border-discord-darkest rounded px-3 py-2 outline-none focus:border-discord-blurple uppercase">
          </div>
          <button type="submit" class="w-full py-2 bg-discord-blurple hover:bg-indigo-600 rounded font-medium">Join</button>
          ${needLogin ? '<button type="button" id="join-login-btn" class="w-full py-2 bg-discord-dark hover:bg-discord-darker rounded font-medium mt-2">Log In</button>' : ''}
        </form>
      `);
      document.getElementById('join-form').onsubmit = (e) => {
        e.preventDefault();
        if (needLogin) { showToast('Please log in first', 'error'); modal.closeModal(); renderLoginModal(); return; }
        joinServerByCode(document.getElementById('invite-code').value);
      };
      const params = new URLSearchParams(location.search);
      const invite = params.get('invite');
      if (invite) document.getElementById('invite-code').value = invite;
      const loginBtn = document.getElementById('join-login-btn');
      if (loginBtn) loginBtn.onclick = () => { modal.closeModal(); renderLoginModal(); };
    }

    async function banUser(userId) {
      if (!currentServerId || !isAdmin()) return;
      const srv = servers[currentServerId];
      if (srv?.ownerId === userId) { showToast('Cannot ban server owner', 'error'); return; }
      const mem = Object.values(members).find(m => m.serverId === currentServerId && m.userId === userId);
      if (!mem) return;
      try {
        await setDoc(doc(db, 'servers', currentServerId, 'banned', userId), { bannedBy: currentUser.uid, bannedAt: serverTimestamp() });
        await deleteDoc(doc(db, 'servers', currentServerId, 'members', userId));
        await deleteDoc(doc(db, 'memberships', mem.id));
        showToast('User banned', 'success');
        loadMembers();
        modal.closeModal();
      } catch (e) { showToast(e.message, 'error'); }
    }

    async function kickUser(userId) {
      if (!currentServerId || !isAdmin()) return;
      const srv = servers[currentServerId];
      if (srv?.ownerId === userId) { showToast('Cannot kick server owner', 'error'); return; }
      const mem = Object.values(members).find(m => m.serverId === currentServerId && m.userId === userId);
      if (!mem) return;
      try {
        await deleteDoc(doc(db, 'servers', currentServerId, 'members', mem.userId));
        await deleteDoc(doc(db, 'memberships', mem.id));
        await ensureUserPublicMembership(userId);
        showToast('User kicked', 'success');
        loadMembers();
        modal.closeModal();
      } catch (e) { showToast(e.message, 'error'); }
    }

    function updateServerActionButtons() {
      const inviteBtn = document.getElementById('btn-invite');
      if (!inviteBtn) return;
      const botOnly = isBotOnlyServer();
      inviteBtn.disabled = botOnly;
      inviteBtn.title = botOnly ? 'Disabled for Bot Chat server' : 'Invite';
      inviteBtn.classList.toggle('opacity-50', botOnly);
      inviteBtn.classList.toggle('cursor-not-allowed', botOnly);
    }

    async function suspendUser(userId, durationMs, reason = '') {
      if (!currentServerId || !isAdmin()) return;
      if (!durationMs || durationMs <= 0) { showToast('Set a valid suspension duration', 'error'); return; }
      const srv = servers[currentServerId];
      if (srv?.ownerId === userId) { showToast('Cannot suspend server owner', 'error'); return; }
      if (userId === BOT_USER_ID) { showToast('Cannot suspend bot account', 'error'); return; }
      const mem = Object.values(members).find(m => m.serverId === currentServerId && m.userId === userId);
      if (!mem) { showToast('User is not in this server', 'error'); return; }
      const untilMs = Date.now() + durationMs;
      try {
        await setDoc(doc(db, 'servers', currentServerId, 'suspended', userId), {
          userId,
          reason: (reason || '').trim().slice(0, 200),
          suspendedBy: currentUser.uid,
          suspendedAt: serverTimestamp(),
          untilMs
        }, { merge: true });
        showToast('User suspended', 'success');
      } catch (e) {
        showToast(e.message || 'Failed to suspend user', 'error');
      }
    }

    function renderSuspendUserModal(userId) {
      if (!currentServerId || !isAdmin()) return;
      const mem = Object.values(members).find(m => m.serverId === currentServerId && m.userId === userId);
      const ud = memberUserData[userId] || {};
      const displayName = getUserDisplayName(ud, mem) || 'Unknown';
      modal.open('Suspend User', `
        <form id="suspend-user-form" class="space-y-4">
          <p class="text-sm text-gray-300">Suspend <span class="text-white font-medium">${escapeHtml(displayName)}</span> from this server.</p>
          <div class="flex items-center gap-2">
            <input id="suspend-duration-value" type="number" min="1" value="1" class="w-24 bg-discord-dark border border-discord-darkest rounded px-3 py-2 outline-none focus:border-discord-blurple">
            <select id="suspend-duration-unit" class="bg-discord-dark border border-discord-darkest rounded px-3 py-2 outline-none focus:border-discord-blurple">
              <option value="hours">hours</option>
              <option value="minutes">minutes</option>
              <option value="days">days</option>
            </select>
          </div>
          <div>
            <label class="block text-sm text-gray-400 mb-1">Reason (optional)</label>
            <textarea id="suspend-reason" rows="3" maxlength="200" placeholder="Why is this user suspended?" class="w-full bg-discord-dark border border-discord-darkest rounded px-3 py-2 outline-none focus:border-discord-blurple resize-none"></textarea>
          </div>
          <button type="submit" class="w-full py-2 rounded bg-amber-700 hover:bg-amber-600 font-medium">Apply Suspension</button>
        </form>
      `);
      document.getElementById('suspend-user-form').onsubmit = async (e) => {
        e.preventDefault();
        const value = document.getElementById('suspend-duration-value').value;
        const unit = document.getElementById('suspend-duration-unit').value;
        const reason = document.getElementById('suspend-reason').value;
        const durationMs = getDurationMs(value, unit);
        await suspendUser(userId, durationMs, reason);
        modal.closeModal();
        renderAdminModal();
      };
    }

    async function makeAdmin(userId) {
      if (!currentServerId || !currentUser?.uid) return;
      const srv = servers[currentServerId];
      if (srv?.ownerId !== currentUser.uid) { showToast('Only owner can make admins', 'error'); return; }
      const mem = Object.values(members).find(m => m.serverId === currentServerId && m.userId === userId);
      if (!mem) return;
      try {
        await updateDoc(doc(db, 'memberships', mem.id), { role: 'admin' });
        await setDoc(doc(db, 'servers', currentServerId, 'members', userId), { role: 'admin' }, { merge: true });
        members[mem.id].role = 'admin';
        showToast('User is now admin', 'success');
        loadMembers();
        renderAdminModal();
      } catch (e) { showToast(e.message, 'error'); }
    }

    async function removeAdmin(userId) {
      if (!currentServerId || !currentUser?.uid) return;
      const srv = servers[currentServerId];
      if (srv?.ownerId !== currentUser.uid) { showToast('Only owner can remove admins', 'error'); return; }
      const mem = Object.values(members).find(m => m.serverId === currentServerId && m.userId === userId);
      if (!mem) return;
      try {
        await updateDoc(doc(db, 'memberships', mem.id), { role: 'member' });
        await setDoc(doc(db, 'servers', currentServerId, 'members', userId), { role: 'member' }, { merge: true });
        members[mem.id].role = 'member';
        showToast('Admin removed', 'success');
        loadMembers();
        renderAdminModal();
      } catch (e) { showToast(e.message, 'error'); }
    }

    async function deleteAnyMessage(msgId) {
      const data = messages[msgId];
      const isOwnMessage = data?.userId === currentUser?.uid;
      if (!isAdmin() && !isOwnMessage) return;
      try {
        const result = await deleteMessageWithAttachments(msgId);
        showToast(`Message deleted (${result.filesDeleted} file(s) removed)`, 'success');
      } catch (e) { showToast(e.message, 'error'); }
    }

    function renderAdminModal() {
      if (!isAdmin()) return;
      const srv = servers[currentServerId];
      const isOwner = srv?.ownerId === currentUser?.uid;
      const memberRows = Object.values(members).filter(m => m.serverId === currentServerId).map(m => {
        const ud = memberUserData[m.userId] || {};
        const displayName = getUserDisplayName(ud, m) || 'Unknown';
        const isOwnerMember = m.userId === srv?.ownerId;
        const canMod = !isOwnerMember && (isOwner || (m.role !== 'owner' && m.role !== 'admin'));
        const roleLabel = isOwnerMember ? 'Owner' : m.role === 'admin' ? 'Admin' : 'Member';
        return `
          <div class="flex items-center justify-between py-2 border-b border-discord-dark">
            <div class="flex items-center gap-2">
              <div class="w-8 h-8 rounded-full bg-discord-blurple flex items-center justify-center overflow-hidden">
                <img src="${ud.photoURL || ''}" class="w-full h-full object-cover" alt="" onerror="this.style.display='none';this.nextElementSibling.style.display='flex'">
                <span class="hidden text-xs font-bold">${displayName[0].toUpperCase()}</span>
              </div>
              <div>
                <span class="font-medium">${escapeHtml(displayName)}</span>
                <span class="text-xs text-gray-500 ml-2">${roleLabel}</span>
              </div>
            </div>
            ${canMod ? `
              <div class="flex gap-1">
                ${isOwner && m.role !== 'admin' ? `<button type="button" class="text-xs px-2 py-1 rounded bg-discord-blurple hover:bg-indigo-600" data-make-admin="${m.userId}">Make Admin</button>` : ''}
                ${isOwner && m.role === 'admin' ? `<button type="button" class="text-xs px-2 py-1 rounded bg-discord-dark hover:bg-discord-red" data-remove-admin="${m.userId}">Remove Admin</button>` : ''}
                <button type="button" class="text-xs px-2 py-1 rounded bg-discord-dark hover:bg-amber-600" data-suspend="${m.userId}">Suspend</button>
                <button type="button" class="text-xs px-2 py-1 rounded bg-discord-dark hover:bg-amber-600" data-kick="${m.userId}">Kick</button>
                <button type="button" class="text-xs px-2 py-1 rounded bg-discord-dark hover:bg-discord-red" data-delete-account="${m.userId}">Delete Account</button>
              </div>
            ` : ''}
          </div>
        `;
      }).join('');
      const channelRows = Object.values(channels).filter(c => c.serverId === currentServerId).map(ch => `
        <div class="flex items-center justify-between py-2 border-b border-discord-dark">
          <span class="text-gray-300"># ${escapeHtml(ch.name)}</span>
          <button type="button" class="text-xs px-2 py-1 rounded bg-discord-dark hover:bg-discord-red" data-delete-channel="${ch.id}">Delete</button>
        </div>
      `).join('');
      modal.open('Server Admin', `
        <div class="space-y-6">
          <div>
            <h3 class="text-sm font-semibold text-gray-400 mb-2">Manage Members</h3>
            <div class="max-h-48 overflow-y-auto space-y-0">${memberRows || '<p class="text-gray-500 py-2">No members</p>'}</div>
          </div>
          <div>
            <h3 class="text-sm font-semibold text-gray-400 mb-2">Channels</h3>
            <div class="space-y-0">${channelRows || '<p class="text-gray-500 py-2">No channels</p>'}</div>
            <button type="button" id="admin-create-channel" class="mt-2 text-sm px-3 py-1.5 rounded bg-discord-blurple hover:bg-indigo-600">+ Create Channel</button>
          </div>
          <div>
            <h3 class="text-sm font-semibold text-gray-400 mb-2">Banned Account List</h3>
            <div class="flex gap-2 mb-2">
              <input id="admin-ban-name-input" type="text" placeholder="Username to block" class="flex-1 bg-discord-dark border border-discord-darkest rounded px-2 py-1.5 text-sm outline-none focus:border-discord-blurple">
              <button type="button" id="admin-ban-name-add" class="text-xs px-3 py-1.5 rounded bg-discord-red hover:bg-red-500">Block</button>
            </div>
            <div id="admin-ban-name-list" class="max-h-40 overflow-y-auto space-y-1"></div>
          </div>
          <div>
            <h3 class="text-sm font-semibold text-gray-400 mb-2">Reports Inbox</h3>
            <div id="admin-reports-inbox" class="max-h-60 overflow-y-auto space-y-2"><p class="text-gray-500 py-2">Loading reports...</p></div>
          </div>
          ${isOwner ? `
            <div>
              <h3 class="text-sm font-semibold text-gray-400 mb-2">Message Cleanup (Owner)</h3>
              <div class="space-y-3 rounded border border-discord-dark bg-discord-darkest/40 p-3">
                <div class="flex flex-wrap items-center gap-2">
                  <select id="admin-cleanup-scope" class="bg-discord-dark border border-discord-darkest rounded px-2 py-1 text-sm">
                    <option value="channel">Current Channel</option>
                    <option value="server">Whole Server</option>
                  </select>
                  <input id="admin-cleanup-age-value" type="number" min="1" value="24" class="w-20 bg-discord-dark border border-discord-darkest rounded px-2 py-1 text-sm">
                  <select id="admin-cleanup-age-unit" class="bg-discord-dark border border-discord-darkest rounded px-2 py-1 text-sm">
                    <option value="hours">hours</option>
                    <option value="minutes">minutes</option>
                    <option value="days">days</option>
                  </select>
                </div>
                <div class="flex flex-wrap gap-2">
                  <button type="button" id="admin-delete-older" class="text-xs px-3 py-1.5 rounded bg-amber-700 hover:bg-amber-600">Delete Older Than</button>
                  <button type="button" id="admin-reset-messages" class="text-xs px-3 py-1.5 rounded bg-discord-red hover:bg-red-500">Reset Messages</button>
                  <button type="button" id="admin-clean-expired-files" class="text-xs px-3 py-1.5 rounded bg-discord-dark hover:bg-discord-darker">Delete Expired Files Now</button>
                </div>
              </div>
            </div>
            <div>
              <h3 class="text-sm font-semibold text-gray-400 mb-2">Danger Zone</h3>
              <div class="rounded border border-discord-red/50 bg-discord-darkest/40 p-3">
                <p class="text-xs text-gray-400 mb-2">Delete this server and all messages, channels, reports, invites, memberships, and member records.</p>
                <button type="button" id="admin-delete-server" class="text-xs px-3 py-1.5 rounded bg-discord-red hover:bg-red-500">Delete Server Permanently</button>
              </div>
            </div>
          ` : ''}
        </div>
      `);
      document.querySelectorAll('[data-kick]').forEach(btn => btn.onclick = () => kickUser(btn.dataset.kick));
      document.querySelectorAll('[data-suspend]').forEach(btn => btn.onclick = () => renderSuspendUserModal(btn.dataset.suspend));
      document.querySelectorAll('[data-make-admin]').forEach(btn => btn.onclick = () => makeAdmin(btn.dataset.makeAdmin));
      document.querySelectorAll('[data-remove-admin]').forEach(btn => btn.onclick = () => removeAdmin(btn.dataset.removeAdmin));
      document.querySelectorAll('[data-delete-account]').forEach(btn => btn.onclick = async () => {
        const targetId = btn.dataset.deleteAccount || '';
        if (!targetId) return;
        if (!confirm('Delete this account data now and block this username from this server?')) return;
        await adminDeleteAccountNow(targetId);
      });
      document.querySelectorAll('[data-delete-channel]').forEach(btn => btn.onclick = () => {
        if (confirm('Delete this channel?')) deleteChannel(btn.dataset.deleteChannel);
      });
      document.getElementById('admin-create-channel').onclick = () => { modal.closeModal(); renderCreateChannelModal(); };
      const addBlockedNameBtn = document.getElementById('admin-ban-name-add');
      if (addBlockedNameBtn) {
        addBlockedNameBtn.onclick = async () => {
          const input = document.getElementById('admin-ban-name-input');
          const raw = String(input?.value || '').trim();
          if (!raw) return;
          if (!currentServerId || !isAdmin()) return;
          try {
            await addServerBannedAccountName(currentServerId, raw, 'Added by admin list');
            showToast('Name blocked for this server', 'success');
            input.value = '';
          } catch (err) {
            showToast(err?.message || 'Failed to block name', 'error');
          }
        };
      }
      renderAdminBannedAccountList();
      fetchOpenReportsForCurrentServer()
        .then(() => renderAdminReportsInbox())
        .catch(() => {
          const host = document.getElementById('admin-reports-inbox');
          if (host) host.innerHTML = '<p class="text-discord-red text-sm py-2">Failed to load reports</p>';
        });
      if (isOwner) {
        document.getElementById('admin-delete-server').onclick = async () => {
          const serverName = servers[currentServerId]?.name || 'this server';
          if (!confirm(`Delete "${serverName}" permanently? This cannot be undone.`)) return;
          if (!confirm('Final confirmation: this removes all server data forever.')) return;
          await deleteServerPermanently(currentServerId);
        };
        document.getElementById('admin-delete-older').onclick = async () => {
          const scope = document.getElementById('admin-cleanup-scope').value;
          const ageValue = document.getElementById('admin-cleanup-age-value').value;
          const ageUnit = document.getElementById('admin-cleanup-age-unit').value;
          const olderThanMs = getDurationMs(ageValue, ageUnit);
          if (!olderThanMs) { showToast('Enter a valid age value', 'error'); return; }
          if (scope === 'channel' && !currentChannelId) { showToast('Select a channel first', 'error'); return; }
          const targetText = scope === 'server' ? 'entire server' : 'current channel';
          if (!confirm(`Delete messages older than ${ageValue} ${ageUnit} in ${targetText}?`)) return;
          try {
            const result = await deleteMessagesByFilter({
              channelId: scope === 'channel' ? currentChannelId : null,
              olderThanMs
            });
            showToast(`Deleted ${result.deleted} message(s), removed ${result.filesDeleted} file(s)`, 'success');
          } catch (err) {
            showToast(err?.message || 'Cleanup failed', 'error');
          }
        };
        document.getElementById('admin-reset-messages').onclick = async () => {
          const scope = document.getElementById('admin-cleanup-scope').value;
          if (scope === 'channel' && !currentChannelId) { showToast('Select a channel first', 'error'); return; }
          const targetText = scope === 'server' ? 'entire server' : 'current channel';
          if (!confirm(`Reset all messages in ${targetText}? This cannot be undone.`)) return;
          try {
            const result = await deleteMessagesByFilter({
              channelId: scope === 'channel' ? currentChannelId : null,
              olderThanMs: null
            });
            showToast(`Reset complete: ${result.deleted} message(s), ${result.filesDeleted} file(s) removed`, 'success');
            modal.closeModal();
          } catch (err) {
            showToast(err?.message || 'Reset failed', 'error');
          }
        };
        document.getElementById('admin-clean-expired-files').onclick = async () => {
          try {
            const result = await cleanupExpiredAttachments({ serverScoped: true });
            showToast(`Expired cleanup: ${result.messagesUpdated} message(s), ${result.filesDeleted} file(s)`, 'info');
          } catch (err) {
            showToast(err?.message || 'Expired cleanup failed', 'error');
          }
        };
      }
    }

    function updateAdminButtonVisibility() {
      const btn = document.getElementById('btn-admin-menu');
      if (!btn) return;
      if (isAdmin()) { btn.classList.remove('hidden'); btn.onclick = renderAdminModal; }
      else { btn.classList.add('hidden'); }
      subscribeReports();
    }

    async function loadMembers() {
      if (!currentServerId) return;
      const serverId = currentServerId;
      const loadVersion = ++membersLoadVersion;
      if (unsubMembers) { unsubMembers(); unsubMembers = null; }
      if (unsubReports) { unsubReports(); unsubReports = null; }
      stopServerBannedAccountsWatcher();
      reportAlertInitialized = false;
      clearMemberUserListeners();
      members = {};
      memberUserData = {};
      userPresence = {};
      renderMembers();
      updateAdminButtonVisibility();
      subscribeServerBannedAccounts(serverId);
      const q = query(collection(db, 'memberships'), where('serverId', '==', serverId));
      unsubMembers = onSnapshot(q, (snap) => {
        if (loadVersion !== membersLoadVersion || serverId !== currentServerId) return;
        const nextMembers = {};
        snap.docs.forEach(d => { nextMembers[d.id] = { id: d.id, ...d.data() }; });
        members = nextMembers;
        const userIds = [...new Set(Object.values(nextMembers).map(m => m.userId))];
        const userIdSet = new Set(userIds);
        Object.keys(memberUserUnsubs).forEach((uid) => {
          if (!userIdSet.has(uid)) {
            memberUserUnsubs[uid]();
            delete memberUserUnsubs[uid];
            delete memberUserData[uid];
            delete userPresence[uid];
          }
        });
        userIds.forEach((uid) => {
          if (memberUserUnsubs[uid]) return;
          memberUserUnsubs[uid] = onSnapshot(doc(db, 'users', uid), (u) => {
            if (loadVersion !== membersLoadVersion || serverId !== currentServerId) return;
            if (u.exists()) {
              const data = u.data();
              memberUserData[uid] = data;
              userPresence[uid] = data.status || 'offline';
            } else {
              delete memberUserData[uid];
              delete userPresence[uid];
            }
            renderMembers();
            renderMessages();
            if (activeMemberProfileUserId === uid) renderMemberProfileModal(uid);
            updateAdminButtonVisibility();
          });
        });
        renderMembers();
        updateAdminButtonVisibility();
      }, (err) => {
        if (loadVersion !== membersLoadVersion || serverId !== currentServerId) return;
        showToast(err.message || 'Failed to load members', 'error');
      });
    }

    function renderMemberProfileModal(userId) {
      activeMemberProfileUserId = userId;
      const memberData = memberUserData[userId] || {};
      const memberRole = Object.values(members).find(m => m.serverId === currentServerId && m.userId === userId);
      const isBotProfile = userId === BOT_USER_ID || memberData?.isBot || memberRole?.role === 'bot';
      const name = getUserDisplayName(memberData, memberRole) || (isBotProfile ? BOT_DISPLAY_NAME : 'Unknown');
      const bio = isBotProfile
        ? (memberData?.bio || 'Server assistant bot. Mention bot/ai/mistral or use /help for supported commands.')
        : (memberData?.bio || '').trim();
      const role = isBotProfile ? 'Bot' : (servers[currentServerId]?.ownerId === userId ? 'Owner' : memberRole?.role === 'admin' ? 'Admin' : 'Member');
      const canReport = !!currentUser?.uid && userId !== currentUser.uid && userId !== BOT_USER_ID;
      modal.open('Member Profile', `
        <div class="space-y-4">
          <div class="flex items-center gap-3">
            <div class="w-14 h-14 rounded-full bg-discord-blurple flex items-center justify-center overflow-hidden">
              <img src="${memberData.photoURL || ''}" class="w-full h-full object-cover" alt="" onerror="this.style.display='none';this.nextElementSibling.style.display='flex'">
              <span class="hidden text-lg font-bold">${name[0].toUpperCase()}</span>
            </div>
            <div>
              <div class="text-lg font-semibold text-white">${escapeHtml(name)}</div>
              <div class="text-xs text-gray-500">${role}</div>
            </div>
          </div>
          <div>
            <div class="text-xs uppercase tracking-wide text-gray-500 mb-1">About</div>
            <div class="text-sm text-gray-300 bg-discord-dark rounded p-3">${escapeHtml(bio || 'No description set.')}</div>
          </div>
          ${isBotProfile ? `<div>
            <div class="text-xs uppercase tracking-wide text-gray-500 mb-1">Supported Commands</div>
            <div class="text-xs text-gray-300 bg-discord-dark rounded p-3">${BOT_COMMAND_HELP.map(c => escapeHtml(c)).join('<br>')}</div>
          </div>` : ''}
          ${canReport ? '<button type="button" id="profile-report-user" class="w-full py-2 rounded bg-discord-red hover:bg-red-500 text-sm font-medium">Report User</button>' : ''}
        </div>
      `);
      const reportBtn = document.getElementById('profile-report-user');
      if (reportBtn) reportBtn.onclick = () => renderReportUserModal(userId);
    }

    function renderMembers() {
      const el = document.getElementById('members-list');
      el.innerHTML = '';
      const srv = servers[currentServerId];
      Object.values(members)
        .filter(m => m.serverId === currentServerId && m.userId !== currentUser?.uid)
        .forEach(m => {
          const ud = memberUserData[m.userId] || {};
          const status = getEffectivePresenceStatus(m.userId);
          const isBotMember = m.userId === BOT_USER_ID || ud?.isBot || m.role === 'bot';
          const displayName = getUserDisplayName(ud, m) || (isBotMember ? BOT_DISPLAY_NAME : 'Unknown');
          const roleLabel = isBotMember ? ' (Bot)' : (srv?.ownerId === m.userId ? ' (Owner)' : m.role === 'admin' ? ' (Admin)' : '');
          const div = document.createElement('div');
          div.className = 'flex items-center gap-2 px-2 py-1.5 rounded hover:bg-discord-dark cursor-pointer';
          div.innerHTML = `
            <div class="relative">
              <div class="w-8 h-8 rounded-full bg-discord-blurple flex items-center justify-center overflow-hidden">
                <img src="${ud.photoURL || ''}" class="w-full h-full object-cover" alt="" onerror="this.style.display='none';this.nextElementSibling.style.display='flex'">
                <span class="hidden text-xs font-bold">${(displayName || '?')[0].toUpperCase()}</span>
              </div>
              <span class="absolute bottom-0 right-0 w-2.5 h-2.5 rounded-full border-2 border-discord-darker ${status === 'online' ? 'bg-discord-green' : status === 'idle' ? 'bg-discord-yellow' : 'bg-gray-500'}"></span>
            </div>
            <span class="text-sm truncate">${escapeHtml(displayName)}<span class="text-gray-500 text-xs">${roleLabel}</span></span>
          `;
          div.onclick = () => renderMemberProfileModal(m.userId);
          el.appendChild(div);
        });
    }

    // ========== GIPHY API (replaces Tenor) ==========
    async function fetchGiphyGifs(term = '', limit = 24) {
      const url = term
        ? `https://api.giphy.com/v1/gifs/search?api_key=${GIPHY_API_KEY}&q=${encodeURIComponent(term)}&limit=${limit}&rating=g`
        : `https://api.giphy.com/v1/gifs/trending?api_key=${GIPHY_API_KEY}&limit=${limit}&rating=g`;
      const res = await fetch(url);
      const data = await res.json();
      if (data.meta?.status !== 200) throw new Error(data.meta?.msg || 'Giphy API error');
      return (data.data || []).map(g => ({
        id: g.id,
        url: g.images?.original?.url || g.images?.fixed_height?.url || '',
        preview: g.images?.fixed_height_small?.url || g.images?.fixed_height?.url || g.images?.original?.url || ''
      })).filter(x => x.url);
    }

    const debouncedGifSearch = debounce(async (term) => {
      const container = document.getElementById('gif-results');
      container.innerHTML = '<div class="flex justify-center py-8"><div class="animate-spin w-8 h-8 border-2 border-discord-blurple border-t-transparent rounded-full"></div></div>';
      try {
        const gifs = await fetchGiphyGifs(term, 24);
        container.innerHTML = '';
        const grid = document.createElement('div');
        grid.className = 'gif-grid max-h-64 overflow-y-auto';
        gifs.forEach(g => {
          const img = document.createElement('img');
          img.src = g.preview;
          img.className = 'w-full h-20 object-cover rounded cursor-pointer hover:opacity-80';
          img.onclick = () => selectGif(g);
          grid.appendChild(img);
        });
        container.appendChild(grid);
      } catch (e) {
        container.innerHTML = '<p class="text-discord-red text-sm">Failed to load GIFs. Check Giphy API key.</p>';
      }
    }, 300);

    function selectGif(gif) {
      pendingAttachments.push({ type: 'image', url: gif.url });
      const prev = document.getElementById('attachment-preview');
      prev.classList.remove('hidden');
      const wrap = document.createElement('div');
      wrap.className = 'flex items-center gap-1';
      wrap.innerHTML = `<img src="${gif.url}" class="w-12 h-12 object-cover rounded" alt=""><button type="button" class="text-discord-red text-xs" data-remove>âœ•</button>`;
      wrap.querySelector('[data-remove]').onclick = () => {
        pendingAttachments = pendingAttachments.filter(a => a.url !== gif.url);
        wrap.remove();
        if (pendingAttachments.length === 0) prev.classList.add('hidden');
      };
      prev.appendChild(wrap);
      modal.closeModal();
    }

    function renderGifModal() {
      modal.open('Search GIFs (Giphy)', `
        <div class="space-y-4">
          <input type="text" id="gif-search" placeholder="Search GIFs..." class="w-full bg-discord-dark border border-discord-darkest rounded px-3 py-2 outline-none focus:border-discord-blurple">
          <div id="gif-results" class="min-h-[200px]"></div>
        </div>
      `);
      document.getElementById('gif-search').oninput = (e) => debouncedGifSearch(e.target.value);
      debouncedGifSearch('');
    }

    function renderEmojiModal() {
      let html = '<div class="space-y-4"><input type="text" id="emoji-search" placeholder="Search emoji..." class="w-full bg-discord-dark border rounded px-3 py-2 outline-none"><div id="emoji-categories" class="max-h-48 overflow-y-auto scrollbar-thin">';
      Object.entries(EMOJI_CATEGORIES).forEach(([cat, emojis]) => {
        html += `<div class="mb-2"><div class="text-xs text-gray-500 mb-1">${cat}</div><div class="flex flex-wrap gap-1">`;
        emojis.forEach(e => { html += `<button type="button" class="text-2xl hover:bg-discord-dark rounded p-1 emoji-btn" data-emoji="${e}">${e}</button>`; });
        html += '</div></div>';
      });
      html += '</div></div>';
      modal.open('Pick Emoji', html);
      document.querySelectorAll('.emoji-btn').forEach(btn => {
        btn.onclick = () => {
          const inp = document.getElementById('message-input');
          inp.value += btn.dataset.emoji;
          inp.focus();
          modal.closeModal();
        };
      });
      document.getElementById('emoji-search').oninput = (e) => {
        const v = e.target.value.toLowerCase();
        document.querySelectorAll('.emoji-btn').forEach(b => {
          b.style.display = !v || b.dataset.emoji.includes(v) ? '' : 'none';
        });
      };
    }

    function renderCreateServerModal() {
      modal.open('Create Server', `
        <form id="create-server-form" class="space-y-4">
          <div>
            <label class="block text-sm text-gray-400 mb-1">Server Name</label>
            <input type="text" id="server-name" placeholder="My Server" class="w-full bg-discord-dark border border-discord-darkest rounded px-3 py-2 outline-none focus:border-discord-blurple">
          </div>
          <label class="flex items-center gap-2 text-sm text-gray-300">
            <input type="checkbox" id="server-bot-chat" class="accent-discord-blurple">
            Create as private Bot Chat (you + bot only, no invites)
          </label>
          <div>
            <label class="block text-sm text-gray-400 mb-1">Server Icon (optional)</label>
            <label for="server-icon" class="inline-block px-4 py-2 rounded bg-discord-dark hover:bg-discord-blurple text-gray-300 hover:text-white text-sm font-medium cursor-pointer transition border border-discord-darkest">Choose Image</label>
            <input type="file" id="server-icon" accept="image/*" class="hidden">
          </div>
          <button type="submit" class="w-full py-2 bg-discord-blurple hover:bg-indigo-600 rounded font-medium">Create</button>
        </form>
      `);
      document.getElementById('server-bot-chat').onchange = (e) => {
        const checked = !!e.target.checked;
        const iconInput = document.getElementById('server-icon');
        if (iconInput && checked) iconInput.value = '';
      };
      document.getElementById('create-server-form').onsubmit = (e) => {
        e.preventDefault();
        createServer(
          document.getElementById('server-name').value,
          document.getElementById('server-icon').files?.[0],
          { botChat: !!document.getElementById('server-bot-chat')?.checked }
        );
      };
    }

    function renderCreateChannelModal() {
      modal.open('Create Channel', `
        <form id="create-channel-form" class="space-y-4">
          <div>
            <label class="block text-sm text-gray-400 mb-1">Channel Name</label>
            <input type="text" id="channel-name" placeholder="new-channel" class="w-full bg-discord-dark border border-discord-darkest rounded px-3 py-2 outline-none focus:border-discord-blurple">
          </div>
          <div>
            <label class="block text-sm text-gray-400 mb-1">Channel Type</label>
            <select id="channel-type" class="w-full bg-discord-dark border border-discord-darkest rounded px-3 py-2 outline-none focus:border-discord-blurple">
              <option value="text">Text</option>
              <option value="voice">Voice</option>
            </select>
          </div>
          <button type="submit" class="w-full py-2 bg-discord-blurple hover:bg-indigo-600 rounded font-medium">Create</button>
        </form>
      `);
      document.getElementById('create-channel-form').onsubmit = (e) => {
        e.preventDefault();
        const name = document.getElementById('channel-name').value.replace(/\s/g, '-').toLowerCase() || 'new-channel';
        const type = document.getElementById('channel-type').value === 'voice' ? 'voice' : 'text';
        createChannel(name, type);
      };
    }

    function updateUserPill() {
      const name = currentUser?.displayName || 'User';
      document.getElementById('user-display-name').textContent = name;
      document.getElementById('user-initial').textContent = name[0].toUpperCase();
      const img = document.getElementById('user-avatar');
      if (currentUser?.photoURL) { img.src = currentUser.photoURL; img.style.display = 'block'; document.getElementById('user-initial').style.display = 'none'; }
      else { img.style.display = 'none'; document.getElementById('user-initial').style.display = 'flex'; }
    }

    document.getElementById('user-pill').onclick = () => renderProfileModal();

    document.getElementById('btn-login').onclick = renderLoginModal;
    document.getElementById('btn-signup').onclick = renderSignupModal;
    document.getElementById('btn-join-invite').onclick = renderJoinModal;
    document.getElementById('btn-join-server').onclick = renderJoinModal;
    document.getElementById('btn-add-server').onclick = renderCreateServerModal;
    document.getElementById('btn-invite').onclick = createInvite;
    document.getElementById('btn-leave-server').onclick = leaveServer;
    document.getElementById('btn-add-channel').onclick = renderCreateChannelModal;
    document.getElementById('btn-emoji').onclick = renderEmojiModal;
    document.getElementById('btn-gif').onclick = renderGifModal;
    document.getElementById('btn-send').onclick = sendMessage;
    document.getElementById('btn-voice-join').onclick = () => joinVoiceChannel(currentChannelId);
    document.getElementById('btn-voice-leave').onclick = () => leaveActiveVoiceChannel();
    document.getElementById('btn-load-more').onclick = loadOlderMessages;
    document.getElementById('btn-members-toggle').onclick = () => document.getElementById('members-sidebar').classList.toggle('hidden');
    document.getElementById('btn-toggle-channel').onclick = () => document.getElementById('channel-sidebar').classList.toggle('hidden');
    document.addEventListener('click', () => hideContextMenu());
    document.addEventListener('contextmenu', (e) => {
      if (!e.target.closest('.message-group')) hideContextMenu();
    });
    window.addEventListener('resize', hideContextMenu);
    document.getElementById('messages-container').addEventListener('scroll', hideContextMenu);
    document.addEventListener('visibilitychange', () => {
      if (!currentUser?.uid) return;
      updatePresence(document.hidden ? 'idle' : 'online').catch(() => {});
    });
    window.addEventListener('pagehide', () => {
      if (!currentUser?.uid) return;
      leaveActiveVoiceChannel().catch(() => {});
      stopMicStream();
      updatePresence('offline').catch(() => {});
    });
    window.addEventListener('unhandledrejection', (event) => {
      const msg = String(event?.reason?.message || event?.reason || '');
      if (/missing or insufficient permissions/i.test(msg)) {
        showToast('Permission blocked by Firestore rules. Publish latest rules.', 'error');
        event.preventDefault();
      }
    });

    document.getElementById('message-input').onkeydown = (e) => {
      if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); sendMessage(); }
      if (e.key === 'Escape') { replyingTo = null; document.getElementById('reply-preview').classList.add('hidden'); }
    };
    document.getElementById('reply-cancel').onclick = () => {
      replyingTo = null;
      document.getElementById('reply-preview').classList.add('hidden');
    };
    document.getElementById('message-input').oninput = () => updateTyping(true);

    document.getElementById('btn-attach').onclick = () => document.getElementById('file-attach').click();
    document.getElementById('file-attach').onchange = async (e) => {
      const file = e.target.files?.[0];
      if (!file) return;
      try {
        const uploadAt = Date.now();
        const storagePath = `messages/${currentUser.uid}/${uploadAt}_${file.name}`;
        const r = ref(storage, storagePath);
        await uploadBytes(r, file, { contentType: file.type || 'application/octet-stream' });
        const url = await getDownloadURL(r);
        const attachment = {
          type: file.type.startsWith('image/') ? 'image' : 'file',
          url,
          storagePath,
          uploadedAt: uploadAt,
          expiresAt: uploadAt + ATTACHMENT_TTL_MS,
          name: file.name || 'Attachment',
          size: file.size || 0,
          mimeType: file.type || 'application/octet-stream'
        };
        if (attachment.type === 'image') {
          const moderation = await analyzeImageModeration(url);
          if (moderation.flagged) {
            try { await deleteObject(r); } catch (_) {}
            showToast('Inappropriate image detected. Account removed.', 'error');
            await enforcePolicyAccountDeletion(moderation.reason || 'Inappropriate image');
            return;
          }
        }
        pendingAttachments.push(attachment);
        const prev = document.getElementById('attachment-preview');
        prev.classList.remove('hidden');
        const wrap = document.createElement('div');
        const safeUrl = escapeHtml(url);
        const safeName = escapeHtml(attachment.name);
        if (attachment.type === 'image') {
          wrap.className = 'flex items-center gap-1';
          wrap.innerHTML = `<img src="${safeUrl}" class="w-12 h-12 object-cover rounded" alt="${safeName}"><button type="button" class="text-discord-red text-xs" data-remove>x</button>`;
        } else {
          wrap.className = 'flex items-center gap-2 px-2 py-1 rounded bg-discord-darkest/70';
          wrap.innerHTML = `<span class="text-xs text-gray-300 max-w-[160px] truncate" title="${safeName}">${safeName}</span><button type="button" class="text-discord-red text-xs" data-remove>x</button>`;
        }
        wrap.querySelector('[data-remove]').onclick = () => {
          pendingAttachments = pendingAttachments.filter(a => a.url !== url);
          wrap.remove();
          if (pendingAttachments.length === 0) prev.classList.add('hidden');
        };
        prev.appendChild(wrap);
      } catch (err) { showToast(err.message, 'error'); }
      e.target.value = '';
    };

    onAuthStateChanged(auth, async (user) => {
      if (user) {
        const isBanned = await isGloballyBannedIdentity({
          email: user.email || '',
          username: user.displayName || ''
        });
        if (isBanned) {
          showToast('This account is banned.', 'error');
          await signOut(auth);
          return;
        }
        const userRef = doc(db, 'users', user.uid);
        const u = await getDoc(userRef);
        const existing = u.data() || {};
        const stillBanned = await isGloballyBannedIdentity({
          email: user.email || '',
          username: existing.displayName || user.displayName || ''
        });
        if (stillBanned) {
          showToast('This account is banned.', 'error');
          await signOut(auth);
          return;
        }
        const ensuredProfile = {
          displayName: existing.displayName || user.displayName || user.email?.split('@')[0] || 'User',
          displayNameNormalized: normalizeAccountName(existing.displayName || user.displayName || user.email?.split('@')[0] || 'User'),
          email: String(existing.email || user.email || '').toLowerCase().trim(),
          photoURL: existing.photoURL || user.photoURL || '',
          bio: existing.bio || '',
          status: existing.status || 'offline'
        };
        if (!u.exists()) ensuredProfile.createdAt = serverTimestamp();
        await setDoc(userRef, ensuredProfile, { merge: true });
        const d = ensuredProfile;
        currentUser = { uid: user.uid, displayName: d?.displayName || user.email?.split('@')[0], bio: d?.bio || '', photoURL: d?.photoURL || user.photoURL || '' };
        document.getElementById('auth-screen').classList.add('hidden');
        document.getElementById('main-app').classList.remove('hidden');
        updateUserPill();
        await updatePresence('online');
        startPresenceHeartbeat();
        startAttachmentCleanupScheduler();
        startPublicSuspensionLifecycleWatcher();
        loadServers();
        const params = new URLSearchParams(location.search);
        const invite = params.get('invite');
        if (invite) { renderJoinModal(); document.getElementById('invite-code').value = invite; }
      } else {
        stopPresenceHeartbeat();
        stopAttachmentCleanupScheduler();
        stopActiveSuspensionWatcher();
        stopPublicSuspensionLifecycleWatcher();
        leaveActiveVoiceChannel().catch(() => {});
        stopVoiceMembersSubscription();
        stopMicStream();
        stopServerBannedAccountsWatcher();
        if (unsubMyMemberships) { unsubMyMemberships(); unsubMyMemberships = null; }
        if (unsubMembers) { unsubMembers(); unsubMembers = null; }
        if (unsubReports) { unsubReports(); unsubReports = null; }
        reportAlertInitialized = false;
        seenReportAlerts.clear();
        openReports = {};
        clearMemberUserListeners();
        memberUserData = {};
        userPresence = {};
        currentUser = null;
        currentServerId = null;
        currentChannelId = null;
        updateServerActionButtons();
        document.getElementById('auth-screen').classList.remove('hidden');
        document.getElementById('main-app').classList.add('hidden');
      }
    });
  </script>
</body>
</html>
