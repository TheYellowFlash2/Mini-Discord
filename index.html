<!DOCTYPE html>
<html lang="en" class="dark">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Mini-Discord</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      darkMode: 'class',
      theme: {
        extend: {
          colors: {
            discord: {
              dark: '#36393f',
              darker: '#2f3136',
              darkest: '#202225',
              blurple: '#5865F2',
              green: '#57F287',
              yellow: '#FEE75C',
              red: '#ED4245',
            }
          }
        }
      }
    }
  </script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    * { font-family: 'Inter', system-ui, sans-serif; }
    .scrollbar-thin::-webkit-scrollbar { width: 8px; height: 8px; }
    .scrollbar-thin::-webkit-scrollbar-track { background: transparent; }
    .scrollbar-thin::-webkit-scrollbar-thumb { background: #202225; border-radius: 4px; }
    .scrollbar-thin::-webkit-scrollbar-thumb:hover { background: #36393f; }
    .message-group:hover { background: rgba(4,4,5,0.07); }
    @keyframes fadeIn { from { opacity: 0; transform: translateY(-10px); } to { opacity: 1; transform: translateY(0); } }
    .modal-animate { animation: fadeIn 0.2s ease-out; }
    .skeleton { background: linear-gradient(90deg, #36393f 25%, #2f3136 50%, #36393f 75%); background-size: 200% 100%; animation: skeleton 1.5s infinite; }
    @keyframes skeleton { 0% { background-position: 200% 0; } 100% { background-position: -200% 0; } }
    .toast-enter { animation: toastIn 0.3s ease-out; }
    @keyframes toastIn { from { opacity: 0; transform: translateY(-20px); } to { opacity: 1; transform: translateY(0); } }
    .typing-dot { animation: typingBounce 1.4s infinite; }
    .typing-dot:nth-child(2) { animation-delay: 0.2s; }
    .typing-dot:nth-child(3) { animation-delay: 0.4s; }
    @keyframes typingBounce { 0%, 60%, 100% { transform: translateY(0); } 30% { transform: translateY(-4px); } }
    .gif-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); gap: 4px; }
    .emoji-btn { border: 1px solid rgba(255,255,255,0.1); }
    .emoji-btn:hover { border-color: rgba(255,255,255,0.3); background: rgba(255,255,255,0.05); }
  </style>
</head>
<body class="bg-discord-darkest text-gray-100 min-h-screen overflow-hidden">
  <!-- ========== CONFIG ========== -->
  <script>
    const firebaseConfig = {
      apiKey: "AIzaSyAnUTCjnbxCEeMpmqfxsfzryUpiVqpp3SE",
      authDomain: "mini-discord-b0977.firebaseapp.com",
      projectId: "mini-discord-b0977",
      storageBucket: "mini-discord-b0977.firebasestorage.app",
      messagingSenderId: "999795104831",
      appId: "1:999795104831:web:f76fdf43d6c889e8deec8a",
      measurementId: "G-V0K3TN8183"
    };
    const GIPHY_API_KEY = "peAMzd2AaeUlKwbMp86bp1wLxHorJFXu";
    const MISTRAL_API_KEY = "ZtJVf6hjKb3FWeVgsFApxIpqs2oKg2U3";
    const DEBUG_MODE = false;
  </script>
  <!-- ========== END CONFIG ========== -->

  <div id="app" class="flex h-screen">
    <div id="auth-screen" class="flex-1 flex items-center justify-center bg-discord-darkest p-4">
      <div class="w-full max-w-md text-center">
        <h1 class="text-4xl font-bold text-white mb-2">Mini-Discord</h1>
        <p class="text-gray-400 mb-8">A Discord-like chat experience</p>
        <div class="space-y-3">
          <button id="btn-login" class="w-full py-3 px-4 bg-discord-blurple hover:bg-indigo-600 rounded font-medium transition">Login</button>
          <button id="btn-signup" class="w-full py-3 px-4 bg-discord-dark hover:bg-discord-darker rounded font-medium transition">Create Account</button>
          <button id="btn-join-invite" class="w-full py-3 px-4 bg-discord-dark hover:bg-discord-darker rounded font-medium transition">Join with Invite</button>
        </div>
      </div>
    </div>

    <div id="main-app" class="hidden flex-1 flex h-screen overflow-hidden">
      <aside id="server-sidebar" class="w-[72px] bg-discord-darkest flex flex-col items-center py-3 gap-2 flex-shrink-0 scrollbar-thin overflow-y-auto">
        <button id="btn-add-server" class="w-12 h-12 rounded-2xl bg-discord-dark hover:bg-discord-green hover:text-discord-darkest flex items-center justify-center transition text-2xl font-light" title="Create Server">+</button>
        <button id="btn-join-server" class="w-12 h-12 rounded-2xl bg-discord-dark hover:bg-discord-blurple flex items-center justify-center transition text-sm font-medium" title="Join Server">Join</button>
        <div id="server-list" class="flex flex-col gap-2"></div>
      </aside>

      <aside id="channel-sidebar" class="w-60 bg-discord-darker flex flex-col flex-shrink-0 hidden md:flex">
        <div class="h-12 px-4 flex items-center justify-between border-b border-discord-dark shadow-sm">
          <div class="flex items-center gap-2 min-w-0">
            <span id="current-server-name" class="font-semibold truncate">Select Server</span>
            <button id="btn-admin-menu" class="flex-shrink-0 p-1 rounded text-gray-400 hover:text-white hover:bg-discord-dark hidden" title="Server Admin">âš™</button>
          </div>
          <div class="flex gap-2 flex-shrink-0">
            <button id="btn-invite" class="text-xs px-2 py-1 rounded bg-discord-dark hover:bg-discord-blurple text-gray-300 hover:text-white transition font-medium">Invite</button>
            <button id="btn-leave-server" class="text-xs px-2 py-1 rounded bg-discord-dark hover:bg-discord-red text-gray-300 hover:text-white transition font-medium">Leave</button>
          </div>
        </div>
        <div class="flex-1 overflow-y-auto scrollbar-thin py-2">
          <div class="px-2">
            <button id="btn-add-channel" class="w-full text-left px-2 py-1.5 rounded text-gray-400 hover:bg-discord-dark hover:text-white flex items-center gap-2 text-sm">
              <span>#</span> Text Channels
            </button>
            <div id="channel-list" class="mt-1"></div>
          </div>
        </div>
        <div class="p-2 border-t border-discord-dark">
          <div id="user-pill" class="flex items-center gap-3 px-2 py-2 rounded hover:bg-discord-dark cursor-pointer">
            <div class="w-8 h-8 rounded-full bg-discord-blurple flex items-center justify-center overflow-hidden">
              <img id="user-avatar" class="w-full h-full object-cover" src="" alt="" onerror="this.style.display='none';this.nextElementSibling.style.display='flex';">
              <span id="user-initial" class="hidden">?</span>
            </div>
            <div class="flex-1 min-w-0 hidden md:block">
              <div id="user-display-name" class="text-sm font-medium truncate">User</div>
              <div id="user-status" class="text-xs text-gray-500">Online</div>
            </div>
          </div>
        </div>
      </aside>

      <button id="btn-toggle-channel" class="md:hidden fixed top-4 left-20 z-40 bg-discord-dark p-2 rounded">â˜°</button>

      <main class="flex-1 flex flex-col min-w-0 bg-discord-dark">
        <header class="h-12 px-4 flex items-center border-b border-discord-dark shadow-sm flex-shrink-0">
          <span id="channel-header-name" class="font-semibold"># general</span>
          <div class="ml-4 flex-1"></div>
          <button id="btn-members-toggle" class="p-2 hover:bg-discord-darker rounded lg:hidden">ğŸ‘¥</button>
        </header>

        <div id="messages-container" class="flex-1 overflow-y-auto scrollbar-thin p-4 flex flex-col-reverse">
          <div id="messages-loading" class="flex justify-center py-8">
            <div class="animate-spin w-8 h-8 border-2 border-discord-blurple border-t-transparent rounded-full"></div>
          </div>
          <div id="messages-list" class="space-y-4"></div>
          <div id="load-more" class="hidden py-4 text-center">
            <button id="btn-load-more" class="text-discord-blurple hover:underline text-sm">Load older messages</button>
          </div>
        </div>

        <div id="typing-indicator" class="hidden px-4 py-2 text-sm text-gray-400">
          <span id="typing-users"></span> <span class="typing-dot">.</span><span class="typing-dot">.</span><span class="typing-dot">.</span>
        </div>

        <div id="message-input-area" class="p-4 flex-shrink-0">
          <div id="reply-preview" class="hidden mb-2 px-3 py-2 rounded-l border-l-4 border-discord-blurple bg-discord-darker/50 flex items-center justify-between">
            <div class="min-w-0 flex-1">
              <span class="text-xs text-discord-blurple font-medium">Replying to </span>
              <span class="text-sm text-gray-300 truncate" id="reply-preview-name"></span>
              <p class="text-xs text-gray-500 truncate mt-0.5" id="reply-preview-text"></p>
            </div>
            <button type="button" id="reply-cancel" class="text-gray-400 hover:text-white p-1 flex-shrink-0">âœ•</button>
          </div>
          <div class="flex items-end gap-2">
            <div class="flex-1 flex items-center gap-2 bg-discord-darker rounded-lg px-4 py-2 min-h-[44px]">
              <button id="btn-emoji" class="text-gray-400 hover:text-white p-1" title="Emoji">ğŸ˜€</button>
              <button id="btn-gif" class="text-gray-400 hover:text-white p-1" title="GIF">GIF</button>
              <input type="file" id="file-attach" accept="*/*" class="hidden">
              <button id="btn-attach" class="text-gray-400 hover:text-white p-1 text-lg" title="Upload file">ğŸ“</button>
              <input id="message-input" type="text" placeholder="Message #general" class="flex-1 bg-transparent outline-none text-sm py-1" maxlength="2000">
              <div id="attachment-preview" class="hidden flex items-center gap-2 flex-wrap"></div>
            </div>
            <button id="btn-send" class="p-2 rounded-full bg-discord-blurple hover:bg-indigo-600 disabled:opacity-50 disabled:cursor-not-allowed transition">
              <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 24 24"><path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z"/></svg>
            </button>
          </div>
        </div>
      </main>

      <aside id="members-sidebar" class="w-60 bg-discord-darker flex flex-col flex-shrink-0 hidden lg:flex">
        <div class="h-12 px-4 flex items-center border-b border-discord-dark">
          <span class="font-semibold text-sm">Members</span>
        </div>
        <div id="members-list" class="flex-1 overflow-y-auto scrollbar-thin p-2"></div>
      </aside>
    </div>
  </div>

  <div id="modal-backdrop" class="fixed inset-0 bg-black/50 z-50 hidden items-center justify-center p-4" style="display: none;">
    <div id="modal-content" class="bg-discord-darker rounded-lg shadow-xl max-w-md w-full max-h-[90vh] overflow-y-auto modal-animate" onclick="event.stopPropagation()">
      <div class="p-6">
        <div class="flex items-center justify-between mb-4">
          <h2 id="modal-title" class="text-xl font-semibold">Modal</h2>
          <button id="modal-close" class="text-gray-400 hover:text-white p-1">âœ•</button>
        </div>
        <div id="modal-body"></div>
      </div>
    </div>
  </div>

  <div id="toast-container" class="fixed bottom-4 right-4 z-[100] flex flex-col gap-2"></div>

  <script type="module">
    import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
    import { getAuth, createUserWithEmailAndPassword, signInWithEmailAndPassword, signOut, onAuthStateChanged } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js';
    import { getFirestore, collection, doc, setDoc, getDoc, getDocs, addDoc, updateDoc, deleteDoc, query, where, orderBy, limit, startAfter, onSnapshot, serverTimestamp, increment } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js';
    import { getStorage, ref, uploadBytes, getDownloadURL, deleteObject } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-storage.js';

    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getFirestore(app);
    const storage = getStorage(app);

    let currentUser = null;
    let currentServerId = null;
    let currentChannelId = null;
    let servers = {};
    let channels = {};
    let members = {};
    let memberUserData = {};
    let memberUserUnsubs = {};
    let messages = {};
    let typingUsers = {};
    let userPresence = {};
    let messageListeners = [];
    let channelUnsub = null;
    let unsubPresence = null;
    let unsubMembers = null;
    let unsubMyMemberships = null;
    let unsubReports = null;
    let unsubActiveSuspension = null;
    let reportAlertInitialized = false;
    const seenReportAlerts = new Set();
    let openReports = {};
    let lastSuspensionNoticeKey = '';
    let serversLoadVersion = 0;
    let membersLoadVersion = 0;
    let presenceInterval = null;
    let lastDoc = null;
    const MESSAGE_LIMIT = 50;
    const PRESENCE_HEARTBEAT_MS = 30000;
    const PRESENCE_STALE_MS = 90000;
    const ATTACHMENT_TTL_MS = 2 * 24 * 60 * 60 * 1000;
    const ATTACHMENT_CLEANUP_INTERVAL_MS = 15 * 60 * 1000;
    let pendingAttachments = [];
    const PUBLIC_SERVER_ID = 'public';
    const BOT_USER_ID = 'global-bot-mistral';
    const BOT_DISPLAY_NAME = 'Mistral';
    const BOT_MODEL = 'pixtral-12b-2409';
    const PROFANITY_WORDS = ['fuck','fucking','shit','bitch','asshole','bastard','cunt','nigger','nigga','faggot','retard','whore','slut','dick','pussy'];
    const moderationCooldownByUser = {};
    let attachmentCleanupInterval = null;
    let replyingTo = null;
    let activeMemberProfileUserId = null;
    const NOTIFICATION_PREF_KEY = 'mini_discord_notifications_enabled';
    let notificationsEnabled = localStorage.getItem(NOTIFICATION_PREF_KEY) === 'true';
    const REPORT_REASONS = ['Harassment', 'Spam', 'Hate Speech', 'Threats', 'Impersonation', 'Other'];

    const EMOJI_CATEGORIES = {
      'Smileys': ['ğŸ˜€','ğŸ˜ƒ','ğŸ˜„','ğŸ˜','ğŸ˜†','ğŸ˜…','ğŸ¤£','ğŸ˜‚','ğŸ™‚','ğŸ™ƒ','ğŸ˜‰','ğŸ˜Š','ğŸ˜‡','ğŸ¥°','ğŸ˜','ğŸ¤©','ğŸ˜˜','ğŸ˜—','â˜º','ğŸ˜š','ğŸ˜™','ğŸ¥²','ğŸ˜‹','ğŸ˜›','ğŸ˜œ','ğŸ¤ª','ğŸ˜','ğŸ¤‘','ğŸ¤—','ğŸ¤­','ğŸ¤«','ğŸ¤”','ğŸ¤','ğŸ¤¨','ğŸ˜','ğŸ˜‘','ğŸ˜¶','ğŸ˜','ğŸ˜’','ğŸ™„','ğŸ˜¬','ğŸ¤¥','ğŸ˜Œ','ğŸ˜”','ğŸ˜ª','ğŸ¤¤','ğŸ˜´','ğŸ˜·','ğŸ¤’','ğŸ¤•','ğŸ¤¢','ğŸ¤®','ğŸ¤§','ğŸ¥µ','ğŸ¥¶','ğŸ¥´','ğŸ˜µ','ğŸ¤¯','ğŸ¤ ','ğŸ¥³','ğŸ¥¸'],
      'Gestures': ['ğŸ‘‹','ğŸ¤š','ğŸ–','âœ‹','ğŸ––','ğŸ‘Œ','ğŸ¤Œ','ğŸ¤','âœŒ','ğŸ¤','ğŸ¤Ÿ','ğŸ¤˜','ğŸ¤™','ğŸ‘ˆ','ğŸ‘‰','ğŸ‘†','ğŸ–•','ğŸ‘‡','â˜','ğŸ‘','ğŸ‘','âœŠ','ğŸ‘Š','ğŸ¤›','ğŸ¤œ','ğŸ‘','ğŸ™Œ','ğŸ‘','ğŸ¤²','ğŸ¤','ğŸ™','âœ','ğŸ’…','ğŸ¤³','ğŸ’ª','ğŸ¦¾','ğŸ¦¿','ğŸ¦µ','ğŸ¦¶','ğŸ‘‚','ğŸ¦»','ğŸ‘ƒ','ğŸ§ ','ğŸ«€','ğŸ«','ğŸ¦·','ğŸ¦´','ğŸ‘€','ğŸ‘','ğŸ‘…','ğŸ‘„'],
      'Hearts': ['â¤ï¸','ğŸ§¡','ğŸ’›','ğŸ’š','ğŸ’™','ğŸ’œ','ğŸ–¤','ğŸ¤','ğŸ¤','ğŸ’”','â£ï¸','ğŸ’•','ğŸ’','ğŸ’“','ğŸ’—','ğŸ’–','ğŸ’˜','ğŸ’','ğŸ’Ÿ','â™¥ï¸'],
      'Symbols': ['âœ–ï¸','â•','â–','â—','â™¾ï¸','ğŸ’²','ğŸ’±','â„¢ï¸','Â©ï¸','Â®ï¸','ã€°ï¸','â°','â¿','ğŸ”','ğŸ”™','ğŸ”›','ğŸ”œ','ğŸ”š','ã€½ï¸','âœ³ï¸','â‡ï¸','â€¼ï¸','â‰ï¸','â“','â”','â—','â•','ğŸ”…','ğŸ”†','âš ï¸','ğŸš¸','ğŸ”±','âšœï¸','ğŸ”°','â™»ï¸','âœ…','ğŸˆ¯','ğŸ’¹','â‡ï¸','âœ³ï¸','â','ğŸŒ','ğŸ’ ','â“‚ï¸','ğŸŒ€','ğŸ’¤','ğŸ§','ğŸš¾','â™¿','ğŸ…¿ï¸','ğŸ›—','ğŸˆ³','ğŸˆ‚ï¸','ğŸ›‚','ğŸ›ƒ','ğŸ›„','ğŸ›…','ğŸš¹','ğŸšº','ğŸš¼','âš§ï¸','ğŸš»','â™»ï¸','â›”','ğŸš«','ğŸš³','ğŸš­','ğŸš¯','ğŸš±','ğŸš·','ğŸ“µ','ğŸ”','â˜¢ï¸','â˜£ï¸','â¬†ï¸','â†—ï¸','â¡ï¸','â†˜ï¸','â¬‡ï¸','â†™ï¸','â¬…ï¸','â†–ï¸','â†•ï¸','â†”ï¸','â†©ï¸','â†ªï¸','â¤´ï¸','â¤µï¸','ğŸ”ƒ','ğŸ”„','ğŸ”™','ğŸ”›','ğŸ”œ','ğŸ”']
    };

    function showToast(message, type = 'info') {
      const container = document.getElementById('toast-container');
      const toast = document.createElement('div');
      toast.className = 'bg-discord-darker border border-discord-dark px-4 py-3 rounded shadow-lg toast-enter flex items-center gap-2';
      const colors = { success: 'text-discord-green', error: 'text-discord-red', info: 'text-gray-300' };
      toast.innerHTML = `<span class="${colors[type] || colors.info}">${message}</span>`;
      container.appendChild(toast);
      setTimeout(() => toast.remove(), 3000);
    }

    function formatTime(timestamp) {
      if (!timestamp) return '';
      const d = timestamp?.toDate ? timestamp.toDate() : new Date(timestamp);
      const now = new Date();
      const diff = now - d;
      if (diff < 60000) return 'Just now';
      if (diff < 3600000) return `${Math.floor(diff/60000)}m ago`;
      if (diff < 86400000) return d.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
      if (diff < 604800000) return d.toLocaleDateString([], { weekday: 'short' });
      return d.toLocaleDateString();
    }

    function escapeHtml(text) {
      if (!text) return '';
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    function formatFileSize(bytes) {
      const n = Number(bytes);
      if (!Number.isFinite(n) || n <= 0) return '';
      const units = ['B', 'KB', 'MB', 'GB', 'TB'];
      let size = n;
      let unitIndex = 0;
      while (size >= 1024 && unitIndex < units.length - 1) {
        size /= 1024;
        unitIndex++;
      }
      const rounded = size >= 100 ? Math.round(size) : Math.round(size * 10) / 10;
      return `${rounded} ${units[unitIndex]}`;
    }

    function isImageAttachment(att) {
      if (!att?.url) return false;
      const type = (att.type || '').toLowerCase();
      const mimeType = (att.mimeType || '').toLowerCase();
      if (type === 'image' || mimeType.startsWith('image/')) return true;
      return /\.(gif|png|jpe?g|webp|bmp|svg)$/i.test(att.url);
    }

    function debounce(fn, ms) {
      let t;
      return (...args) => { clearTimeout(t); t = setTimeout(() => fn(...args), ms); };
    }

    function notificationsSupported() {
      return typeof Notification !== 'undefined';
    }

    function getNotificationPermissionLabel() {
      if (!notificationsSupported()) return 'Unsupported';
      if (Notification.permission === 'granted') return 'Granted';
      if (Notification.permission === 'denied') return 'Denied';
      return 'Not requested';
    }

    function updateNotificationToggleUI() {
      const btn = document.getElementById('profile-notifications-toggle');
      const status = document.getElementById('profile-notification-status');
      if (btn) {
        btn.textContent = notificationsEnabled ? 'On' : 'Off';
        btn.className = `px-3 py-1 rounded text-sm font-medium transition ${notificationsEnabled ? 'bg-discord-blurple hover:bg-indigo-600 text-white' : 'bg-discord-dark hover:bg-discord-darker text-gray-300'}`;
      }
      if (status) status.textContent = `Permission: ${getNotificationPermissionLabel()}`;
    }

    async function setNotificationsEnabled(enabled) {
      notificationsEnabled = !!enabled;
      localStorage.setItem(NOTIFICATION_PREF_KEY, String(notificationsEnabled));
      if (notificationsEnabled) {
        if (!notificationsSupported()) {
          notificationsEnabled = false;
          localStorage.setItem(NOTIFICATION_PREF_KEY, 'false');
          showToast('Notifications are not supported in this browser', 'error');
          updateNotificationToggleUI();
          return;
        }
        if (Notification.permission === 'default') {
          const permission = await Notification.requestPermission();
          if (permission !== 'granted') {
            notificationsEnabled = false;
            localStorage.setItem(NOTIFICATION_PREF_KEY, 'false');
            showToast('Notification permission was not granted', 'error');
          } else {
            showToast('Desktop notifications enabled', 'success');
          }
        } else if (Notification.permission === 'denied') {
          notificationsEnabled = false;
          localStorage.setItem(NOTIFICATION_PREF_KEY, 'false');
          showToast('Notifications are blocked in browser settings', 'error');
        } else {
          showToast('Desktop notifications enabled', 'success');
        }
      } else {
        showToast('Desktop notifications disabled', 'info');
      }
      updateNotificationToggleUI();
    }

    function maybeNotifyForMessage(messageId, messageData) {
      if (!notificationsEnabled || !notificationsSupported()) return;
      if (Notification.permission !== 'granted') return;
      if (!messageData || messageData.userId === currentUser?.uid) return;
      if (!document.hidden) return;
      const sender = getUserDisplayName(memberUserData[messageData.userId], messageData) || 'Someone';
      const channelName = channels[messageData.channelId]?.name || 'channel';
      const text = (messageData.text || '').trim();
      const attachmentText = (messageData.attachments || []).length ? 'Sent an attachment' : 'New message';
      const body = text ? text.slice(0, 140) : attachmentText;
      const notif = new Notification(`${sender} in #${channelName}`, {
        body,
        icon: messageData.photoURL || memberUserData[messageData.userId]?.photoURL || '',
        tag: `msg-${messageId}`
      });
      notif.onclick = () => window.focus();
    }

    async function resolveReport(reportId, action = 'dismissed', reportedUserId = '') {
      if (!reportId || !isAdmin()) return;
      try {
        await updateDoc(doc(db, 'reports', reportId), {
          status: action === 'kicked' ? 'actioned' : 'dismissed',
          action,
          resolvedBy: currentUser.uid,
          resolvedAt: serverTimestamp()
        });
      } catch (_) {}
      delete openReports[reportId];
      renderAdminReportsInbox();
      if (action === 'kicked' && reportedUserId) {
        try {
          await kickUserFromServer(currentServerId, reportedUserId, 'User kicked from report');
        } catch (_) {}
      }
    }

    async function fetchOpenReportsForCurrentServer() {
      if (!currentServerId || !currentUser?.uid || !isAdmin()) {
        openReports = {};
        return;
      }
      const snap = await getDocs(query(
        collection(db, 'reports'),
        where('serverId', '==', currentServerId),
        limit(100)
      ));
      const nextOpen = {};
      snap.docs.forEach((d) => {
        const data = d.data();
        if (data?.status === 'open') nextOpen[d.id] = { id: d.id, ...data };
      });
      openReports = nextOpen;
    }

    function renderAdminReportsInbox() {
      const host = document.getElementById('admin-reports-inbox');
      if (!host) return;
      const rows = Object.values(openReports)
        .filter(r => r.serverId === currentServerId && r.status === 'open')
        .sort((a, b) => {
          const at = a.createdAt?.toDate ? a.createdAt.toDate().getTime() : 0;
          const bt = b.createdAt?.toDate ? b.createdAt.toDate().getTime() : 0;
          return bt - at;
        })
        .map((r) => {
          const reportedUser = memberUserData[r.reportedUserId] || {};
          const reporterUser = memberUserData[r.reportedBy] || {};
          const reportedName = getUserDisplayName(reportedUser, {}) || 'Unknown';
          const reporterName = getUserDisplayName(reporterUser, { displayName: r.reportedByDisplayName || 'User' }) || 'User';
          const reason = (r.reason || 'Other').trim();
          const details = (r.details || '').trim();
          return `
            <div class="rounded border border-discord-dark bg-discord-darkest/40 p-3">
              <div class="flex items-center justify-between gap-2">
                <div class="text-sm text-gray-200">${escapeHtml(reportedName)} <span class="text-gray-500">reported by ${escapeHtml(reporterName)}</span></div>
                <span class="text-xs text-gray-500">${formatTime(r.createdAt)}</span>
              </div>
              <div class="text-xs text-amber-300 mt-1">Reason: ${escapeHtml(reason)}</div>
              ${details ? `<div class="text-xs text-gray-400 mt-1">${escapeHtml(details)}</div>` : ''}
              <div class="mt-2 flex gap-2">
                <button type="button" class="text-xs px-2 py-1 rounded bg-discord-red hover:bg-red-500" data-report-inbox-kick="${r.id}" data-reported-user="${r.reportedUserId}">Kick</button>
                <button type="button" class="text-xs px-2 py-1 rounded bg-discord-dark hover:bg-discord-darker" data-report-inbox-dismiss="${r.id}">Dismiss</button>
              </div>
            </div>
          `;
        }).join('');
      host.innerHTML = rows || '<p class="text-gray-500 py-2">No open reports</p>';
      host.querySelectorAll('[data-report-inbox-kick]').forEach(btn => btn.onclick = async () => {
        await resolveReport(btn.dataset.reportInboxKick, 'kicked', btn.dataset.reportedUser || '');
      });
      host.querySelectorAll('[data-report-inbox-dismiss]').forEach(btn => btn.onclick = async () => {
        await resolveReport(btn.dataset.reportInboxDismiss, 'dismissed');
      });
    }

    function maybeNotifyForReport(reportId, reportData) {
      if (!reportData || reportData.reportedBy === currentUser?.uid) return;
      const reportedName = getUserDisplayName(memberUserData[reportData.reportedUserId], {}) || 'a user';
      const reporterName = getUserDisplayName(memberUserData[reportData.reportedBy], {}) || 'Someone';
      const reason = reportData.reason || 'Rule violation';
      if (document.hidden && notificationsEnabled && notificationsSupported() && Notification.permission === 'granted') {
        const notif = new Notification(`New report: ${reportedName}`, {
          body: `${reporterName} reported ${reportedName} for ${reason}`,
          tag: `report-${reportId}`
        });
        notif.onclick = () => {
          window.focus();
          renderAdminModal();
        };
        return;
      }
      const container = document.getElementById('toast-container');
      const toast = document.createElement('div');
      toast.className = 'bg-discord-darker border border-amber-600/60 px-4 py-3 rounded shadow-lg toast-enter';
      const details = (reportData.details || '').trim();
      toast.innerHTML = `
        <div class="text-sm">
          <div class="font-semibold text-amber-300">New user report</div>
          <div class="text-gray-200 mt-1">${escapeHtml(reporterName)} reported ${escapeHtml(reportedName)}</div>
          <div class="text-xs text-gray-400 mt-1">Reason: ${escapeHtml(reason)}</div>
          ${details ? `<div class="text-xs text-gray-500 mt-1 max-w-[260px] truncate">"${escapeHtml(details)}"</div>` : ''}
          <div class="mt-2 flex gap-2">
            <button type="button" data-report-kick="${reportId}" class="text-xs px-2 py-1 rounded bg-discord-red hover:bg-red-500">Kick</button>
            <button type="button" data-report-dismiss="${reportId}" class="text-xs px-2 py-1 rounded bg-discord-dark hover:bg-discord-darkest">Dismiss</button>
          </div>
        </div>
      `;
      container.appendChild(toast);
      const kickBtn = toast.querySelector(`[data-report-kick="${reportId}"]`);
      const dismissBtn = toast.querySelector(`[data-report-dismiss="${reportId}"]`);
      if (kickBtn) {
        kickBtn.onclick = async () => {
          await resolveReport(reportId, 'kicked', reportData.reportedUserId);
          toast.remove();
        };
      }
      if (dismissBtn) {
        dismissBtn.onclick = async () => {
          await resolveReport(reportId, 'dismissed', reportData.reportedUserId);
          toast.remove();
        };
      }
      setTimeout(() => toast.remove(), 25000);
    }

    function subscribeReports() {
      if (unsubReports) { unsubReports(); unsubReports = null; }
      reportAlertInitialized = false;
      openReports = {};
      if (!currentServerId || !currentUser?.uid || !isAdmin()) return;
      const q = query(
        collection(db, 'reports'),
        where('serverId', '==', currentServerId),
        limit(100)
      );
      unsubReports = onSnapshot(q, (snap) => {
        const nextOpen = {};
        snap.docs.forEach((d) => {
          const data = d.data();
          if (data?.status === 'open') nextOpen[d.id] = { id: d.id, ...data };
        });
        openReports = nextOpen;
        renderAdminReportsInbox();
        if (!reportAlertInitialized) {
          Object.values(openReports).forEach((d) => {
            if (!seenReportAlerts.has(d.id)) {
              seenReportAlerts.add(d.id);
              maybeNotifyForReport(d.id, d);
            }
          });
          reportAlertInitialized = true;
          return;
        }
        snap.docChanges().forEach((change) => {
          const data = change.doc.data() || {};
          if (data.status !== 'open') return;
          if (change.type !== 'added' && change.type !== 'modified') return;
          if (!seenReportAlerts.has(change.doc.id)) {
            seenReportAlerts.add(change.doc.id);
            maybeNotifyForReport(change.doc.id, data);
          }
        });
      }, (err) => {
        showToast('Report alerts failed to subscribe', 'error');
        if (DEBUG_MODE) console.error('Report subscription failed', err);
      });
    }

    function renderReportUserModal(userId) {
      const memberData = memberUserData[userId] || {};
      const displayName = getUserDisplayName(memberData, {}) || 'Unknown';
      modal.open('Report User', `
        <form id="report-user-form" class="space-y-4">
          <p class="text-sm text-gray-400">Reporting <span class="text-white font-medium">${escapeHtml(displayName)}</span></p>
          <div>
            <label class="block text-sm text-gray-400 mb-1">Reason</label>
            <select id="report-reason" class="w-full bg-discord-dark border border-discord-darkest rounded px-3 py-2 outline-none focus:border-discord-blurple">
              ${REPORT_REASONS.map((r) => `<option value="${escapeHtml(r)}">${escapeHtml(r)}</option>`).join('')}
            </select>
          </div>
          <div>
            <label class="block text-sm text-gray-400 mb-1">Details</label>
            <textarea id="report-details" rows="4" maxlength="300" placeholder="What happened?" class="w-full bg-discord-dark border border-discord-darkest rounded px-3 py-2 outline-none focus:border-discord-blurple resize-none"></textarea>
          </div>
          <button type="submit" class="w-full py-2 bg-discord-red hover:bg-red-500 rounded font-medium">Report User</button>
        </form>
      `);
      document.getElementById('report-user-form').onsubmit = async (e) => {
        e.preventDefault();
        if (!currentUser?.uid || !currentServerId || !userId) return;
        if (userId === currentUser.uid) { showToast('You cannot report yourself', 'error'); return; }
        const reason = document.getElementById('report-reason').value;
        const details = document.getElementById('report-details').value.trim();
        try {
          await addDoc(collection(db, 'reports'), {
            serverId: currentServerId,
            channelId: currentChannelId || null,
            status: 'open',
            reason: reason || 'Other',
            details: details.slice(0, 300),
            reportedUserId: userId,
            reportedBy: currentUser.uid,
            reportedByDisplayName: currentUser.displayName || 'User',
            createdAt: serverTimestamp()
          });
          showToast('Report sent to admins', 'success');
          modal.closeModal();
        } catch (err) {
          showToast(err?.message || 'Failed to submit report', 'error');
        }
      };
    }

    function getUserDisplayName(userData, memberData) {
      return (userData?.displayName || userData?.username || memberData?.displayName || memberData?.username || '').trim();
    }

    function textHasProfanity(text) {
      const raw = (text || '').toLowerCase();
      if (!raw) return false;
      return PROFANITY_WORDS.some(word => new RegExp(`\\b${word.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\b`, 'i').test(raw));
    }

    function extractMistralText(content) {
      if (!content) return '';
      if (typeof content === 'string') return content.trim();
      if (Array.isArray(content)) {
        return content.map(item => {
          if (typeof item === 'string') return item;
          if (item?.type === 'text') return item.text || '';
          return '';
        }).join(' ').trim();
      }
      return String(content).trim();
    }

    function getAttachmentStoragePath(att) {
      if (!att) return '';
      if (att.storagePath) return att.storagePath;
      const url = (att.url || '').trim();
      if (!url.includes('firebasestorage.googleapis.com')) return '';
      const m = url.match(/\/o\/([^?]+)/);
      if (!m?.[1]) return '';
      try { return decodeURIComponent(m[1]); } catch (_) { return ''; }
    }

    async function deleteAttachmentFromStorage(att) {
      const storagePath = getAttachmentStoragePath(att);
      if (!storagePath) return false;
      try {
        await deleteObject(ref(storage, storagePath));
        return true;
      } catch (_) {
        return false;
      }
    }

    async function deleteMessageWithAttachments(messageId, messageData) {
      const data = messageData || messages[messageId];
      if (!messageId || !data) return { filesDeleted: 0, messageDeleted: false };
      let filesDeleted = 0;
      for (const att of (data.attachments || [])) {
        const deleted = await deleteAttachmentFromStorage(att);
        if (deleted) filesDeleted++;
      }
      await deleteDoc(doc(db, 'messages', messageId));
      return { filesDeleted, messageDeleted: true };
    }

    function getDurationMs(value, unit) {
      const n = Number(value);
      if (!Number.isFinite(n) || n <= 0) return 0;
      if (unit === 'minutes') return n * 60 * 1000;
      if (unit === 'days') return n * 24 * 60 * 60 * 1000;
      return n * 60 * 60 * 1000;
    }

    function formatDurationRemaining(ms) {
      const remaining = Math.max(0, Number(ms) || 0);
      const totalMinutes = Math.ceil(remaining / 60000);
      if (totalMinutes < 60) return `${totalMinutes} minute${totalMinutes === 1 ? '' : 's'}`;
      const totalHours = Math.ceil(totalMinutes / 60);
      if (totalHours < 24) return `${totalHours} hour${totalHours === 1 ? '' : 's'}`;
      const totalDays = Math.ceil(totalHours / 24);
      return `${totalDays} day${totalDays === 1 ? '' : 's'}`;
    }

    async function getActiveSuspension(serverId, userId = currentUser?.uid) {
      if (!serverId || !userId) return null;
      try {
        const suspensionRef = doc(db, 'servers', serverId, 'suspended', userId);
        const snap = await getDoc(suspensionRef);
        if (!snap.exists()) return null;
        const data = snap.data() || {};
        const untilMs = Number(data.untilMs || 0);
        if (!untilMs || untilMs <= Date.now()) {
          deleteDoc(suspensionRef).catch(() => {});
          return null;
        }
        return { ...data, untilMs };
      } catch (_) {
        return null;
      }
    }

    function stopActiveSuspensionWatcher() {
      if (unsubActiveSuspension) {
        unsubActiveSuspension();
        unsubActiveSuspension = null;
      }
    }

    function startActiveSuspensionWatcher(serverId) {
      stopActiveSuspensionWatcher();
      if (!serverId || !currentUser?.uid) return;
      const watchServerId = serverId;
      const suspensionRef = doc(db, 'servers', watchServerId, 'suspended', currentUser.uid);
      unsubActiveSuspension = onSnapshot(suspensionRef, async (snap) => {
        if (watchServerId !== currentServerId) return;
        if (!snap.exists()) {
          lastSuspensionNoticeKey = '';
          return;
        }
        const data = snap.data() || {};
        const untilMs = Number(data.untilMs || 0);
        if (!untilMs || untilMs <= Date.now()) {
          deleteDoc(suspensionRef).catch(() => {});
          lastSuspensionNoticeKey = '';
          return;
        }
        const noticeKey = `${watchServerId}:${untilMs}`;
        if (lastSuspensionNoticeKey !== noticeKey) {
          lastSuspensionNoticeKey = noticeKey;
          showSuspensionLockModal(servers[watchServerId]?.name || 'this server', { ...data, untilMs });
        }
        if (watchServerId !== PUBLIC_SERVER_ID && servers[PUBLIC_SERVER_ID]) {
          await selectServer(PUBLIC_SERVER_ID);
        } else {
          currentChannelId = null;
          renderChannelList();
          renderMessages();
        }
      }, () => {});
    }

    function showSuspensionLockModal(serverName, suspension) {
      const remaining = formatDurationRemaining((suspension?.untilMs || 0) - Date.now());
      const untilLabel = new Date(Number(suspension?.untilMs || Date.now())).toLocaleString();
      const reason = (suspension?.reason || '').trim();
      modal.open('Server Locked', `
        <div class="space-y-3">
          <p class="text-sm text-gray-300">You are suspended from <span class="text-white font-medium">${escapeHtml(serverName || 'this server')}</span>.</p>
          <div class="rounded border border-discord-dark bg-discord-darkest/40 p-3 text-sm text-gray-300">
            <div>Remaining: <span class="text-white font-medium">${escapeHtml(remaining)}</span></div>
            <div class="text-xs text-gray-500 mt-1">Ends: ${escapeHtml(untilLabel)}</div>
            ${reason ? `<div class="text-xs text-gray-400 mt-1">Reason: ${escapeHtml(reason)}</div>` : ''}
          </div>
          <button type="button" id="suspension-lock-ok" class="w-full py-2 rounded bg-discord-blurple hover:bg-indigo-600 font-medium">OK</button>
        </div>
      `);
      const okBtn = document.getElementById('suspension-lock-ok');
      if (okBtn) okBtn.onclick = () => modal.closeModal();
    }

    async function deleteMessagesByFilter({ channelId = null, olderThanMs = null } = {}) {
      if (!currentServerId || !currentUser?.uid) return { deleted: 0, filesDeleted: 0 };
      const srv = servers[currentServerId];
      if (srv?.ownerId !== currentUser.uid) {
        showToast('Only server owner can run bulk message cleanup', 'error');
        return { deleted: 0, filesDeleted: 0 };
      }
      const qBase = channelId
        ? query(collection(db, 'messages'), where('channelId', '==', channelId))
        : query(collection(db, 'messages'), where('serverId', '==', currentServerId));
      const snap = await getDocs(qBase);
      const cutoff = olderThanMs ? Date.now() - olderThanMs : 0;
      const targetDocs = snap.docs.filter((d) => {
        const data = d.data();
        if (!olderThanMs) return true;
        const at = data.createdAt?.toDate ? data.createdAt.toDate().getTime() : 0;
        return at > 0 && at <= cutoff;
      });
      let deleted = 0;
      let filesDeleted = 0;
      for (const d of targetDocs) {
        try {
          const result = await deleteMessageWithAttachments(d.id, d.data());
          if (result.messageDeleted) deleted++;
          filesDeleted += result.filesDeleted;
        } catch (_) {}
      }
      return { deleted, filesDeleted };
    }

    async function cleanupExpiredAttachments({ serverScoped = false } = {}) {
      if (!currentUser?.uid) return { filesDeleted: 0, messagesUpdated: 0 };
      if (serverScoped && !currentServerId) return { filesDeleted: 0, messagesUpdated: 0 };
      const now = Date.now();
      let qRef;
      if (serverScoped) {
        qRef = query(
          collection(db, 'messages'),
          where('serverId', '==', currentServerId),
          limit(300)
        );
      } else {
        qRef = query(
          collection(db, 'messages'),
          where('userId', '==', currentUser.uid),
          limit(200)
        );
      }
      const snap = await getDocs(qRef);
      let filesDeleted = 0;
      let messagesUpdated = 0;
      for (const d of snap.docs) {
        const data = d.data();
        const messageExpiry = Number(data.attachmentExpiresAt || 0);
        if (!messageExpiry || messageExpiry > now) continue;
        const currentAttachments = data.attachments || [];
        const keep = [];
        let touched = false;
        let nextExpiry = null;
        for (const att of currentAttachments) {
          const expiresAt = Number(att?.expiresAt || 0);
          const storagePath = getAttachmentStoragePath(att);
          const isExpiredManagedAttachment = !!storagePath && expiresAt > 0 && expiresAt <= now;
          if (isExpiredManagedAttachment) {
            const deleted = await deleteAttachmentFromStorage(att);
            if (deleted) filesDeleted++;
            touched = true;
            continue;
          }
          keep.push(att);
          if (storagePath && expiresAt > 0) {
            nextExpiry = nextExpiry ? Math.min(nextExpiry, expiresAt) : expiresAt;
          }
        }
        if (!touched) continue;
        try {
          await updateDoc(doc(db, 'messages', d.id), {
            attachments: keep,
            attachmentExpiresAt: nextExpiry || null,
            editedAt: serverTimestamp()
          });
          messagesUpdated++;
        } catch (_) {}
      }
      return { filesDeleted, messagesUpdated };
    }

    function startAttachmentCleanupScheduler() {
      if (attachmentCleanupInterval) clearInterval(attachmentCleanupInterval);
      cleanupExpiredAttachments().catch(() => {});
      attachmentCleanupInterval = setInterval(() => {
        cleanupExpiredAttachments().catch(() => {});
      }, ATTACHMENT_CLEANUP_INTERVAL_MS);
    }

    function stopAttachmentCleanupScheduler() {
      if (!attachmentCleanupInterval) return;
      clearInterval(attachmentCleanupInterval);
      attachmentCleanupInterval = null;
    }

    async function ensureGlobalBotProfile() {
      await setDoc(doc(db, 'users', BOT_USER_ID), {
        displayName: BOT_DISPLAY_NAME,
        bio: 'Global assistant bot powered by Mistral.',
        photoURL: '',
        isBot: true,
        status: 'online',
        updatedAt: serverTimestamp()
      }, { merge: true });
    }

    async function ensureBotMembership(serverId) {
      if (!serverId) return;
      const existing = await getDocs(query(
        collection(db, 'memberships'),
        where('serverId', '==', serverId),
        where('userId', '==', BOT_USER_ID)
      ));
      if (!existing.empty) return;
      await setDoc(doc(db, 'servers', serverId, 'members', BOT_USER_ID), { role: 'bot' }, { merge: true });
      await setDoc(doc(collection(db, 'memberships')), { serverId, userId: BOT_USER_ID, role: 'bot' });
    }

    async function sendBotMessage(serverId, channelId, text) {
      if (!serverId || !channelId || !text) return;
      await addDoc(collection(db, 'messages'), {
        serverId,
        channelId,
        userId: BOT_USER_ID,
        displayName: BOT_DISPLAY_NAME,
        photoURL: '',
        text: String(text).slice(0, 2000),
        attachments: [],
        replyTo: null,
        isBot: true,
        createdAt: serverTimestamp()
      });
    }

    async function askMistral(prompt) {
      const res = await fetch('https://api.mistral.ai/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${MISTRAL_API_KEY}`
        },
        body: JSON.stringify({
          model: BOT_MODEL,
          temperature: 0.6,
          max_tokens: 300,
          messages: [
            { role: 'system', content: 'You are a concise Discord assistant bot.' },
            { role: 'user', content: prompt }
          ]
        })
      });
      if (!res.ok) {
        const errText = await res.text();
        throw new Error(errText || `Mistral API error (${res.status})`);
      }
      const data = await res.json();
      return extractMistralText(data?.choices?.[0]?.message?.content) || 'I could not generate a response.';
    }

    async function handleBotCommand(rawText) {
      const prompt = rawText.replace(/^\/bot\s*/i, '').trim();
      if (!prompt) {
        showToast('Usage: /bot <message>', 'info');
        return true;
      }
      try {
        // Best effort only: these writes can be blocked by Firestore rules.
        ensureGlobalBotProfile().catch(() => {});
        ensureBotMembership(currentServerId).catch(() => {});
        const reply = await askMistral(prompt);
        await sendBotMessage(currentServerId, currentChannelId, reply);
      } catch (err) {
        const reason = (err?.message || 'Unknown error').replace(/\s+/g, ' ').slice(0, 140);
        showToast(`Bot failed: ${reason}`, 'error');
        await sendBotMessage(currentServerId, currentChannelId, 'Bot is currently unavailable. Please try again.');
      }
      return true;
    }

    async function kickUserFromServer(serverId, userId, reason = 'Kicked') {
      if (!serverId || !userId || userId === BOT_USER_ID) return;
      const srv = servers[serverId];
      if (srv?.ownerId === userId) return;
      const mem = Object.values(members).find(m => m.serverId === serverId && m.userId === userId);
      if (!mem) return;
      await deleteDoc(doc(db, 'servers', serverId, 'members', userId));
      await deleteDoc(doc(db, 'memberships', mem.id));
      await ensureUserPublicMembership(userId);
      showToast(reason, 'error');
    }

    async function moderateMessageIfNeeded(messageData) {
      if (!messageData || !currentUser?.uid) return;
      if (messageData.serverId === PUBLIC_SERVER_ID) return;
      if (!messageData.text || !textHasProfanity(messageData.text)) return;
      if (!isAdmin(messageData.serverId)) return;
      const offenderId = messageData.userId;
      if (!offenderId || offenderId === currentUser.uid || offenderId === BOT_USER_ID) return;
      const now = Date.now();
      const last = moderationCooldownByUser[offenderId] || 0;
      if (now - last < 30000) return;
      moderationCooldownByUser[offenderId] = now;
      try {
        await kickUserFromServer(messageData.serverId, offenderId, 'User kicked for profanity');
        if (messageData.channelId) {
          await sendBotMessage(messageData.serverId, messageData.channelId, 'A user was kicked for profanity.');
        }
      } catch (_) {}
    }

    const modal = {
      backdrop: document.getElementById('modal-backdrop'),
      title: document.getElementById('modal-title'),
      body: document.getElementById('modal-body'),
      close: document.getElementById('modal-close'),
      open(title, content) {
        this.title.textContent = title;
        this.body.innerHTML = content;
        this.backdrop.classList.remove('hidden');
        this.backdrop.style.display = 'flex';
        document.body.style.overflow = 'hidden';
      },
      closeModal() {
        this.backdrop.classList.add('hidden');
        this.backdrop.style.display = 'none';
        document.body.style.overflow = '';
        activeMemberProfileUserId = null;
      }
    };
    modal.close.onclick = () => modal.closeModal();
    modal.backdrop.onclick = (e) => { if (e.target === modal.backdrop) modal.closeModal(); };
    document.addEventListener('keydown', (e) => { if (e.key === 'Escape') modal.closeModal(); });

    async function signUp(email, password, displayName) {
      try {
        const cred = await createUserWithEmailAndPassword(auth, email, password);
        await setDoc(doc(db, 'users', cred.user.uid), {
          displayName: displayName || email.split('@')[0],
          bio: '',
          photoURL: '',
          createdAt: serverTimestamp(),
          status: 'offline'
        });
        showToast('Account created!', 'success');
        modal.closeModal();
      } catch (e) { showToast(e.message || 'Signup failed', 'error'); }
    }

    async function logIn(email, password) {
      try {
        await signInWithEmailAndPassword(auth, email, password);
        showToast('Logged in!', 'success');
        modal.closeModal();
      } catch (e) { showToast(e.message || 'Login failed', 'error'); }
    }

    async function logOut() {
      try { await updatePresence('offline'); } catch (_) {}
      stopPresenceHeartbeat();
      stopAttachmentCleanupScheduler();
      stopActiveSuspensionWatcher();
      await signOut(auth);
      currentServerId = null;
      currentChannelId = null;
      document.getElementById('auth-screen').classList.remove('hidden');
      document.getElementById('main-app').classList.add('hidden');
    }

    function renderLoginModal() {
      modal.open('Login', `
        <form id="login-form" class="space-y-4">
          <div>
            <label class="block text-sm text-gray-400 mb-1">Email</label>
            <input type="email" id="login-email" required class="w-full bg-discord-dark border border-discord-darkest rounded px-3 py-2 outline-none focus:border-discord-blurple">
          </div>
          <div>
            <label class="block text-sm text-gray-400 mb-1">Password</label>
            <input type="password" id="login-password" required class="w-full bg-discord-dark border border-discord-darkest rounded px-3 py-2 outline-none focus:border-discord-blurple">
          </div>
          <button type="submit" class="w-full py-2 bg-discord-blurple hover:bg-indigo-600 rounded font-medium">Login</button>
        </form>
      `);
      document.getElementById('login-form').onsubmit = (e) => {
        e.preventDefault();
        logIn(document.getElementById('login-email').value, document.getElementById('login-password').value);
      };
    }

    function renderSignupModal() {
      modal.open('Create Account', `
        <form id="signup-form" class="space-y-4">
          <div>
            <label class="block text-sm text-gray-400 mb-1">Display Name</label>
            <input type="text" id="signup-display" placeholder="Your name" class="w-full bg-discord-dark border border-discord-darkest rounded px-3 py-2 outline-none focus:border-discord-blurple">
          </div>
          <div>
            <label class="block text-sm text-gray-400 mb-1">Email</label>
            <input type="email" id="signup-email" required class="w-full bg-discord-dark border border-discord-darkest rounded px-3 py-2 outline-none focus:border-discord-blurple">
          </div>
          <div>
            <label class="block text-sm text-gray-400 mb-1">Password</label>
            <input type="password" id="signup-password" required minlength="6" class="w-full bg-discord-dark border border-discord-darkest rounded px-3 py-2 outline-none focus:border-discord-blurple">
          </div>
          <button type="submit" class="w-full py-2 bg-discord-blurple hover:bg-indigo-600 rounded font-medium">Create Account</button>
        </form>
      `);
      document.getElementById('signup-form').onsubmit = (e) => {
        e.preventDefault();
        signUp(document.getElementById('signup-email').value, document.getElementById('signup-password').value, document.getElementById('signup-display').value);
      };
    }

    function renderProfileModal() {
      modal.open('Edit Profile', `
        <form id="profile-form" class="space-y-4">
          <div class="flex items-center gap-4">
            <div id="profile-avatar-preview" class="w-16 h-16 rounded-full bg-discord-blurple flex items-center justify-center overflow-hidden flex-shrink-0">
              <img id="profile-avatar-img" class="w-full h-full object-cover" src="${currentUser?.photoURL || ''}" alt="" onerror="this.style.display='none'">
              <span id="profile-avatar-initial" class="text-2xl font-bold">${(currentUser?.displayName || '?')[0].toUpperCase()}</span>
            </div>
            <div class="flex-1">
              <label class="block text-sm text-gray-400 mb-1">Change Avatar</label>
              <label for="profile-avatar-input" class="inline-block px-4 py-2 rounded bg-discord-blurple hover:bg-indigo-600 text-white text-sm font-medium cursor-pointer transition">Choose Photo</label>
              <input type="file" id="profile-avatar-input" accept="image/*" class="hidden">
            </div>
          </div>
          <div>
            <label class="block text-sm text-gray-400 mb-1">Display Name</label>
            <input type="text" id="profile-display" value="${escapeHtml(currentUser?.displayName || '')}" class="w-full bg-discord-dark border border-discord-darkest rounded px-3 py-2 outline-none focus:border-discord-blurple">
          </div>
          <div>
            <label class="block text-sm text-gray-400 mb-1">About Me</label>
            <textarea id="profile-bio" rows="3" maxlength="200" placeholder="Say something about yourself" class="w-full bg-discord-dark border border-discord-darkest rounded px-3 py-2 outline-none focus:border-discord-blurple resize-none">${escapeHtml(currentUser?.bio || '')}</textarea>
          </div>
          <div class="rounded border border-discord-dark bg-discord-dark/40 p-3">
            <div class="flex items-center justify-between gap-2">
              <div>
                <div class="text-sm text-gray-200">Desktop Notifications</div>
                <div id="profile-notification-status" class="text-xs text-gray-500 mt-0.5">Permission: ${getNotificationPermissionLabel()}</div>
              </div>
              <button type="button" id="profile-notifications-toggle" class="px-3 py-1 rounded text-sm font-medium transition ${notificationsEnabled ? 'bg-discord-blurple hover:bg-indigo-600 text-white' : 'bg-discord-dark hover:bg-discord-darker text-gray-300'}">${notificationsEnabled ? 'On' : 'Off'}</button>
            </div>
          </div>
          <button type="submit" class="w-full py-2 bg-discord-blurple hover:bg-indigo-600 rounded font-medium">Save</button>
        </form>
      `);
      const img = document.getElementById('profile-avatar-img');
      const initialSpan = document.getElementById('profile-avatar-initial');
      if (currentUser?.photoURL) { img.src = currentUser.photoURL; img.style.display = 'block'; initialSpan.style.display = 'none'; }
      else { img.style.display = 'none'; initialSpan.style.display = 'flex'; }
      document.getElementById('profile-notifications-toggle').onclick = async () => {
        await setNotificationsEnabled(!notificationsEnabled);
      };
      updateNotificationToggleUI();
      document.getElementById('profile-avatar-input').onchange = async (e) => {
        const file = e.target.files?.[0];
        if (!file) return;
        try {
          const r = ref(storage, `users/${currentUser.uid}/avatar`);
          await uploadBytes(r, file);
          const url = await getDownloadURL(r);
          await updateDoc(doc(db, 'users', currentUser.uid), { photoURL: url });
          currentUser.photoURL = url;
          img.src = url; img.style.display = 'block'; document.getElementById('profile-avatar-initial').style.display = 'none';
          showToast('Avatar updated!', 'success');
        } catch (err) { showToast(err.message, 'error'); }
      };
      document.getElementById('profile-form').onsubmit = async (e) => {
        e.preventDefault();
        const name = document.getElementById('profile-display').value.trim();
        const bio = document.getElementById('profile-bio').value.trim();
        if (!name) return;
        try {
          await updateDoc(doc(db, 'users', currentUser.uid), { displayName: name, bio });
          currentUser.displayName = name;
          currentUser.bio = bio;
          updateUserPill();
          showToast('Profile updated!', 'success');
          modal.closeModal();
        } catch (err) { showToast(err.message, 'error'); }
      };
    }

    async function updatePresence(status = 'online') {
      if (!currentUser?.uid) return;
      await setDoc(doc(db, 'users', currentUser.uid), { status, lastSeen: serverTimestamp() }, { merge: true });
    }

    function startPresenceHeartbeat() {
      if (presenceInterval) clearInterval(presenceInterval);
      presenceInterval = setInterval(() => {
        if (!currentUser?.uid) return;
        updatePresence(document.hidden ? 'idle' : 'online').catch(() => {});
      }, PRESENCE_HEARTBEAT_MS);
    }

    function stopPresenceHeartbeat() {
      if (!presenceInterval) return;
      clearInterval(presenceInterval);
      presenceInterval = null;
    }

    function getEffectivePresenceStatus(userId) {
      const status = userPresence[userId] || 'offline';
      const lastSeen = memberUserData[userId]?.lastSeen;
      const seenAt = lastSeen?.toDate ? lastSeen.toDate().getTime() : (lastSeen ? new Date(lastSeen).getTime() : 0);
      if (!seenAt) return status;
      if (Date.now() - seenAt > PRESENCE_STALE_MS) return 'offline';
      return status;
    }

    function clearMemberUserListeners() {
      Object.values(memberUserUnsubs).forEach(unsub => typeof unsub === 'function' && unsub());
      memberUserUnsubs = {};
    }

    function subscribePresence(serverId) {
      if (unsubPresence) unsubPresence();
      if (!serverId) return;
      const memberIds = Object.values(members).filter(m => m.serverId === serverId).map(m => m.userId);
      if (memberIds.length === 0) return;
      const batch = memberIds.slice(0, 10);
      unsubPresence = onSnapshot(query(collection(db, 'users'), where('__name__', 'in', batch)), (snap) => {
        snap.docs.forEach(d => { userPresence[d.id] = d.data().status || 'offline'; });
        renderMembers();
      });
    }

    async function createServer(name, iconFile) {
      if (!currentUser?.uid) return;
      try {
        const serverRef = doc(collection(db, 'servers'));
        let iconUrl = '';
        if (iconFile) {
          const r = ref(storage, `servers/${serverRef.id}/icon`);
          await uploadBytes(r, iconFile);
          iconUrl = await getDownloadURL(r);
        }
        await setDoc(serverRef, { name: name || 'New Server', ownerId: currentUser.uid, icon: iconUrl, createdAt: serverTimestamp() });
        await setDoc(doc(db, 'servers', serverRef.id, 'members', currentUser.uid), { role: 'owner' });
        const chRef = doc(collection(db, 'channels'));
        await setDoc(chRef, { serverId: serverRef.id, name: 'general', createdAt: serverTimestamp() });
        await setDoc(doc(collection(db, 'memberships')), { serverId: serverRef.id, userId: currentUser.uid, role: 'owner' });
        showToast('Server created!', 'success');
        modal.closeModal();
        loadServers();
      } catch (e) { showToast(e.message, 'error'); }
    }

    function isAdmin(serverId) {
      const sid = serverId || currentServerId;
      if (!sid || !currentUser?.uid) return false;
      const srv = servers[sid];
      if (srv?.ownerId === 'system') return false;
      if (srv?.ownerId === currentUser.uid) return true;
      const mem = Object.values(members).find(m => m.serverId === sid && m.userId === currentUser.uid);
      return mem?.role === 'admin';
    }

    async function joinServerByCode(code) {
      if (!currentUser?.uid || !code) return;
      const q = query(collection(db, 'invites'), where('code', '==', code.trim().toUpperCase()));
      const snap = await getDocs(q);
      const inv = snap.docs.find(d => {
        const d_ = d.data();
        if (d_.maxUses && d_.uses >= d_.maxUses) return false;
        if (d_.expireAt?.toDate && d_.expireAt.toDate() < new Date()) return false;
        return true;
      });
      if (!inv) { showToast('Invalid or expired invite', 'error'); return; }
      const invData = inv.data();
      const bannedSnap = await getDoc(doc(db, 'servers', invData.serverId, 'banned', currentUser.uid));
      if (bannedSnap.exists()) { showToast('You are banned from this server', 'error'); return; }
      const activeSuspension = await getActiveSuspension(invData.serverId, currentUser.uid);
      if (activeSuspension) {
        showSuspensionLockModal(servers[invData.serverId]?.name || 'this server', activeSuspension);
        return;
      }
      const existing = await getDocs(query(collection(db, 'memberships'), where('serverId', '==', invData.serverId), where('userId', '==', currentUser.uid)));
      if (!existing.empty) { showToast('Already a member', 'info'); selectServer(invData.serverId); modal.closeModal(); return; }
      await setDoc(doc(db, 'servers', invData.serverId, 'members', currentUser.uid), { role: 'member' });
      await setDoc(doc(collection(db, 'memberships')), { serverId: invData.serverId, userId: currentUser.uid, role: 'member' });
      await updateDoc(doc(db, 'invites', inv.id), { uses: increment(1) });
      showToast('Joined server!', 'success');
      modal.closeModal();
      await loadServers();
      if (servers[invData.serverId]) selectServer(invData.serverId);
      else showToast('Joined, but server details could not be loaded', 'error');
    }

    async function leaveServer() {
      if (!currentServerId || !currentUser?.uid) {
        showToast('Select a server first', 'error');
        return;
      }
      if (currentServerId === PUBLIC_SERVER_ID) {
        showToast('Cannot leave the public server', 'error');
        return;
      }
      const mem = Object.values(members).find(m => m.serverId === currentServerId && m.userId === currentUser.uid);
      if (!mem) return;
      const srv = servers[currentServerId];
      if (srv?.ownerId === currentUser.uid) { showToast('Transfer ownership before leaving', 'error'); return; }
      await deleteDoc(doc(db, 'servers', currentServerId, 'members', currentUser.uid));
      await deleteDoc(doc(db, 'memberships', mem.id));
      showToast('Left server', 'info');
      currentServerId = null; currentChannelId = null;
      stopActiveSuspensionWatcher();
      loadServers();
      renderChannelList();
      renderMessages();
    }

    async function selectServer(serverId) {
      const suspension = await getActiveSuspension(serverId, currentUser?.uid);
      if (suspension) {
        const serverName = servers[serverId]?.name || 'this server';
        showSuspensionLockModal(serverName, suspension);
        if (serverId !== PUBLIC_SERVER_ID && servers[PUBLIC_SERVER_ID] && currentServerId !== PUBLIC_SERVER_ID) {
          selectServer(PUBLIC_SERVER_ID);
        }
        return;
      }
      currentServerId = serverId;
      currentChannelId = null;
      seenReportAlerts.clear();
      openReports = {};
      lastSuspensionNoticeKey = '';
      startActiveSuspensionWatcher(serverId);
      document.getElementById('current-server-name').textContent = servers[serverId]?.name || 'Server';
      loadChannels(serverId);
      loadMembers();
      document.getElementById('messages-loading').classList.remove('hidden');
      renderMessages();
    }

    async function ensurePublicServer() {
      const publicRef = doc(db, 'servers', PUBLIC_SERVER_ID);
      const publicSnap = await getDoc(publicRef);
      if (!publicSnap.exists()) {
        await setDoc(publicRef, { name: 'Public', ownerId: 'system', icon: '', createdAt: serverTimestamp() });
        const chRef = doc(collection(db, 'channels'));
        await setDoc(chRef, { serverId: PUBLIC_SERVER_ID, name: 'general', createdAt: serverTimestamp() });
      }
    }

    async function ensurePublicMembership() {
      const membershipsSnap = await getDocs(query(collection(db, 'memberships'), where('userId', '==', currentUser.uid)));
      if (!membershipsSnap.empty) return;
      await ensurePublicServer();
      await setDoc(doc(db, 'servers', PUBLIC_SERVER_ID, 'members', currentUser.uid), { role: 'member' });
      await setDoc(doc(collection(db, 'memberships')), { serverId: PUBLIC_SERVER_ID, userId: currentUser.uid, role: 'member' });
    }

    async function ensureUserPublicMembership(userId) {
      if (!userId) return;
      await ensurePublicServer();
      const existingMembership = await getDocs(query(
        collection(db, 'memberships'),
        where('serverId', '==', PUBLIC_SERVER_ID),
        where('userId', '==', userId)
      ));
      if (existingMembership.empty) {
        await setDoc(doc(collection(db, 'memberships')), { serverId: PUBLIC_SERVER_ID, userId, role: 'member' });
      }
      const publicMemberRef = doc(db, 'servers', PUBLIC_SERVER_ID, 'members', userId);
      const existingPublicMember = await getDoc(publicMemberRef);
      if (!existingPublicMember.exists()) {
        await setDoc(publicMemberRef, { role: 'member' });
      }
    }

    async function loadServers() {
      if (!currentUser?.uid) return;
      await ensurePublicMembership();
      if (unsubMyMemberships) { unsubMyMemberships(); unsubMyMemberships = null; }
      const loadVersion = ++serversLoadVersion;
      const q = query(collection(db, 'memberships'), where('userId', '==', currentUser.uid));
      unsubMyMemberships = onSnapshot(q, async (snap) => {
        if (loadVersion !== serversLoadVersion || !currentUser?.uid) return;
        const nextMembers = {};
        snap.docs.forEach(d => { nextMembers[d.id] = { id: d.id, ...d.data() }; });
        const serverIds = [...new Set(snap.docs.map(d => d.data().serverId))];
        const nextServers = {};
        const serverDocs = await Promise.all(serverIds.map(sid => getDoc(doc(db, 'servers', sid))));
        if (loadVersion !== serversLoadVersion || !currentUser?.uid) return;
        serverDocs.forEach((sDoc, i) => {
          if (sDoc.exists()) nextServers[serverIds[i]] = { id: serverIds[i], ...sDoc.data() };
        });
        servers = nextServers;
        members = nextMembers;
        renderServerList();
        if (currentServerId && !servers[currentServerId]) {
          currentServerId = null;
          currentChannelId = null;
          renderChannelList();
          renderMessages();
        }
        if (!currentServerId && Object.keys(servers).length > 0) {
          const first = servers[PUBLIC_SERVER_ID] ? PUBLIC_SERVER_ID : Object.keys(servers)[0];
          selectServer(first);
        }
      }, (err) => {
        if (loadVersion !== serversLoadVersion) return;
        showToast(err.message || 'Failed to load servers', 'error');
      });
    }

    function renderServerList() {
      const el = document.getElementById('server-list');
      el.innerHTML = '';
      const sorted = Object.values(servers).sort((a, b) => (a.id === PUBLIC_SERVER_ID ? -1 : b.id === PUBLIC_SERVER_ID ? 1 : 0));
      sorted.forEach(s => {
        const btn = document.createElement('button');
        btn.className = `w-12 h-12 rounded-2xl flex items-center justify-center overflow-hidden transition ${currentServerId === s.id ? 'rounded-xl bg-discord-blurple' : 'hover:bg-discord-blurple'}`;
        btn.title = s.name;
        if (s.icon) { btn.innerHTML = `<img src="${s.icon}" class="w-full h-full object-cover" alt="">`; }
        else { btn.textContent = (s.name || 'S')[0].toUpperCase(); btn.classList.add('bg-discord-dark'); }
        btn.onclick = () => selectServer(s.id);
        el.appendChild(btn);
      });
    }

    async function loadChannels(serverId) {
      const sid = serverId || currentServerId;
      if (!sid) return;
      if (channelUnsub) { channelUnsub(); channelUnsub = null; }
      const q = query(collection(db, 'channels'), where('serverId', '==', sid), orderBy('createdAt'));
      channelUnsub = onSnapshot(q, (snap) => {
        channels = {};
        snap.docs.forEach(d => { channels[d.id] = { id: d.id, ...d.data() }; });
        renderChannelList();
        const chIds = Object.values(channels).filter(c => c.serverId === sid).map(c => c.id);
        if (chIds.length && currentServerId === sid && !currentChannelId) {
          selectChannel(chIds[0]);
        } else if (chIds.length === 0 && currentServerId === sid) {
          currentChannelId = null;
          document.getElementById('messages-loading').classList.add('hidden');
          renderMessages();
        }
      }, (err) => {
        document.getElementById('messages-loading').classList.add('hidden');
        showToast(err.message || 'Failed to load channels', 'error');
      });
    }

    function renderChannelList() {
      const el = document.getElementById('channel-list');
      el.innerHTML = '';
      Object.values(channels).filter(c => c.serverId === currentServerId).forEach(ch => {
        const btn = document.createElement('button');
        btn.className = `w-full text-left px-2 py-1.5 rounded flex items-center gap-2 text-sm ${currentChannelId === ch.id ? 'bg-discord-dark text-white' : 'text-gray-400 hover:bg-discord-dark hover:text-white'}`;
        btn.innerHTML = `<span>#</span><span class="truncate">${escapeHtml(ch.name)}</span>`;
        btn.onclick = () => selectChannel(ch.id);
        el.appendChild(btn);
      });
    }

    async function createChannel(name) {
      if (!currentServerId || !currentUser?.uid) return;
      if (!isAdmin()) { showToast('Admin only', 'error'); return; }
      try {
        const chRef = doc(collection(db, 'channels'));
        await setDoc(chRef, { serverId: currentServerId, name: (name || 'new-channel').replace(/\s/g, '-').toLowerCase(), createdAt: serverTimestamp() });
        showToast('Channel created!', 'success');
        modal.closeModal();
      } catch (e) { showToast(e.message, 'error'); }
    }

    async function deleteChannel(channelId) {
      if (!channelId) return;
      const ch = channels[channelId];
      if (!ch || ch.serverId !== currentServerId) return;
      if (!isAdmin()) { showToast('Admin only', 'error'); return; }
      try {
        const msgs = await getDocs(query(collection(db, 'messages'), where('channelId', '==', channelId)));
        for (const m of msgs.docs) await deleteMessageWithAttachments(m.id, m.data());
        await deleteDoc(doc(db, 'channels', channelId));
        showToast('Channel deleted', 'info');
        if (currentChannelId === channelId) { currentChannelId = null; selectServer(currentServerId); }
        modal.closeModal();
      } catch (e) { showToast(e.message, 'error'); }
    }

    function selectChannel(channelId) {
      currentChannelId = channelId;
      const ch = channels[channelId];
      document.getElementById('channel-header-name').textContent = ch ? `# ${ch.name}` : '# general';
      document.getElementById('message-input').placeholder = `Message #${ch?.name || 'general'}`;
      document.getElementById('message-input-area').style.display = currentChannelId ? 'block' : 'none';
      renderMessages();
      subscribeMessages();
      subscribeTyping();
    }

    function subscribeMessages() {
      messageListeners.forEach(u => typeof u === 'function' && u());
      messageListeners = messageListeners.filter(() => false);
      if (!currentChannelId) return;
      document.getElementById('messages-loading').classList.remove('hidden');
      let initialSnapshotLoaded = false;
      const q = query(
        collection(db, 'messages'),
        where('channelId', '==', currentChannelId),
        orderBy('createdAt', 'desc'),
        limit(MESSAGE_LIMIT)
      );
      const unsub = onSnapshot(q, (snap) => {
        if (initialSnapshotLoaded) {
          snap.docChanges().forEach((change) => {
            if (change.type === 'added') {
              const data = change.doc.data();
              maybeNotifyForMessage(change.doc.id, data);
              moderateMessageIfNeeded(data);
            }
          });
        } else {
          initialSnapshotLoaded = true;
        }
        messages = {};
        snap.docs.forEach(d => { messages[d.id] = { id: d.id, ...d.data() }; });
        lastDoc = snap.docs[snap.docs.length - 1];
        document.getElementById('load-more').classList.toggle('hidden', !lastDoc || snap.docs.length < MESSAGE_LIMIT);
        renderMessages();
        document.getElementById('messages-loading').classList.add('hidden');
      }, (err) => {
        document.getElementById('messages-loading').classList.add('hidden');
        showToast(err.message || 'Failed to load messages', 'error');
      });
      messageListeners.push(unsub);
    }

    async function loadOlderMessages() {
      if (!currentChannelId || !lastDoc) return;
      const q = query(
        collection(db, 'messages'),
        where('channelId', '==', currentChannelId),
        orderBy('createdAt', 'desc'),
        startAfter(lastDoc),
        limit(MESSAGE_LIMIT)
      );
      const snap = await getDocs(q);
      snap.docs.forEach(d => { messages[d.id] = { id: d.id, ...d.data() }; });
      lastDoc = snap.docs[snap.docs.length - 1];
      document.getElementById('load-more').classList.toggle('hidden', !lastDoc || snap.docs.length < MESSAGE_LIMIT);
      renderMessages();
    }

    function renderMessages() {
      const list = document.getElementById('messages-list');
      const loadingEl = document.getElementById('messages-loading');
      list.innerHTML = '';
      if (!currentChannelId) {
        loadingEl.classList.add('hidden');
        list.innerHTML = '<div class="text-center text-gray-500 py-12">Select a channel</div>';
        return;
      }
      const arr = Object.values(messages).filter(m => m.channelId === currentChannelId).sort((a, b) => (a.createdAt?.toDate?.() || 0) - (b.createdAt?.toDate?.() || 0));
      let prevUserId = null;
      arr.forEach((m) => {
        const liveUser = memberUserData[m.userId] || {};
        const displayName = getUserDisplayName(liveUser, m) || 'Unknown';
        const isBot = m.userId === BOT_USER_ID || liveUser?.isBot || m.isBot;
        const avatarUrl = (liveUser.photoURL || m.photoURL || '').trim();
        const isOwn = m.userId === currentUser?.uid;
        const showAvatar = prevUserId !== m.userId || isOwn;
        prevUserId = m.userId;
        const div = document.createElement('div');
        div.className = `message-group group flex gap-4 px-4 py-1 pl-1 ${isOwn ? 'flex-row-reverse justify-end' : ''}`;
        const avatar = showAvatar ? `<div class="w-10 h-10 rounded-full bg-discord-blurple flex-shrink-0 flex items-center justify-center overflow-hidden">
          ${avatarUrl
            ? `<img src="${escapeHtml(avatarUrl)}" class="w-full h-full object-cover" alt="" onerror="this.style.display='none';this.nextElementSibling.style.display='flex'"><span class="hidden text-sm font-bold">${displayName[0].toUpperCase()}</span>`
            : `<span class="text-sm font-bold">${displayName[0].toUpperCase()}</span>`
          }
        </div>` : '<div class="w-10 flex-shrink-0"></div>';
        const time = formatTime(m.createdAt);
        const edited = m.editedAt ? ' <span class="text-xs text-gray-500">(edited)</span>' : '';
        let content = escapeHtml(m.text || '');
        (m.attachments || []).forEach((att, index) => {
          if (!att?.url) return;
          const safeUrl = escapeHtml(att.url);
          const fileName = escapeHtml(att.name || `Attachment ${index + 1}`);
          const sizeText = formatFileSize(att.size);
          if (isImageAttachment(att)) {
            content += `<div class="mt-2">
              <a href="${safeUrl}" target="_blank" rel="noopener noreferrer">
                <img src="${safeUrl}" class="max-w-sm max-h-64 rounded cursor-pointer" alt="${fileName}">
              </a>
              <a href="${safeUrl}" target="_blank" rel="noopener noreferrer" download="${fileName}" class="text-xs text-discord-blurple hover:underline">${fileName}</a>
            </div>`;
          } else {
            content += `<div class="mt-2 max-w-sm rounded border border-discord-dark bg-discord-darkest/60 p-3">
              <div class="text-sm text-gray-200 truncate">${fileName}</div>
              <div class="text-xs text-gray-500">${sizeText || 'File'}</div>
              <a href="${safeUrl}" target="_blank" rel="noopener noreferrer" download="${fileName}" class="text-xs text-discord-blurple hover:underline">Download</a>
            </div>`;
          }
        });
        const adminDelBtn = isAdmin() ? `<button type="button" class="opacity-0 group-hover:opacity-100 ml-1 text-xs text-discord-red hover:underline transition" data-delete-msg="${m.id}" title="Delete message">Delete</button>` : '';
        const replyBtn = `<button type="button" class="opacity-0 group-hover:opacity-100 ml-1 text-xs text-discord-blurple hover:underline transition" data-reply-msg="${m.id}" title="Reply">Reply</button>`;
        const canReportUser = !isOwn && m.userId !== BOT_USER_ID;
        const reportBtn = canReportUser ? `<button type="button" class="opacity-0 group-hover:opacity-100 ml-1 text-xs text-amber-400 hover:underline transition" data-report-msg-user="${m.userId}" title="Report user">Report</button>` : '';
        const replyPreview = m.replyTo ? `<div class="mb-1 py-1 px-2 rounded border-l-2 border-discord-blurple/50 bg-discord-darkest/50 text-xs"><span class="text-discord-blurple">${escapeHtml(m.replyTo.displayName || 'Unknown')}</span><span class="text-gray-500">: </span><span class="text-gray-400 truncate">${escapeHtml((m.replyTo.text || '').slice(0, 80))}${(m.replyTo.text || '').length > 80 ? '...' : ''}</span></div>` : '';
        const botBadge = isBot ? '<span class="text-[10px] px-1.5 py-0.5 rounded bg-discord-blurple text-white font-bold align-middle">BOT</span>' : '';
        const msgContent = `<div class="flex-1 min-w-0 max-w-[75%] ${isOwn ? 'text-right' : ''}"><div class="flex items-baseline gap-2 flex-wrap ${isOwn ? 'justify-end' : ''}"><span class="font-semibold text-white">${escapeHtml(displayName)}</span>${botBadge}<span class="text-xs text-gray-500">${time}</span>${edited}${replyBtn}${reportBtn}${adminDelBtn}</div>${replyPreview}<div class="text-gray-300 break-words ${isOwn ? 'bg-discord-blurple/30 rounded-lg px-3 py-2 inline-block' : ''}">${content}</div></div>`;
        div.innerHTML = `${avatar}${msgContent}`;
        list.appendChild(div);
        const delBtn = div.querySelector('[data-delete-msg]');
        if (delBtn) delBtn.onclick = () => { if (confirm('Delete this message?')) deleteAnyMessage(m.id); };
        const replyBtnEl = div.querySelector('[data-reply-msg]');
        if (replyBtnEl) replyBtnEl.onclick = () => {
          replyingTo = { id: m.id, userId: m.userId, displayName, text: (m.text || '').slice(0, 100) };
          document.getElementById('reply-preview').classList.remove('hidden');
          document.getElementById('reply-preview-name').textContent = replyingTo.displayName;
          document.getElementById('reply-preview-text').textContent = replyingTo.text || '(attachment)';
          document.getElementById('message-input').focus();
        };
        const reportBtnEl = div.querySelector('[data-report-msg-user]');
        if (reportBtnEl) reportBtnEl.onclick = () => renderReportUserModal(reportBtnEl.dataset.reportMsgUser);
      });
      list.scrollTop = list.scrollHeight;
    }

    async function sendMessage() {
      const input = document.getElementById('message-input');
      const text = input.value.trim();
      if (!currentChannelId || !currentUser?.uid) {
        showToast('Select a channel first', 'error');
        return;
      }
      const activeSuspension = await getActiveSuspension(currentServerId, currentUser.uid);
      if (activeSuspension) {
        showSuspensionLockModal(servers[currentServerId]?.name || 'this server', activeSuspension);
        return;
      }
      if (!text && pendingAttachments.length === 0) return;
      if (text.toLowerCase().startsWith('/bot')) {
        input.value = '';
        await handleBotCommand(text);
        return;
      }
      try {
        const expiringAttachments = pendingAttachments.filter(att => getAttachmentStoragePath(att) && Number(att.expiresAt) > 0);
        const nextAttachmentExpiry = expiringAttachments.length
          ? Math.min(...expiringAttachments.map(att => Number(att.expiresAt)))
          : null;
        const msg = {
          serverId: currentServerId,
          channelId: currentChannelId,
          userId: currentUser.uid,
          displayName: currentUser.displayName || 'User',
          photoURL: currentUser.photoURL || '',
          text: text || '',
          attachments: [...pendingAttachments],
          attachmentExpiresAt: nextAttachmentExpiry,
          replyTo: replyingTo ? { messageId: replyingTo.id, userId: replyingTo.userId, displayName: replyingTo.displayName, text: replyingTo.text } : null,
          createdAt: serverTimestamp()
        };
        await addDoc(collection(db, 'messages'), msg);
        input.value = '';
        pendingAttachments = [];
        replyingTo = null;
        document.getElementById('reply-preview').classList.add('hidden');
        document.getElementById('attachment-preview').classList.add('hidden');
        document.getElementById('attachment-preview').innerHTML = '';
        updateTyping(false);
      } catch (e) {
        showToast(e.message || 'Failed to send message', 'error');
        console.error('Send error:', e);
      }
    }

    let typingTimeout;
    async function updateTyping(typing) {
      if (!currentChannelId || !currentUser?.uid) return;
      try {
        const refPath = doc(db, 'channels', currentChannelId, 'typing', currentUser.uid);
        if (typing) {
          await setDoc(refPath, { userId: currentUser.uid, displayName: currentUser.displayName, at: serverTimestamp() });
          clearTimeout(typingTimeout);
          typingTimeout = setTimeout(() => updateTyping(false), 5000);
        } else {
          await deleteDoc(refPath);
        }
      } catch (_) {}
    }

    function subscribeTyping() {
      if (!currentChannelId) return;
      const unsub = onSnapshot(collection(db, 'channels', currentChannelId, 'typing'), (snap) => {
        typingUsers = {};
        snap.docs.forEach(d => {
          const d_ = d.data();
          if (d_.userId !== currentUser?.uid) typingUsers[d_.userId] = d_.displayName;
        });
        const names = Object.values(typingUsers);
        const el = document.getElementById('typing-indicator');
        el.classList.toggle('hidden', names.length === 0);
        document.getElementById('typing-users').textContent = names.length ? `${names.slice(0, 2).join(', ')}${names.length > 2 ? ' and others' : ''} typing` : '';
      });
      messageListeners.push(unsub);
    }

    async function createInvite() {
      if (!currentServerId || !currentUser?.uid) {
        showToast('Select a server first', 'error');
        return;
      }
      const code = Math.random().toString(36).slice(2, 10).toUpperCase();
      try {
        await addDoc(collection(db, 'invites'), {
          serverId: currentServerId,
          code,
          createdBy: currentUser.uid,
          uses: 0,
          maxUses: null,
          expireAt: null
        });
        modal.open('Invite Link', `
          <p class="text-gray-300 mb-4">Share this code to invite people:</p>
          <p class="text-2xl font-mono bg-discord-dark p-4 rounded text-center">${code}</p>
          <p class="text-sm text-gray-500 mt-2">Or share: ${window.location.origin}${window.location.pathname}?invite=${code}</p>
        `);
      } catch (e) { showToast(e.message, 'error'); }
    }

    function renderJoinModal() {
      const needLogin = !currentUser?.uid;
      modal.open('Join Server', `
        ${needLogin ? '<p class="text-amber-400 text-sm mb-4">Log in or create an account first to join a server.</p>' : ''}
        <form id="join-form" class="space-y-4">
          <div>
            <label class="block text-sm text-gray-400 mb-1">Invite Code</label>
            <input type="text" id="invite-code" placeholder="e.g. ABC123XY" class="w-full bg-discord-dark border border-discord-darkest rounded px-3 py-2 outline-none focus:border-discord-blurple uppercase">
          </div>
          <button type="submit" class="w-full py-2 bg-discord-blurple hover:bg-indigo-600 rounded font-medium">Join</button>
          ${needLogin ? '<button type="button" id="join-login-btn" class="w-full py-2 bg-discord-dark hover:bg-discord-darker rounded font-medium mt-2">Log In</button>' : ''}
        </form>
      `);
      document.getElementById('join-form').onsubmit = (e) => {
        e.preventDefault();
        if (needLogin) { showToast('Please log in first', 'error'); modal.closeModal(); renderLoginModal(); return; }
        joinServerByCode(document.getElementById('invite-code').value);
      };
      const params = new URLSearchParams(location.search);
      const invite = params.get('invite');
      if (invite) document.getElementById('invite-code').value = invite;
      const loginBtn = document.getElementById('join-login-btn');
      if (loginBtn) loginBtn.onclick = () => { modal.closeModal(); renderLoginModal(); };
    }

    async function banUser(userId) {
      if (!currentServerId || !isAdmin()) return;
      const srv = servers[currentServerId];
      if (srv?.ownerId === userId) { showToast('Cannot ban server owner', 'error'); return; }
      const mem = Object.values(members).find(m => m.serverId === currentServerId && m.userId === userId);
      if (!mem) return;
      try {
        await setDoc(doc(db, 'servers', currentServerId, 'banned', userId), { bannedBy: currentUser.uid, bannedAt: serverTimestamp() });
        await deleteDoc(doc(db, 'servers', currentServerId, 'members', userId));
        await deleteDoc(doc(db, 'memberships', mem.id));
        showToast('User banned', 'success');
        loadMembers();
        modal.closeModal();
      } catch (e) { showToast(e.message, 'error'); }
    }

    async function kickUser(userId) {
      if (!currentServerId || !isAdmin()) return;
      const srv = servers[currentServerId];
      if (srv?.ownerId === userId) { showToast('Cannot kick server owner', 'error'); return; }
      const mem = Object.values(members).find(m => m.serverId === currentServerId && m.userId === userId);
      if (!mem) return;
      try {
        await deleteDoc(doc(db, 'servers', currentServerId, 'members', mem.userId));
        await deleteDoc(doc(db, 'memberships', mem.id));
        await ensureUserPublicMembership(userId);
        showToast('User kicked', 'success');
        loadMembers();
        modal.closeModal();
      } catch (e) { showToast(e.message, 'error'); }
    }

    async function suspendUser(userId, durationMs, reason = '') {
      if (!currentServerId || !isAdmin()) return;
      if (!durationMs || durationMs <= 0) { showToast('Set a valid suspension duration', 'error'); return; }
      const srv = servers[currentServerId];
      if (srv?.ownerId === userId) { showToast('Cannot suspend server owner', 'error'); return; }
      if (userId === BOT_USER_ID) { showToast('Cannot suspend bot account', 'error'); return; }
      const mem = Object.values(members).find(m => m.serverId === currentServerId && m.userId === userId);
      if (!mem) { showToast('User is not in this server', 'error'); return; }
      const untilMs = Date.now() + durationMs;
      try {
        await setDoc(doc(db, 'servers', currentServerId, 'suspended', userId), {
          userId,
          reason: (reason || '').trim().slice(0, 200),
          suspendedBy: currentUser.uid,
          suspendedAt: serverTimestamp(),
          untilMs
        }, { merge: true });
        showToast('User suspended', 'success');
      } catch (e) {
        showToast(e.message || 'Failed to suspend user', 'error');
      }
    }

    function renderSuspendUserModal(userId) {
      if (!currentServerId || !isAdmin()) return;
      const mem = Object.values(members).find(m => m.serverId === currentServerId && m.userId === userId);
      const ud = memberUserData[userId] || {};
      const displayName = getUserDisplayName(ud, mem) || 'Unknown';
      modal.open('Suspend User', `
        <form id="suspend-user-form" class="space-y-4">
          <p class="text-sm text-gray-300">Suspend <span class="text-white font-medium">${escapeHtml(displayName)}</span> from this server.</p>
          <div class="flex items-center gap-2">
            <input id="suspend-duration-value" type="number" min="1" value="1" class="w-24 bg-discord-dark border border-discord-darkest rounded px-3 py-2 outline-none focus:border-discord-blurple">
            <select id="suspend-duration-unit" class="bg-discord-dark border border-discord-darkest rounded px-3 py-2 outline-none focus:border-discord-blurple">
              <option value="hours">hours</option>
              <option value="minutes">minutes</option>
              <option value="days">days</option>
            </select>
          </div>
          <div>
            <label class="block text-sm text-gray-400 mb-1">Reason (optional)</label>
            <textarea id="suspend-reason" rows="3" maxlength="200" placeholder="Why is this user suspended?" class="w-full bg-discord-dark border border-discord-darkest rounded px-3 py-2 outline-none focus:border-discord-blurple resize-none"></textarea>
          </div>
          <button type="submit" class="w-full py-2 rounded bg-amber-700 hover:bg-amber-600 font-medium">Apply Suspension</button>
        </form>
      `);
      document.getElementById('suspend-user-form').onsubmit = async (e) => {
        e.preventDefault();
        const value = document.getElementById('suspend-duration-value').value;
        const unit = document.getElementById('suspend-duration-unit').value;
        const reason = document.getElementById('suspend-reason').value;
        const durationMs = getDurationMs(value, unit);
        await suspendUser(userId, durationMs, reason);
        modal.closeModal();
        renderAdminModal();
      };
    }

    async function makeAdmin(userId) {
      if (!currentServerId || !currentUser?.uid) return;
      const srv = servers[currentServerId];
      if (srv?.ownerId !== currentUser.uid) { showToast('Only owner can make admins', 'error'); return; }
      const mem = Object.values(members).find(m => m.serverId === currentServerId && m.userId === userId);
      if (!mem) return;
      try {
        await updateDoc(doc(db, 'memberships', mem.id), { role: 'admin' });
        await setDoc(doc(db, 'servers', currentServerId, 'members', userId), { role: 'admin' }, { merge: true });
        members[mem.id].role = 'admin';
        showToast('User is now admin', 'success');
        loadMembers();
        renderAdminModal();
      } catch (e) { showToast(e.message, 'error'); }
    }

    async function removeAdmin(userId) {
      if (!currentServerId || !currentUser?.uid) return;
      const srv = servers[currentServerId];
      if (srv?.ownerId !== currentUser.uid) { showToast('Only owner can remove admins', 'error'); return; }
      const mem = Object.values(members).find(m => m.serverId === currentServerId && m.userId === userId);
      if (!mem) return;
      try {
        await updateDoc(doc(db, 'memberships', mem.id), { role: 'member' });
        await setDoc(doc(db, 'servers', currentServerId, 'members', userId), { role: 'member' }, { merge: true });
        members[mem.id].role = 'member';
        showToast('Admin removed', 'success');
        loadMembers();
        renderAdminModal();
      } catch (e) { showToast(e.message, 'error'); }
    }

    async function deleteAnyMessage(msgId) {
      if (!isAdmin()) return;
      try {
        const result = await deleteMessageWithAttachments(msgId);
        showToast(`Message deleted (${result.filesDeleted} file(s) removed)`, 'success');
      } catch (e) { showToast(e.message, 'error'); }
    }

    function renderAdminModal() {
      if (!isAdmin()) return;
      const srv = servers[currentServerId];
      const isOwner = srv?.ownerId === currentUser?.uid;
      const memberRows = Object.values(members).filter(m => m.serverId === currentServerId).map(m => {
        const ud = memberUserData[m.userId] || {};
        const displayName = getUserDisplayName(ud, m) || 'Unknown';
        const isOwnerMember = m.userId === srv?.ownerId;
        const canMod = !isOwnerMember && (isOwner || (m.role !== 'owner' && m.role !== 'admin'));
        const roleLabel = isOwnerMember ? 'Owner' : m.role === 'admin' ? 'Admin' : 'Member';
        return `
          <div class="flex items-center justify-between py-2 border-b border-discord-dark">
            <div class="flex items-center gap-2">
              <div class="w-8 h-8 rounded-full bg-discord-blurple flex items-center justify-center overflow-hidden">
                <img src="${ud.photoURL || ''}" class="w-full h-full object-cover" alt="" onerror="this.style.display='none';this.nextElementSibling.style.display='flex'">
                <span class="hidden text-xs font-bold">${displayName[0].toUpperCase()}</span>
              </div>
              <div>
                <span class="font-medium">${escapeHtml(displayName)}</span>
                <span class="text-xs text-gray-500 ml-2">${roleLabel}</span>
              </div>
            </div>
            ${canMod ? `
              <div class="flex gap-1">
                ${isOwner && m.role !== 'admin' ? `<button type="button" class="text-xs px-2 py-1 rounded bg-discord-blurple hover:bg-indigo-600" data-make-admin="${m.userId}">Make Admin</button>` : ''}
                ${isOwner && m.role === 'admin' ? `<button type="button" class="text-xs px-2 py-1 rounded bg-discord-dark hover:bg-discord-red" data-remove-admin="${m.userId}">Remove Admin</button>` : ''}
                <button type="button" class="text-xs px-2 py-1 rounded bg-discord-dark hover:bg-amber-600" data-suspend="${m.userId}">Suspend</button>
                <button type="button" class="text-xs px-2 py-1 rounded bg-discord-dark hover:bg-amber-600" data-kick="${m.userId}">Kick</button>
                <button type="button" class="text-xs px-2 py-1 rounded bg-discord-dark hover:bg-discord-red" data-ban="${m.userId}">Ban</button>
              </div>
            ` : ''}
          </div>
        `;
      }).join('');
      const channelRows = Object.values(channels).filter(c => c.serverId === currentServerId).map(ch => `
        <div class="flex items-center justify-between py-2 border-b border-discord-dark">
          <span class="text-gray-300"># ${escapeHtml(ch.name)}</span>
          <button type="button" class="text-xs px-2 py-1 rounded bg-discord-dark hover:bg-discord-red" data-delete-channel="${ch.id}">Delete</button>
        </div>
      `).join('');
      modal.open('Server Admin', `
        <div class="space-y-6">
          <div>
            <h3 class="text-sm font-semibold text-gray-400 mb-2">Manage Members</h3>
            <div class="max-h-48 overflow-y-auto space-y-0">${memberRows || '<p class="text-gray-500 py-2">No members</p>'}</div>
          </div>
          <div>
            <h3 class="text-sm font-semibold text-gray-400 mb-2">Channels</h3>
            <div class="space-y-0">${channelRows || '<p class="text-gray-500 py-2">No channels</p>'}</div>
            <button type="button" id="admin-create-channel" class="mt-2 text-sm px-3 py-1.5 rounded bg-discord-blurple hover:bg-indigo-600">+ Create Channel</button>
          </div>
          <div>
            <h3 class="text-sm font-semibold text-gray-400 mb-2">Reports Inbox</h3>
            <div id="admin-reports-inbox" class="max-h-60 overflow-y-auto space-y-2"><p class="text-gray-500 py-2">Loading reports...</p></div>
          </div>
          ${isOwner ? `
            <div>
              <h3 class="text-sm font-semibold text-gray-400 mb-2">Message Cleanup (Owner)</h3>
              <div class="space-y-3 rounded border border-discord-dark bg-discord-darkest/40 p-3">
                <div class="flex flex-wrap items-center gap-2">
                  <select id="admin-cleanup-scope" class="bg-discord-dark border border-discord-darkest rounded px-2 py-1 text-sm">
                    <option value="channel">Current Channel</option>
                    <option value="server">Whole Server</option>
                  </select>
                  <input id="admin-cleanup-age-value" type="number" min="1" value="24" class="w-20 bg-discord-dark border border-discord-darkest rounded px-2 py-1 text-sm">
                  <select id="admin-cleanup-age-unit" class="bg-discord-dark border border-discord-darkest rounded px-2 py-1 text-sm">
                    <option value="hours">hours</option>
                    <option value="minutes">minutes</option>
                    <option value="days">days</option>
                  </select>
                </div>
                <div class="flex flex-wrap gap-2">
                  <button type="button" id="admin-delete-older" class="text-xs px-3 py-1.5 rounded bg-amber-700 hover:bg-amber-600">Delete Older Than</button>
                  <button type="button" id="admin-reset-messages" class="text-xs px-3 py-1.5 rounded bg-discord-red hover:bg-red-500">Reset Messages</button>
                  <button type="button" id="admin-clean-expired-files" class="text-xs px-3 py-1.5 rounded bg-discord-dark hover:bg-discord-darker">Delete Expired Files Now</button>
                </div>
              </div>
            </div>
          ` : ''}
        </div>
      `);
      document.querySelectorAll('[data-ban]').forEach(btn => btn.onclick = () => banUser(btn.dataset.ban));
      document.querySelectorAll('[data-kick]').forEach(btn => btn.onclick = () => kickUser(btn.dataset.kick));
      document.querySelectorAll('[data-suspend]').forEach(btn => btn.onclick = () => renderSuspendUserModal(btn.dataset.suspend));
      document.querySelectorAll('[data-make-admin]').forEach(btn => btn.onclick = () => makeAdmin(btn.dataset.makeAdmin));
      document.querySelectorAll('[data-remove-admin]').forEach(btn => btn.onclick = () => removeAdmin(btn.dataset.removeAdmin));
      document.querySelectorAll('[data-delete-channel]').forEach(btn => btn.onclick = () => {
        if (confirm('Delete this channel?')) deleteChannel(btn.dataset.deleteChannel);
      });
      document.getElementById('admin-create-channel').onclick = () => { modal.closeModal(); renderCreateChannelModal(); };
      fetchOpenReportsForCurrentServer()
        .then(() => renderAdminReportsInbox())
        .catch(() => {
          const host = document.getElementById('admin-reports-inbox');
          if (host) host.innerHTML = '<p class="text-discord-red text-sm py-2">Failed to load reports</p>';
        });
      if (isOwner) {
        document.getElementById('admin-delete-older').onclick = async () => {
          const scope = document.getElementById('admin-cleanup-scope').value;
          const ageValue = document.getElementById('admin-cleanup-age-value').value;
          const ageUnit = document.getElementById('admin-cleanup-age-unit').value;
          const olderThanMs = getDurationMs(ageValue, ageUnit);
          if (!olderThanMs) { showToast('Enter a valid age value', 'error'); return; }
          if (scope === 'channel' && !currentChannelId) { showToast('Select a channel first', 'error'); return; }
          const targetText = scope === 'server' ? 'entire server' : 'current channel';
          if (!confirm(`Delete messages older than ${ageValue} ${ageUnit} in ${targetText}?`)) return;
          try {
            const result = await deleteMessagesByFilter({
              channelId: scope === 'channel' ? currentChannelId : null,
              olderThanMs
            });
            showToast(`Deleted ${result.deleted} message(s), removed ${result.filesDeleted} file(s)`, 'success');
          } catch (err) {
            showToast(err?.message || 'Cleanup failed', 'error');
          }
        };
        document.getElementById('admin-reset-messages').onclick = async () => {
          const scope = document.getElementById('admin-cleanup-scope').value;
          if (scope === 'channel' && !currentChannelId) { showToast('Select a channel first', 'error'); return; }
          const targetText = scope === 'server' ? 'entire server' : 'current channel';
          if (!confirm(`Reset all messages in ${targetText}? This cannot be undone.`)) return;
          try {
            const result = await deleteMessagesByFilter({
              channelId: scope === 'channel' ? currentChannelId : null,
              olderThanMs: null
            });
            showToast(`Reset complete: ${result.deleted} message(s), ${result.filesDeleted} file(s) removed`, 'success');
            modal.closeModal();
          } catch (err) {
            showToast(err?.message || 'Reset failed', 'error');
          }
        };
        document.getElementById('admin-clean-expired-files').onclick = async () => {
          try {
            const result = await cleanupExpiredAttachments({ serverScoped: true });
            showToast(`Expired cleanup: ${result.messagesUpdated} message(s), ${result.filesDeleted} file(s)`, 'info');
          } catch (err) {
            showToast(err?.message || 'Expired cleanup failed', 'error');
          }
        };
      }
    }

    function updateAdminButtonVisibility() {
      const btn = document.getElementById('btn-admin-menu');
      if (!btn) return;
      if (isAdmin()) { btn.classList.remove('hidden'); btn.onclick = renderAdminModal; }
      else { btn.classList.add('hidden'); }
      subscribeReports();
    }

    async function loadMembers() {
      if (!currentServerId) return;
      const serverId = currentServerId;
      const loadVersion = ++membersLoadVersion;
      if (unsubMembers) { unsubMembers(); unsubMembers = null; }
      if (unsubReports) { unsubReports(); unsubReports = null; }
      reportAlertInitialized = false;
      clearMemberUserListeners();
      members = {};
      memberUserData = {};
      userPresence = {};
      renderMembers();
      updateAdminButtonVisibility();
      const q = query(collection(db, 'memberships'), where('serverId', '==', serverId));
      unsubMembers = onSnapshot(q, (snap) => {
        if (loadVersion !== membersLoadVersion || serverId !== currentServerId) return;
        const nextMembers = {};
        snap.docs.forEach(d => { nextMembers[d.id] = { id: d.id, ...d.data() }; });
        members = nextMembers;
        const userIds = [...new Set(Object.values(nextMembers).map(m => m.userId))];
        const userIdSet = new Set(userIds);
        Object.keys(memberUserUnsubs).forEach((uid) => {
          if (!userIdSet.has(uid)) {
            memberUserUnsubs[uid]();
            delete memberUserUnsubs[uid];
            delete memberUserData[uid];
            delete userPresence[uid];
          }
        });
        userIds.forEach((uid) => {
          if (memberUserUnsubs[uid]) return;
          memberUserUnsubs[uid] = onSnapshot(doc(db, 'users', uid), (u) => {
            if (loadVersion !== membersLoadVersion || serverId !== currentServerId) return;
            if (u.exists()) {
              const data = u.data();
              memberUserData[uid] = data;
              userPresence[uid] = data.status || 'offline';
            } else {
              delete memberUserData[uid];
              delete userPresence[uid];
            }
            renderMembers();
            renderMessages();
            if (activeMemberProfileUserId === uid) renderMemberProfileModal(uid);
            updateAdminButtonVisibility();
          });
        });
        renderMembers();
        updateAdminButtonVisibility();
      }, (err) => {
        if (loadVersion !== membersLoadVersion || serverId !== currentServerId) return;
        showToast(err.message || 'Failed to load members', 'error');
      });
    }

    function renderMemberProfileModal(userId) {
      activeMemberProfileUserId = userId;
      const memberData = memberUserData[userId] || {};
      const memberRole = Object.values(members).find(m => m.serverId === currentServerId && m.userId === userId);
      const name = getUserDisplayName(memberData, memberRole) || 'Unknown';
      const bio = (memberData?.bio || '').trim();
      const role = servers[currentServerId]?.ownerId === userId ? 'Owner' : memberRole?.role === 'admin' ? 'Admin' : 'Member';
      const canReport = !!currentUser?.uid && userId !== currentUser.uid && userId !== BOT_USER_ID;
      modal.open('Member Profile', `
        <div class="space-y-4">
          <div class="flex items-center gap-3">
            <div class="w-14 h-14 rounded-full bg-discord-blurple flex items-center justify-center overflow-hidden">
              <img src="${memberData.photoURL || ''}" class="w-full h-full object-cover" alt="" onerror="this.style.display='none';this.nextElementSibling.style.display='flex'">
              <span class="hidden text-lg font-bold">${name[0].toUpperCase()}</span>
            </div>
            <div>
              <div class="text-lg font-semibold text-white">${escapeHtml(name)}</div>
              <div class="text-xs text-gray-500">${role}</div>
            </div>
          </div>
          <div>
            <div class="text-xs uppercase tracking-wide text-gray-500 mb-1">About</div>
            <div class="text-sm text-gray-300 bg-discord-dark rounded p-3">${escapeHtml(bio || 'No description set.')}</div>
          </div>
          ${canReport ? '<button type="button" id="profile-report-user" class="w-full py-2 rounded bg-discord-red hover:bg-red-500 text-sm font-medium">Report User</button>' : ''}
        </div>
      `);
      const reportBtn = document.getElementById('profile-report-user');
      if (reportBtn) reportBtn.onclick = () => renderReportUserModal(userId);
    }

    function renderMembers() {
      const el = document.getElementById('members-list');
      el.innerHTML = '';
      const srv = servers[currentServerId];
      Object.values(members)
        .filter(m => m.serverId === currentServerId && m.userId !== currentUser?.uid)
        .forEach(m => {
          const ud = memberUserData[m.userId] || {};
          const status = getEffectivePresenceStatus(m.userId);
          const displayName = getUserDisplayName(ud, m) || 'Unknown';
          const roleLabel = srv?.ownerId === m.userId ? ' (Owner)' : m.role === 'admin' ? ' (Admin)' : '';
          const div = document.createElement('div');
          div.className = 'flex items-center gap-2 px-2 py-1.5 rounded hover:bg-discord-dark cursor-pointer';
          div.innerHTML = `
            <div class="relative">
              <div class="w-8 h-8 rounded-full bg-discord-blurple flex items-center justify-center overflow-hidden">
                <img src="${ud.photoURL || ''}" class="w-full h-full object-cover" alt="" onerror="this.style.display='none';this.nextElementSibling.style.display='flex'">
                <span class="hidden text-xs font-bold">${(displayName || '?')[0].toUpperCase()}</span>
              </div>
              <span class="absolute bottom-0 right-0 w-2.5 h-2.5 rounded-full border-2 border-discord-darker ${status === 'online' ? 'bg-discord-green' : status === 'idle' ? 'bg-discord-yellow' : 'bg-gray-500'}"></span>
            </div>
            <span class="text-sm truncate">${escapeHtml(displayName)}<span class="text-gray-500 text-xs">${roleLabel}</span></span>
          `;
          div.onclick = () => renderMemberProfileModal(m.userId);
          el.appendChild(div);
        });
    }

    // ========== GIPHY API (replaces Tenor) ==========
    async function fetchGiphyGifs(term = '', limit = 24) {
      const url = term
        ? `https://api.giphy.com/v1/gifs/search?api_key=${GIPHY_API_KEY}&q=${encodeURIComponent(term)}&limit=${limit}&rating=g`
        : `https://api.giphy.com/v1/gifs/trending?api_key=${GIPHY_API_KEY}&limit=${limit}&rating=g`;
      const res = await fetch(url);
      const data = await res.json();
      if (data.meta?.status !== 200) throw new Error(data.meta?.msg || 'Giphy API error');
      return (data.data || []).map(g => ({
        id: g.id,
        url: g.images?.original?.url || g.images?.fixed_height?.url || '',
        preview: g.images?.fixed_height_small?.url || g.images?.fixed_height?.url || g.images?.original?.url || ''
      })).filter(x => x.url);
    }

    const debouncedGifSearch = debounce(async (term) => {
      const container = document.getElementById('gif-results');
      container.innerHTML = '<div class="flex justify-center py-8"><div class="animate-spin w-8 h-8 border-2 border-discord-blurple border-t-transparent rounded-full"></div></div>';
      try {
        const gifs = await fetchGiphyGifs(term, 24);
        container.innerHTML = '';
        const grid = document.createElement('div');
        grid.className = 'gif-grid max-h-64 overflow-y-auto';
        gifs.forEach(g => {
          const img = document.createElement('img');
          img.src = g.preview;
          img.className = 'w-full h-20 object-cover rounded cursor-pointer hover:opacity-80';
          img.onclick = () => selectGif(g);
          grid.appendChild(img);
        });
        container.appendChild(grid);
      } catch (e) {
        container.innerHTML = '<p class="text-discord-red text-sm">Failed to load GIFs. Check Giphy API key.</p>';
      }
    }, 300);

    function selectGif(gif) {
      pendingAttachments.push({ type: 'image', url: gif.url });
      const prev = document.getElementById('attachment-preview');
      prev.classList.remove('hidden');
      const wrap = document.createElement('div');
      wrap.className = 'flex items-center gap-1';
      wrap.innerHTML = `<img src="${gif.url}" class="w-12 h-12 object-cover rounded" alt=""><button type="button" class="text-discord-red text-xs" data-remove>âœ•</button>`;
      wrap.querySelector('[data-remove]').onclick = () => {
        pendingAttachments = pendingAttachments.filter(a => a.url !== gif.url);
        wrap.remove();
        if (pendingAttachments.length === 0) prev.classList.add('hidden');
      };
      prev.appendChild(wrap);
      modal.closeModal();
    }

    function renderGifModal() {
      modal.open('Search GIFs (Giphy)', `
        <div class="space-y-4">
          <input type="text" id="gif-search" placeholder="Search GIFs..." class="w-full bg-discord-dark border border-discord-darkest rounded px-3 py-2 outline-none focus:border-discord-blurple">
          <div id="gif-results" class="min-h-[200px]"></div>
        </div>
      `);
      document.getElementById('gif-search').oninput = (e) => debouncedGifSearch(e.target.value);
      debouncedGifSearch('');
    }

    function renderEmojiModal() {
      let html = '<div class="space-y-4"><input type="text" id="emoji-search" placeholder="Search emoji..." class="w-full bg-discord-dark border rounded px-3 py-2 outline-none"><div id="emoji-categories" class="max-h-48 overflow-y-auto scrollbar-thin">';
      Object.entries(EMOJI_CATEGORIES).forEach(([cat, emojis]) => {
        html += `<div class="mb-2"><div class="text-xs text-gray-500 mb-1">${cat}</div><div class="flex flex-wrap gap-1">`;
        emojis.forEach(e => { html += `<button type="button" class="text-2xl hover:bg-discord-dark rounded p-1 emoji-btn" data-emoji="${e}">${e}</button>`; });
        html += '</div></div>';
      });
      html += '</div></div>';
      modal.open('Pick Emoji', html);
      document.querySelectorAll('.emoji-btn').forEach(btn => {
        btn.onclick = () => {
          const inp = document.getElementById('message-input');
          inp.value += btn.dataset.emoji;
          inp.focus();
          modal.closeModal();
        };
      });
      document.getElementById('emoji-search').oninput = (e) => {
        const v = e.target.value.toLowerCase();
        document.querySelectorAll('.emoji-btn').forEach(b => {
          b.style.display = !v || b.dataset.emoji.includes(v) ? '' : 'none';
        });
      };
    }

    function renderCreateServerModal() {
      modal.open('Create Server', `
        <form id="create-server-form" class="space-y-4">
          <div>
            <label class="block text-sm text-gray-400 mb-1">Server Name</label>
            <input type="text" id="server-name" placeholder="My Server" class="w-full bg-discord-dark border border-discord-darkest rounded px-3 py-2 outline-none focus:border-discord-blurple">
          </div>
          <div>
            <label class="block text-sm text-gray-400 mb-1">Server Icon (optional)</label>
            <label for="server-icon" class="inline-block px-4 py-2 rounded bg-discord-dark hover:bg-discord-blurple text-gray-300 hover:text-white text-sm font-medium cursor-pointer transition border border-discord-darkest">Choose Image</label>
            <input type="file" id="server-icon" accept="image/*" class="hidden">
          </div>
          <button type="submit" class="w-full py-2 bg-discord-blurple hover:bg-indigo-600 rounded font-medium">Create</button>
        </form>
      `);
      document.getElementById('create-server-form').onsubmit = (e) => {
        e.preventDefault();
        createServer(document.getElementById('server-name').value, document.getElementById('server-icon').files?.[0]);
      };
    }

    function renderCreateChannelModal() {
      modal.open('Create Channel', `
        <form id="create-channel-form" class="space-y-4">
          <div>
            <label class="block text-sm text-gray-400 mb-1">Channel Name</label>
            <input type="text" id="channel-name" placeholder="new-channel" class="w-full bg-discord-dark border border-discord-darkest rounded px-3 py-2 outline-none focus:border-discord-blurple">
          </div>
          <button type="submit" class="w-full py-2 bg-discord-blurple hover:bg-indigo-600 rounded font-medium">Create</button>
        </form>
      `);
      document.getElementById('create-channel-form').onsubmit = (e) => {
        e.preventDefault();
        createChannel(document.getElementById('channel-name').value.replace(/\s/g, '-').toLowerCase() || 'new-channel');
      };
    }

    function updateUserPill() {
      const name = currentUser?.displayName || 'User';
      document.getElementById('user-display-name').textContent = name;
      document.getElementById('user-initial').textContent = name[0].toUpperCase();
      const img = document.getElementById('user-avatar');
      if (currentUser?.photoURL) { img.src = currentUser.photoURL; img.style.display = 'block'; document.getElementById('user-initial').style.display = 'none'; }
      else { img.style.display = 'none'; document.getElementById('user-initial').style.display = 'flex'; }
    }

    document.getElementById('user-pill').onclick = () => renderProfileModal();

    document.getElementById('btn-login').onclick = renderLoginModal;
    document.getElementById('btn-signup').onclick = renderSignupModal;
    document.getElementById('btn-join-invite').onclick = renderJoinModal;
    document.getElementById('btn-join-server').onclick = renderJoinModal;
    document.getElementById('btn-add-server').onclick = renderCreateServerModal;
    document.getElementById('btn-invite').onclick = createInvite;
    document.getElementById('btn-leave-server').onclick = leaveServer;
    document.getElementById('btn-add-channel').onclick = renderCreateChannelModal;
    document.getElementById('btn-emoji').onclick = renderEmojiModal;
    document.getElementById('btn-gif').onclick = renderGifModal;
    document.getElementById('btn-send').onclick = sendMessage;
    document.getElementById('btn-load-more').onclick = loadOlderMessages;
    document.getElementById('btn-members-toggle').onclick = () => document.getElementById('members-sidebar').classList.toggle('hidden');
    document.getElementById('btn-toggle-channel').onclick = () => document.getElementById('channel-sidebar').classList.toggle('hidden');
    document.addEventListener('visibilitychange', () => {
      if (!currentUser?.uid) return;
      updatePresence(document.hidden ? 'idle' : 'online').catch(() => {});
    });
    window.addEventListener('pagehide', () => {
      if (!currentUser?.uid) return;
      updatePresence('offline').catch(() => {});
    });

    document.getElementById('message-input').onkeydown = (e) => {
      if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); sendMessage(); }
      if (e.key === 'Escape') { replyingTo = null; document.getElementById('reply-preview').classList.add('hidden'); }
    };
    document.getElementById('reply-cancel').onclick = () => {
      replyingTo = null;
      document.getElementById('reply-preview').classList.add('hidden');
    };
    document.getElementById('message-input').oninput = () => updateTyping(true);

    document.getElementById('btn-attach').onclick = () => document.getElementById('file-attach').click();
    document.getElementById('file-attach').onchange = async (e) => {
      const file = e.target.files?.[0];
      if (!file) return;
      try {
        const uploadAt = Date.now();
        const storagePath = `messages/${currentUser.uid}/${uploadAt}_${file.name}`;
        const r = ref(storage, storagePath);
        await uploadBytes(r, file, { contentType: file.type || 'application/octet-stream' });
        const url = await getDownloadURL(r);
        const attachment = {
          type: file.type.startsWith('image/') ? 'image' : 'file',
          url,
          storagePath,
          uploadedAt: uploadAt,
          expiresAt: uploadAt + ATTACHMENT_TTL_MS,
          name: file.name || 'Attachment',
          size: file.size || 0,
          mimeType: file.type || 'application/octet-stream'
        };
        pendingAttachments.push(attachment);
        const prev = document.getElementById('attachment-preview');
        prev.classList.remove('hidden');
        const wrap = document.createElement('div');
        const safeUrl = escapeHtml(url);
        const safeName = escapeHtml(attachment.name);
        if (attachment.type === 'image') {
          wrap.className = 'flex items-center gap-1';
          wrap.innerHTML = `<img src="${safeUrl}" class="w-12 h-12 object-cover rounded" alt="${safeName}"><button type="button" class="text-discord-red text-xs" data-remove>x</button>`;
        } else {
          wrap.className = 'flex items-center gap-2 px-2 py-1 rounded bg-discord-darkest/70';
          wrap.innerHTML = `<span class="text-xs text-gray-300 max-w-[160px] truncate" title="${safeName}">${safeName}</span><button type="button" class="text-discord-red text-xs" data-remove>x</button>`;
        }
        wrap.querySelector('[data-remove]').onclick = () => {
          pendingAttachments = pendingAttachments.filter(a => a.url !== url);
          wrap.remove();
          if (pendingAttachments.length === 0) prev.classList.add('hidden');
        };
        prev.appendChild(wrap);
      } catch (err) { showToast(err.message, 'error'); }
      e.target.value = '';
    };

    onAuthStateChanged(auth, async (user) => {
      if (user) {
        const userRef = doc(db, 'users', user.uid);
        const u = await getDoc(userRef);
        const existing = u.data() || {};
        const ensuredProfile = {
          displayName: existing.displayName || user.displayName || user.email?.split('@')[0] || 'User',
          photoURL: existing.photoURL || user.photoURL || '',
          bio: existing.bio || '',
          status: existing.status || 'offline'
        };
        if (!u.exists()) ensuredProfile.createdAt = serverTimestamp();
        await setDoc(userRef, ensuredProfile, { merge: true });
        const d = ensuredProfile;
        currentUser = { uid: user.uid, displayName: d?.displayName || user.email?.split('@')[0], bio: d?.bio || '', photoURL: d?.photoURL || user.photoURL || '' };
        document.getElementById('auth-screen').classList.add('hidden');
        document.getElementById('main-app').classList.remove('hidden');
        updateUserPill();
        await updatePresence('online');
        startPresenceHeartbeat();
        startAttachmentCleanupScheduler();
        loadServers();
        const params = new URLSearchParams(location.search);
        const invite = params.get('invite');
        if (invite) { renderJoinModal(); document.getElementById('invite-code').value = invite; }
      } else {
        stopPresenceHeartbeat();
        stopAttachmentCleanupScheduler();
        stopActiveSuspensionWatcher();
        if (unsubMyMemberships) { unsubMyMemberships(); unsubMyMemberships = null; }
        if (unsubMembers) { unsubMembers(); unsubMembers = null; }
        if (unsubReports) { unsubReports(); unsubReports = null; }
        reportAlertInitialized = false;
        seenReportAlerts.clear();
        openReports = {};
        clearMemberUserListeners();
        memberUserData = {};
        userPresence = {};
        currentUser = null;
        document.getElementById('auth-screen').classList.remove('hidden');
        document.getElementById('main-app').classList.add('hidden');
      }
    });
  </script>
</body>
</html>
